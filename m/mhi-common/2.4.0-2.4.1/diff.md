# Comparing `tmp/mhi_common-2.4.0-py3-none-any.whl.zip` & `tmp/mhi_common-2.4.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,23 @@
-Zip file size: 41140 bytes, number of entries: 20
--rw-rw-rw-  2.0 fat      855 b- defN 24-Mar-06 19:54 mhi/common/__init__.py
--rw-rw-rw-  2.0 fat      165 b- defN 23-Aug-04 14:43 mhi/common/__main__.py
--rw-rw-rw-  2.0 fat     3681 b- defN 23-Aug-04 14:43 mhi/common/_script.py
--rw-rw-rw-  2.0 fat     2943 b- defN 23-Aug-04 14:43 mhi/common/arrow.py
--rw-rw-rw-  2.0 fat      903 b- defN 23-Aug-04 14:43 mhi/common/cdata.py
--rw-rw-rw-  2.0 fat    11886 b- defN 24-Mar-06 19:53 mhi/common/codec.py
--rw-rw-rw-  2.0 fat     2211 b- defN 23-Aug-04 14:43 mhi/common/collection.py
--rw-rw-rw-  2.0 fat    32864 b- defN 23-Aug-04 14:43 mhi/common/colour.py
--rw-rw-rw-  2.0 fat     2208 b- defN 23-Aug-04 14:43 mhi/common/config.py
--rw-rw-rw-  2.0 fat     6859 b- defN 23-Aug-04 14:43 mhi/common/path.py
--rw-rw-rw-  2.0 fat    19943 b- defN 24-Feb-08 15:20 mhi/common/process.py
--rw-rw-rw-  2.0 fat    26993 b- defN 24-Mar-06 19:53 mhi/common/remote.py
--rw-rw-rw-  2.0 fat    22365 b- defN 24-Feb-08 15:20 mhi/common/server.py
--rw-rw-rw-  2.0 fat     2860 b- defN 23-Aug-04 14:43 mhi/common/version.py
--rw-rw-rw-  2.0 fat    11270 b- defN 23-Aug-04 14:43 mhi/common/zipper.py
--rw-rw-rw-  2.0 fat     1731 b- defN 24-Mar-06 19:56 mhi_common-2.4.0.dist-info/LICENSE
--rw-rw-rw-  2.0 fat     1457 b- defN 24-Mar-06 19:56 mhi_common-2.4.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat       92 b- defN 24-Mar-06 19:56 mhi_common-2.4.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        4 b- defN 24-Mar-06 19:56 mhi_common-2.4.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     1564 b- defN 24-Mar-06 19:56 mhi_common-2.4.0.dist-info/RECORD
-20 files, 152854 bytes uncompressed, 38638 bytes compressed:  74.7%
+Zip file size: 41902 bytes, number of entries: 21
+-rw-rw-rw-  2.0 fat      855 b- defN 24-Apr-02 22:38 mhi/common/__init__.py
+-rw-rw-rw-  2.0 fat      237 b- defN 24-Apr-02 22:38 mhi/common/__main__.py
+-rw-rw-rw-  2.0 fat     3695 b- defN 24-Apr-02 22:38 mhi/common/_script.py
+-rw-rw-rw-  2.0 fat     3051 b- defN 24-Apr-02 22:38 mhi/common/arrow.py
+-rw-rw-rw-  2.0 fat      903 b- defN 24-Apr-02 20:17 mhi/common/cdata.py
+-rw-rw-rw-  2.0 fat    12414 b- defN 24-Apr-02 22:38 mhi/common/codec.py
+-rw-rw-rw-  2.0 fat     1392 b- defN 24-Apr-02 22:38 mhi/common/collection.py
+-rw-rw-rw-  2.0 fat    33053 b- defN 24-Apr-02 22:38 mhi/common/colour.py
+-rw-rw-rw-  2.0 fat     2226 b- defN 24-Apr-02 22:38 mhi/common/config.py
+-rw-rw-rw-  2.0 fat     1002 b- defN 24-Apr-02 22:38 mhi/common/help.py
+-rw-rw-rw-  2.0 fat     6238 b- defN 24-Apr-02 22:38 mhi/common/path.py
+-rw-rw-rw-  2.0 fat    20708 b- defN 24-Apr-02 22:38 mhi/common/process.py
+-rw-rw-rw-  2.0 fat    27638 b- defN 24-Apr-02 22:38 mhi/common/remote.py
+-rw-rw-rw-  2.0 fat    22390 b- defN 24-Apr-02 22:38 mhi/common/server.py
+-rw-rw-rw-  2.0 fat     3156 b- defN 24-Apr-02 22:38 mhi/common/version.py
+-rw-rw-rw-  2.0 fat    11462 b- defN 24-Apr-02 22:38 mhi/common/zipper.py
+-rw-rw-rw-  2.0 fat     1731 b- defN 24-Apr-02 22:39 mhi_common-2.4.1.dist-info/LICENSE
+-rw-rw-rw-  2.0 fat     1631 b- defN 24-Apr-02 22:39 mhi_common-2.4.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat       92 b- defN 24-Apr-02 22:39 mhi_common-2.4.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        4 b- defN 24-Apr-02 22:39 mhi_common-2.4.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     1639 b- defN 24-Apr-02 22:39 mhi_common-2.4.1.dist-info/RECORD
+21 files, 155517 bytes uncompressed, 39288 bytes compressed:  74.7%
```

## zipnote {}

```diff
@@ -21,14 +21,17 @@
 
 Filename: mhi/common/colour.py
 Comment: 
 
 Filename: mhi/common/config.py
 Comment: 
 
+Filename: mhi/common/help.py
+Comment: 
+
 Filename: mhi/common/path.py
 Comment: 
 
 Filename: mhi/common/process.py
 Comment: 
 
 Filename: mhi/common/remote.py
@@ -39,23 +42,23 @@
 
 Filename: mhi/common/version.py
 Comment: 
 
 Filename: mhi/common/zipper.py
 Comment: 
 
-Filename: mhi_common-2.4.0.dist-info/LICENSE
+Filename: mhi_common-2.4.1.dist-info/LICENSE
 Comment: 
 
-Filename: mhi_common-2.4.0.dist-info/METADATA
+Filename: mhi_common-2.4.1.dist-info/METADATA
 Comment: 
 
-Filename: mhi_common-2.4.0.dist-info/WHEEL
+Filename: mhi_common-2.4.1.dist-info/WHEEL
 Comment: 
 
-Filename: mhi_common-2.4.0.dist-info/top_level.txt
+Filename: mhi_common-2.4.1.dist-info/top_level.txt
 Comment: 
 
-Filename: mhi_common-2.4.0.dist-info/RECORD
+Filename: mhi_common-2.4.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mhi/common/__init__.py

```diff
@@ -6,15 +6,15 @@
 internally by the application specific packages.
 """
 
 #===============================================================================
 # Script Version Identifiers
 #===============================================================================
 
-_VERSION = (2, 4, 0)
+_VERSION = (2, 4, 1)
 
 _TYPE = 'f0'
 
 VERSION = '{0}.{1}.{2}'.format(*_VERSION, _TYPE)
 VERSION_HEX = int.from_bytes((*_VERSION, int(_TYPE, 16)), byteorder='big')
 
 __all__ = [] # type: ignore
```

## mhi/common/__main__.py

```diff
@@ -1,11 +1,17 @@
 """
 Common Library Version Report Application
 """
 
 from . import version_msg
 
+
 def main():
+    """
+    CLI main function - report package version
+    """
+
     print(version_msg())
 
+
 if __name__ == '__main__':
     main()
```

## mhi/common/_script.py

```diff
@@ -13,15 +13,17 @@
 *** For internal application use only ***
 """
 
 #===============================================================================
 # Imports
 #===============================================================================
 
-import sys, threading, traceback
+import sys
+import threading
+import traceback
 
 from ctypes import c_long, py_object, pythonapi
 from linecache import clearcache
 
 from .remote import Context
```

## mhi/common/arrow.py

```diff
@@ -19,15 +19,15 @@
     ================= =====
 """
 
 #===============================================================================
 # Imports
 #===============================================================================
 
-from typing import Sequence, Union
+from typing import Sequence, Set, Union
 
 from .codec import KeywordCodec
 
 
 
 #===============================================================================
 # Arrow CODEC
@@ -53,15 +53,15 @@
 
         Returns:
             bool: ``True`` if ``keyword`` is ``'arrows'``, ``False`` otherwise
         """
 
         return keyword in self._KEYS
 
-    def encode(self, dirs: Union[int, str, Sequence[str]]) -> int: # pylint: disable=arguments-differ
+    def encode(self, dirs: Union[int, str, Sequence[str]]) -> int: # pylint: disable=arguments-differ,arguments-renamed
         """
         Encode one or more directions into an bit-encoded integer::
 
             >>> arrow.encode("N S")
             3
             >>> arrow.encode(["E", "W"])
             12
@@ -78,15 +78,15 @@
                 return dirs
             if isinstance(dirs, str):
                 dirs = dirs.split()
             return sum(self._DIR[direction.upper()] for direction in dirs)
 
         return 0
 
-    def decode(self, dirs: Union[str, int]) -> str:       # pylint: disable=arguments-differ
+    def decode(self, dirs: Union[str, int]) -> str:       # pylint: disable=arguments-differ,arguments-renamed
         """
         Decode a bit-encoded integer string into a direction string::
 
             >>> arrow.decode("15")
             'N S W E'
 
         Parameters:
@@ -97,7 +97,10 @@
         """
 
         if isinstance(dirs, str):
             dirs = int(dirs)
 
         return " ".join(key
                         for key, val in self._DIR.items() if (dirs & val) != 0)
+
+    def range(self) -> Set[str]:
+        return set(self._DIR)
```

## mhi/common/codec.py

```diff
@@ -1,68 +1,75 @@
-#! /usr/bin/env python3
 """
 Encode user-friendly values into internal formats used by the application,
 and decoder the values back into user-friendly values.
 """
 
 #===============================================================================
 # Imports
 #===============================================================================
 
-from typing import Any, Tuple, FrozenSet, Dict
+from typing import Any, FrozenSet, Dict
 from warnings import warn
 
 
 #===============================================================================
 # Coder/Decoder
 #===============================================================================
 
 class Codec:
-
     """
     Codec: Coder / Decoder
 
     Encode from user-friendly values into an internal value format,
     and decode from the internal format into (ideally) a user-friendly
     value.
     """
 
-    def encode(self, value: Any) -> Any: # pylint: disable=unused-argument,no-self-use
+    def encode(self, value: Any) -> Any:    # pylint: disable=unused-argument
         """
         Encode a user-friendly value into an internal format
 
         Parameters:
            value: the value to encode
 
         Returns:
             the encoded value
         """
 
         raise NotImplementedError()
 
-    def decode(self, value: Any) -> Any: # pylint: disable=unused-argument,no-self-use
+    def decode(self, value: Any) -> Any:    # pylint: disable=unused-argument
         """
         Decode an internal format value into a more user-friendly format
 
         Parameters:
            value: the value to decode
 
         Returns:
             the decoded value
         """
 
         raise NotImplementedError()
 
 
+    def range(self):
+        """
+        Returns the range of values that this codec will encode,
+        as in, maybe passed to :meth:`.encode` and will
+        be returned by :meth:`.decode`.
+        """
+
+        raise NotImplementedError()
+
+
 #===============================================================================
 # Boolean Coder/Decoder
 #===============================================================================
 
 class BooleanCodec(Codec):
-
     """
     Boolean Coder / Decoder
 
     Convert Python boolean values to/from the strings `"true"` and `"false"`,
     used by MHI application serialization.
     """
 
@@ -108,34 +115,33 @@
 
         Returns:
             bool: the decoded value
         """
 
         return value.lower() == "true"
 
-    @staticmethod
-    def range() -> Tuple[bool, bool]:
+
+    def range(self) -> set[bool]:
         """
         Returns the range of values that this codec will encode,
         as in, maybe passed to :meth:`.encode` and will
         be returned by :meth:`.decode`.
 
         Returns:
-            Tuple[Bool, Bool]: ``False, True``
+            ``{False, True}``
         """
 
-        return False, True
+        return {False, True}
 
 
 #===============================================================================
 # Map Coder/Decoder
 #===============================================================================
 
 class MapCodec(Codec):
-
     """
     Map Coder / Decoder
 
     Convert Python values to/from the strings,
     used by MHI application serialization.
     """
 
@@ -200,24 +206,23 @@
 
 
 #===============================================================================
 # Keyword Coder/Decoder
 #===============================================================================
 
 class KeywordCodec(Codec):
-
     """
     Keyword Codec
 
     Encode values for specific keys of a dictionary from user-friendly values
     into an internal value format, and decode values for those specific keys
     from the internal format into (ideally) a user-friendly value.
     """
 
-    def encodes(self, keyword: str): # pylint: disable=unused-argument,no-self-use
+    def encodes(self, keyword: str):        # pylint: disable=unused-argument
         """
         Predicate, indicating whether or not this keyword codec will encode
         and decode a particular keyword
 
         Parameters:
             keyword (str): keyword to test
 
@@ -259,15 +264,20 @@
                 for key, value in kwargs.items()}
 
 
 #===============================================================================
 # CodecMap
 #===============================================================================
 
-class CodecMap(KeywordCodec):
+class CodecMap:
+    """
+    A collection of codecs for encoding/decoding a dictionary of values
+
+    The dictionary keys are used to select the codec used for that entry.
+    """
 
     def __init__(self, **codecs):
         self._codecs = codecs
 
     def _encode(self, keyword: str, value: Any) -> Any:
         codec = self._codecs.get(keyword)
         if codec is not None:
@@ -277,20 +287,32 @@
     def _decode(self, keyword: str, value: str) -> Any:
         codec = self._codecs.get(keyword)
         if codec is not None:
             value = codec.decode(value)
         return value
 
     def encode_all(self, kwargs: Dict[str, Any]) -> Dict[str, Any]:
+        """
+        Encode a dictionary of values
+        """
+
         return {key: self._encode(key, value) for key, value in kwargs.items()}
 
     def decode_all(self, kwargs: Dict[str, Any]) -> Dict[str, Any]:
+        """
+        Decode a dictionary of values
+        """
+
         return {key: self._decode(key, value) for key, value in kwargs.items()}
 
     def range(self, keyword) -> Any:
+        """
+        Return the valid range for a given parameter (key)
+        """
+
         return self._codecs[keyword].range()
 
 
 #===============================================================================
 # Coder/Decoder
 #===============================================================================
 
@@ -319,15 +341,15 @@
 			>>> codec.encode_all({'animal': 'lion', 'fruit': 'pear'})
 			{'animal': 'lion', 'fruit': 3}
     """
 
     def __init__(self, code_dict=None, **codes):
 
         if code_dict is None:
-            self._code = dict(**codes)
+            self._code = {**codes}
         else:
             self._code = dict(code_dict, **codes)
         self._decode = {str(val): key for key, val in self._code.items()}
         self._keys = set()
 
     def alternates(self, code_dict, **codes):
         """
```

## mhi/common/collection.py

```diff
@@ -1,17 +1,18 @@
-#! /usr/bin/env python3
 """
 General purpose utilities
 """
 
 #===============================================================================
 # Imports
 #===============================================================================
 
-import collections, itertools
+import collections
+import itertools
+
 
 #===============================================================================
 # Indexable Dictionary
 #===============================================================================
 
 class IndexableDict(collections.OrderedDict):
 
@@ -37,33 +38,7 @@
         if isinstance(key, int):
             num = len(self)
             if key < -num or key >= num:
                 raise IndexError()
             idx = key if key >= 0 else num + key
             return next(itertools.islice(self.values(), idx, idx + 1))
         return super().__getitem__(key)
-
-
-#===============================================================================
-# Unit tests
-#===============================================================================
-
-if __name__ == '__main__':
-    d = IndexableDict([('foo', 10), ('bar', 30)])
-    d['baz'] = 20
-
-    assert d['foo'] == d[0] == d[-3] == 10
-    assert d['bar'] == d[1] == d[-2] == 30
-    assert d['baz'] == d[2] == d[-1] == 20
-
-    try:
-        assert d[3] and False, "IndexError expected: 3 is out of range."
-    except IndexError:
-        pass
-    try:
-        assert d[-4] and False, "IndexError expected: -4 is out of range."
-    except IndexError:
-        pass
-
-    # keys and values are ordered...
-    assert tuple(d.keys()) == ('foo', 'bar', 'baz')
-    assert tuple(d.values()) == (10, 30, 20)
```

## mhi/common/colour.py

```diff
@@ -4,17 +4,18 @@
 and RGB integer values.  Standard Windows and CSS colour names are recognized.
 """
 
 #===============================================================================
 # Imports
 #===============================================================================
 
-from typing import Dict, Union, Sequence
+from typing import Dict, Union, Sequence, Set
 from . import codec
 
+
 #===============================================================================
 # Colour CODEC
 #===============================================================================
 
 class Colour(codec.KeywordCodec):
     """
     Colour Coder / Decoder
@@ -111,15 +112,15 @@
         Returns:
             bool: ``True`` if ``keyword`` is ``'fg_color'``, ``'bg_color'``,
             or ``'true-color'``, ``False`` otherwise
         """
         return keyword in self._KEYS
 
 
-    def encode(self, colour: Union[str, int, Sequence[int]]) -> str: # pylint: disable=arguments-differ
+    def encode(self, colour: Union[str, int, Sequence[int]]) -> str: # pylint: disable=arguments-differ,arguments-renamed
         """
         Encode a named colour into an #ARGB value::
 
             >>> colour = Colour()
             >>> colour.encode("RED")
             #ffff0000
             >>> colour.encode((0, 0, 255))
@@ -132,15 +133,15 @@
 
         Returns:
             str: the #ARGB value
         """
 
         return self.colour_to_argb(colour)
 
-    def decode(self, colour: str) -> str:     # pylint: disable=arguments-differ
+    def decode(self, colour: str) -> str:     # pylint: disable=arguments-differ,arguments-renamed
         """
         Decode an ARGB value into a named colour, if possible::
 
             >>> colour = Colour()
             >>> colour.decode(str(0xFFFFFF))
             'white'
             >>> colour.decode(str(0x9AFA00))
@@ -156,14 +157,22 @@
         Returns:
             str: the name of the colour
         """
 
         return self.argb_to_colour(colour)
 
 
+    def range(self) -> Set[str]:
+        """
+        Return the set of known colour names
+        """
+
+        return set(self._COLOUR)
+
+
 # Colours from Window's online document
 
 # pylint: disable=protected-access
 Colour._windows_colour("aliceblue", 0xF0F8FF)
 Colour._windows_colour("antiquewhite", 0xFAEBD7)
 Colour._windows_colour("aqua", 0x00FFFF)
 Colour._windows_colour("aquamarine", 0x7FFFD4)
```

## mhi/common/config.py

```diff
@@ -35,15 +35,15 @@
     """
 
     if not kwargs:
         raise ValueError("No global variables given")
 
     filename = os.path.expanduser(os.path.expandvars(filename))
     if os.path.isfile(filename):
-        with open(filename) as file:
+        with open(filename, encoding='utf-8') as file:
             exec(file.read(), kwargs)                # pylint: disable=exec-used
 
 def fetch(filename: str, name: str = "OPTIONS", value: Any = None):
     """
     Configuration Reader
 
     Execute a configuration script, passing only one named object to the script.
```

## mhi/common/path.py

```diff
@@ -1,15 +1,17 @@
 #! /usr/bin/env python3
 """
 Conversion between pathnames with and without expanded %ENVIRONMENT_VARIABLES%.
 """
 
-import os, winreg
+import os
+import winreg
 from pathlib import Path
-from typing import Dict, List, Sequence, Tuple
+from typing import Dict, List, Optional, Sequence
+
 
 #===============================================================================
 # When run from IDLE, if the HOME environment is not set, Tkinter is setting it
 # to %HOMEDRIVE%%HOMEPATH% ... which can be wrong under Windows.
 #    https://bugs.python.org/issue27263
 # Attempt to detect and restore to correct default
 #===============================================================================
@@ -24,15 +26,16 @@
                 del os.environ['HOME']
 
 
 #===============================================================================
 # Expand Path
 #===============================================================================
 
-def expand_path(path: str, abspath: bool = False, folder: str = None) -> str:
+def expand_path(path: str, abspath: bool = False,
+                folder: Optional[str] = None) -> str:
     """
     Expand ``path``, by replacing a `~` or `~user` prefix, as well as
     expanding any `$var`, `${var}` and `%var%` patterns in the path.
 
     Parameters:
         path (str): The path to be expanded.
         abspath (bool): If `True`, convert resulting path to an absolute path.
@@ -49,15 +52,15 @@
     path = os.path.normpath(os.path.expanduser(os.path.expandvars(path)))
     if abspath:
         path = os.path.abspath(path)
 
     return path
 
 def expand_paths(paths: Sequence[str], abspath: bool = False,
-                 folder: str = None) -> List[str]:
+                 folder: Optional[str] = None) -> List[str]:
     """
     Expand ``paths``, by replacing a `~` or `~user` prefix, as well as
     expanding any `$var`, `${var}` and `%var%` patterns in the paths.
 
     Parameters:
         path (List[str]): A list of paths to be expanded.
         abspath (bool): If `True`, convert resulting paths to absolute paths.
@@ -72,16 +75,17 @@
     return [expand_path(path, abspath, folder) for path in paths]
 
 
 #===============================================================================
 # Contract Path
 #===============================================================================
 
-def contract_path(path: str, *, keys: List[str] = None, # pylint: disable=too-many-branches
-                  reverse_map: Dict[str, str] = None) -> str:
+def contract_path(path: str, *,             # pylint: disable=too-many-branches
+                  keys: Optional[List[str]] = None,
+                  reverse_map: Optional[Dict[str, str]] = None) -> str:
     """contract_path(path)
 
     Look for and replace any substring of the path that matches a value
     found in an environment variable with that environment variable:
     `${key}` or `%key%`.  Additionally, replace a path starting with
     the user's home path with `~`.
 
@@ -169,27 +173,7 @@
 
     if value_type == winreg.REG_EXPAND_SZ:
         value = os.path.expandvars(value)
     elif value_type != winreg.REG_SZ:
         raise ValueError("Shell Folder %r is not a string" % (name,))
 
     return Path(value)
-
-
-#===============================================================================
-# Self test
-#===============================================================================
-
-if __name__ == "__main__":
-
-    PATHS = [r'%LOCALAPPDATA%\Manitoba HVDC Research Centre\Enerplot',
-             r'%PUBLIC%\Documents\Enerplot\1.0\Examples\EnerplotExamples.pswx',
-             r'%TMP%\tempfile',
-             r'~\my\doc',
-             r'~']
-
-    PATHS1 = expand_paths(PATHS)
-    PATHS2 = contract_paths(PATHS1)
-
-    for p, p1, p2 in zip(PATHS, PATHS1, PATHS2):
-        assert p != p1, "expand('%s') == '%s': must differ" % (p, p1)
-        assert p == p2, "'%s' expands to '%s' contacts to '%s'" % (p, p1, p2)
```

## mhi/common/process.py

```diff
@@ -4,26 +4,36 @@
 Process launching and querying
 """
 
 #===============================================================================
 # Imports
 #===============================================================================
 
-import logging, os, subprocess, random
-from .version import Version, InvalidVersion
+import logging
+import os
+import subprocess
+import random
 from typing import Any, Dict, Iterator, List, Optional, Set, Tuple
 
+import ctypes
+import socket
+import struct
+
 # Pywin32
 from winreg import EnumKey as _EnumKey
 from winreg import OpenKey as _OpenKey, CloseKey as _CloseKey
 from winreg import QueryValueEx as _QueryValueEx
 from winreg import HKEY_LOCAL_MACHINE as _HKLM, KEY_READ as _KEY_READ
 from winreg import KEY_WOW64_32KEY as _KEY32, KEY_WOW64_64KEY as _KEY64
 from winreg import REG_SZ as _REG_SZ
-import ctypes, socket, struct, win32con, win32com.client
+
+import win32con
+import win32com.client
+
+from .version import Version
 
 
 #===============================================================================
 # Pywin32, socket, related window constants, structures
 #===============================================================================
 
 
@@ -330,15 +340,16 @@
             yield _EnumKey(key, i)
             i += 1
         except OSError as ex:
             if ex.winerror == _ERROR_NO_MORE_ITEMS: # type: ignore
                 break
             raise
 
-def _app_path(app_name: str) -> List[Dict[str, str]]:
+
+def _app_path(app_name: str) -> Tuple[Dict[str, str],Dict[str, str]]:
 
     app_paths = []
 
     company_names = ['Manitoba HVDC Research Centre Inc',
                      'Manitoba Hydro International']
 
     for access in (_KEY32, _KEY64):     # pylint: disable=too-many-nested-blocks
@@ -358,17 +369,18 @@
                         pass
                     _CloseKey(subkey)
                 _CloseKey(key)
             except FileNotFoundError:
                 pass
         app_paths.append(paths)
 
-    return app_paths
+    return app_paths[0], app_paths[1]
+
 
-def _exe_path(app_name: str) -> List[Dict[str, str]]:
+def _exe_path(app_name: str) -> Tuple[Dict[str, str],Dict[str, str]]:
 
     exe_paths = []
 
     for app_paths in _app_path(app_name):
         paths = {}
 
         for version, path in app_paths.items():
@@ -378,15 +390,16 @@
             else:
                 exe = os.path.join(path, app_name + version + '.exe')
                 if os.path.isfile(exe):
                     paths[version] = exe
 
         exe_paths.append(paths)
 
-    return exe_paths
+    return exe_paths[0], exe_paths[1]
+
 
 def versions(app_name: str) -> List[Tuple[str, bool]]:
     """
     Find the installed versions of an MHI application.
 
     Returns:
         List[Tuple]: List of tuples of version and bit-size
@@ -397,15 +410,15 @@
     versions_all = [(version, True) for version in versions64]
     for version in versions32:
         versions_all.append((version, False))
 
     return versions_all
 
 
-def find_exe(app_name: str,
+def find_exe(app_name: str,                 # pylint: disable=too-many-arguments
              version: Optional[str] = None, x64: Optional[bool] = None,
              minimum: Optional[str] = None, maximum: Optional[str] = None,
              allow_alpha: bool = True, allow_beta: bool = True
              ) -> Optional[str]:
 
     """
     Find an MHI application executable.
@@ -469,15 +482,15 @@
         version = max(filtered, default=None, key=Version)
         if version is None:
             return None
 
     return filtered.get(version, None)
 
 
-def launch(*args: str, options: Dict[str, Any] = None, **kwargs):
+def launch(*args: str, options: Optional[Dict[str, Any]] = None, **kwargs):
 
     """
     Launch an application process.
 
     All ``{keyword}`` format codes in the list of ``args`` strings are
     replaced by the value in the corresponding ``options`` dictionary and/or
     ``kwargs`` key-value argument pairs.
@@ -546,41 +559,57 @@
             sui.dwFlags |= subprocess.STARTF_USESHOWWINDOW
             sui.wShowWindow = win32con.SW_SHOWMINNOACTIVE
         else:
             sui.dwFlags |= subprocess.STARTF_USESHOWWINDOW
             sui.wShowWindow = win32con.SW_SHOWNOACTIVATE
 
     # Launch the subprocess
-    proc = subprocess.Popen(args, close_fds=True, startupinfo=sui)
+    proc = subprocess.Popen(args, close_fds=True, startupinfo=sui) # pylint: disable=consider-using-with
     _LOG.debug("Process ID = %d", proc.pid)
 
     return proc
 
 
 #===============================================================================
-# Unit test
+# Process Report
 #===============================================================================
 
-if __name__ == '__main__':
+def report(installed=True, minimums=False, running=True):
+    """
+    Report known, installed MHI products
+    """
 
-    # Show executables for known apps, but it is ok if they aren't installed.
     fmt = "    {0:<8} = {1}"
-    
-    print("Installed")
-    for app in ('PSCAD', 'Enerplot'):
-        exe = find_exe(app)
-        print(fmt.format(app, exe))
-    print()
-
-##    print("Installed executables (minimum versions)")
-##    for app, minimum in {'PSCAD': '5.0', 'Enerplot': '1.1'}.items():
-##        exe = find_exe(app, minimum=minimum, allow_alpha=False, allow_beta=False)
-##        print(fmt.format(app, exe))
-##    print()
-
-    print("Running")
-    fmt = "    {0:<15} {1:<5} {2:<5} {3}"
-    print(fmt.format("Address", "Port", "PID", "Executable"))
-    for app_name in ('PSCAD%', 'Enerplot%'):
-        for data in listener_ports_by_name(app_name):
-            print(fmt.format(*data))
-    print()
+
+    # Show executables for known apps, but it is ok if they aren't installed.
+    if installed:
+        print("Installed executables")
+        for app in ('PSCAD', 'Enerplot'):
+            exe = find_exe(app)
+            print(fmt.format(app, exe))
+        print()
+
+        # Installed executables w/ enforced minimums
+        if minimums:
+            print("Installed executables (minimum versions)")
+            for app, minimum in {'PSCAD': '5.0', 'Enerplot': '1.1'}.items():
+                exe = find_exe(app, minimum=minimum,
+                               allow_alpha=False, allow_beta=False)
+                print(fmt.format(app, exe))
+            print()
+
+    if running:
+        print("Running")
+        fmt = "    {0:<15} {1:<5} {2:<5} {3}"
+        print(fmt.format("Address", "Port", "PID", "Executable"))
+        for app_name in ('PSCAD%', 'Enerplot%'):
+            for data in listener_ports_by_name(app_name):
+                print(fmt.format(*data))
+        print()
+
+
+#===============================================================================
+# CLI Utility
+#===============================================================================
+
+if __name__ == '__main__':
+    report()
```

## mhi/common/remote.py

```diff
@@ -1,13 +1,22 @@
 #! /usr/bin/env python3
 """
 Remote method invocation from Python scripts to MHI application entities.
 """
 
-import sys, queue, pickle, io, importlib, time, warnings, socket, threading
+import importlib
+import io
+import pickle
+import queue
+import socket
+import sys
+import threading
+import time
+import warnings
+
 from typing import Any, Dict, Optional, Union, Tuple, TYPE_CHECKING
 from functools import wraps
 from .version import Version
 
 
 #===============================================================================
 # Window constants
@@ -80,31 +89,33 @@
         return self._context._main            # pylint: disable=protected-access
 
 
 #===============================================================================
 # Remote Method Invocation
 #===============================================================================
 
-class rmi_property(property):
+class rmi_property(property):                   # pylint: disable=invalid-name
 
     """
     A property which is stored in a remote object
 
     Apply this decorator to a property of a :class:`.Remotable` object causes
     the property access attempts to be forwarded to the remote application
     object.
 
     Remote properties may never be deleted.
     """
 
     def _fget(self) -> Any:
         """Undocumented"""
 
-    def __init__(self, fget=None, fset=None, doc=None, name=None,
-                 requires=None):
+    def __init__(self, fget=None,           # pylint: disable=too-many-arguments
+                 fset=None, doc=None, name=None,
+                 requires=None):            # pylint: disable=redefined-outer-name
+
         if fget is True:
             fget = rmi_property._fget
         super().__init__(fget=fget, fset=fset, fdel=None, doc=doc)
         if doc is not None:
             self.__doc__ = doc
         if not name:
             if fget and hasattr(fget, '__name__'):
@@ -136,15 +147,15 @@
         return result
 
     def __set__(self, instance, value):
         if not self.fset:
             raise AttributeError("can't set attribute %s" % self._key)
         if instance is not None:
             if self._required_version:
-                instance.main.requires(self._required_version, method._key)
+                instance.main.requires(self._required_version, self._key)
 
             exception = instance._context._setprop(instance, self._key, value)
             if isinstance(exception, Exception):
                 raise exception
 
     def __delete__(self, instance):
         raise AttributeError("can't delete attribute %s" % self._key)
@@ -247,15 +258,15 @@
         """
 
     #-----------------------------------------------------------------------
     # Common application functions
     #-----------------------------------------------------------------------
 
     @rmi_property(True, True)
-    def silence(self) -> bool:
+    def silence(self) -> bool:                      # type: ignore[empty-body]
         """
         When set to `True`, silence all popup dialogs, using the dialog's
         "default" action.
         """
 
 
     def is_alive(self) -> bool:
@@ -327,15 +338,15 @@
 
         Returns:
             bool: ``True`` if the remote application version is greater than
                 or equal to ``version``, ``False`` otherwise.
         """
 
         if not hasattr(self, '_version'):
-            app_ver = self.version
+            app_ver = self.version                  # type: Union[str, Version]
             if app_ver not in ('Alpha', 'Beta'):
                 app_ver = Version(self.version)
             self._version = app_ver # pylint: disable=attribute-defined-outside-init
 
         if self._version in {'Alpha', 'Beta'}:
             return True
 
@@ -365,42 +376,44 @@
     # Embedded
     #-----------------------------------------------------------------------
 
     @property
     def is_embedded(self) -> bool:
         """Return whether an internal Python environment is being used"""
 
-        return Context._EMBEDDED_SERVER is not None
+        return Context._EMBEDDED_SERVER is not None # pylint: disable=protected-access
 
 
     #-----------------------------------------------------------------------
     # Server Address
     #-----------------------------------------------------------------------
 
     def server_address(self) -> Tuple[str, int]:
         """
         Return the host/port address for the application server, which
         may be used to open additional connections to the application.
         """
 
+        # pylint: disable=protected-access
         if Context._EMBEDDED_SERVER:
             return Context._EMBEDDED_SERVER._server._address
 
-        return self._context._sock.getpeername()
+        return self._context._sock.getpeername()    # type: ignore[attr-defined]
 
 
     #-----------------------------------------------------------------------
     # Secondary Connection
     #-----------------------------------------------------------------------
 
     def secondary_connection(self, timeout=5) -> "Application":
         """
         Open a secondary connection to the application server
         """
 
+        # pylint: disable=protected-access
         host, port = self.server_address()
         app = Context._connect(host, port, timeout)
         app._initialize()
         return app
 
 
 #===============================================================================
@@ -559,15 +572,15 @@
     # RxClient
     #-----------------------------------------------------------------------
 
     def _reader(self):
         try:
             while self.is_alive():
                 result = self._read()
-                if type(result) == tuple and len(result) == 2:
+                if type(result) == tuple and len(result) == 2:  # pylint: disable=unidiomatic-typecheck
                     channel, msg = result
                 else:
                     channel, msg = None, result
 
                 if channel:
                     self._broadcast(channel, msg)
                 else:
@@ -615,17 +628,19 @@
     #-----------------------------------------------------------------------
 
     def _rmi(self, msg):
         for _ in range(self.retries):
             response = self._do_rmi(msg)
             if not isinstance(response, SystemError):
                 return response
+            if str(response) != 'Could not queue task':
+                return response
 
             if callable(self.retry_pause):
-                self.retry_pause()
+                self.retry_pause()              # pylint: disable=not-callable
 
         return self._do_rmi(msg)
 
     def _do_rmi(self, msg):
         if not self.is_alive():
             raise OSError("Connection has been closed")
```

## mhi/common/server.py

```diff
@@ -6,19 +6,24 @@
 Automation Server
 """
 
 #===============================================================================
 # Imports
 #===============================================================================
 
-import logging, queue, threading, pickle, io, socket
+import logging
+import io
+import pickle
+import queue
+import socket
+import threading
 
 from socket import IPPROTO_TCP, TCP_NODELAY
 from select import select as _select
-from typing import Dict, Optional, Set
+from typing import Dict, Set
 
 from .remote import RemoteException, Context, Application
 from ._script import _UserScript
 
 
 #===============================================================================
 # Logging
@@ -131,29 +136,29 @@
             _LOG.exception("Unpickling, dispatching or pickling error!")
             response = None, ex
             reply = self._pickler.dumps(response)
 
         if reply:
             try:
                 client.reply(reply)
-            except Exception as ex:               # pylint: disable=broad-except
+            except Exception:                     # pylint: disable=broad-except
                 _LOG.exception("Exception replying to client!")
 
     def post(self, client, response, channel=None):
         """Post a delayed reply or subscription event to a client"""
         try:
             response = channel, response
             reply = self._pickler.dumps(response)
         except Exception as ex:                   # pylint: disable=broad-except
             _LOG.exception("Pickling error!")
             reply = self._pickler.dumps(ex)
 
         try:
             return client.reply(reply)
-        except Exception as ex:                   # pylint: disable=broad-except
+        except Exception:                         # pylint: disable=broad-except
             _LOG.exception("Exception posting to client!")
 
         return False
 
 
     def _dispatch(self, cmd, client):
         response = None
```

## mhi/common/version.py

```diff
@@ -85,26 +85,38 @@
         if not isinstance(other, Version):
             return NotImplemented
 
         return self._version != other._version
 
     @property
     def major(self) -> int:
+        """
+        The Version's major number (read-only)
+        """
         return self._version[0]
 
     @property
     def minor(self) -> int:
+        """
+        The Version's minor number (read-only)
+        """
         return self._version[1]
 
     @property
     def patch(self) -> Optional[int]:
+        """
+        The Version's patch number (optional, read-only)
+        """
         return self._version[2] if len(self._version) == 3 else None
 
     @property
     def dev(self) -> bool:
+        """
+        Development flag (read-only)
+        """
         return len(self._version) == 2
 
     def __repr__(self) -> str:
         return "Version('%s')" % self
 
     def __str__(self) -> str:
         return ".".join(map(str, self._version))
```

## mhi/common/zipper.py

```diff
@@ -1,32 +1,41 @@
-import os, sys
-import mhi.common.process
+"""
+Utility to update embedded MHI automation libraries
+"""
+
+import os
+import sys
 
-from argparse import ArgumentParser, Namespace
+from argparse import Namespace
 from pathlib import Path
-from typing import DefaultDict, Dict, List, NamedTuple, Set, NewType
+from typing import DefaultDict, Dict, List, Set
 from zipfile import PyZipFile
 
-Version = NewType('Version', str)
+import mhi.common.process
+
+Version = str
 
 class Error(Exception):
-    pass
+    """
+    Error class
+    """
+
 
 class LibraryZipper:
     """
     Collect python packages together and save as a zipped library.
     The python modules may be pre-compiled for a particular CPython version.
     """
 
     SUB_COMMAND = "update"
 
     def __init__(self, app_name: str, *packages: str, lib: str = 'mhi.zip',
                  allow_all: bool = True, allow_local: bool = True):
         self._app_name = app_name
-        self._packages = {}
+        self._packages = {}                             # type: Dict[str, Path]
         self._exclude_files = {'__main__.py'}
         self._exclude_paths = {__name__.replace('.', '\\') + '.py'}
         self._lib = lib
         self._all = allow_all
         self._local = allow_local
 
         for package in packages:
@@ -112,15 +121,15 @@
         """
         Return a dictionary of installed application versions and their paths.
 
         32-bit versions are identified with a '-32' suffix on the key,
         64-bit versions do not have any suffix.
         """
 
-        v32, v64 = mhi.common.process._exe_path(self._app_name)
+        v32, v64 = mhi.common.process._exe_path(self._app_name) # pylint: disable=protected-access
 
         paths = {ver + '-32': Path(path).parent for ver, path in v32.items()}
         for version, path in v64.items():
             paths[version] = Path(path).parent
 
         versions = {version: path for version, path in paths.items()
                     if self._get_zipfile(path).exists()}
@@ -244,15 +253,15 @@
         Create a source and/or binary library zipfile.
         """
 
 
         if not (include_source or compile_source):
             raise Error("Source must be included, compiled or both")
 
-        with PyZipFile(zipfile, 'w') as zf:
+        with PyZipFile(str(zipfile), 'w') as zf:
             print('Writing', zipfile)
             self._write_namespaces(zf)
             if include_source:
                 self._write_source(zf)
             if compile_source:
                 self._compile_source(zf)
 
@@ -265,15 +274,15 @@
             zf.writestr(init_py, "")
 
     def _init_py_files(self) -> Set[str]:
         """
         Identify __init__.py files necessary to turn namespaces into packages.
         """
 
-        init_pys = set()
+        init_pys = set()                                        # type: Set[str]
         for package in self._packages:
             segments = package.split('.')
             init_pys.update('/'.join(segments[:last]) + '/__init__.py'
                             for last in range(1, len(segments)))
         return init_pys
 
     def _write_source(self, zf):
```

## Comparing `mhi_common-2.4.0.dist-info/LICENSE` & `mhi_common-2.4.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mhi_common-2.4.0.dist-info/METADATA` & `mhi_common-2.4.1.dist-info/METADATA`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mhi-common
-Version: 2.4.0
+Version: 2.4.1
 Summary: Manitoba Hydro International: Common library
 Author-email: "Manitoba Hydro International Ltd." <pscad@mhi.ca>
 License: BSD-3-Clause-Clear
 Project-URL: Homepage, https://www.pscad.com/support/support-resources
 Project-URL: Documentation, https://www.pscad.com/webhelp-v501-al/index.html
 Classifier: Development Status :: 5 - Production/Stable
 Classifier: Programming Language :: Python :: 3
@@ -19,14 +19,18 @@
 Classifier: License :: OSI Approved :: BSD License
 Classifier: Operating System :: Microsoft :: Windows
 Requires-Python: >=3.5
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: pywin32 >=300
 Requires-Dist: packaging
+Provides-Extra: dev
+Requires-Dist: coverage >=7.4.3 ; extra == 'dev'
+Requires-Dist: pytest >=8.0.1 ; extra == 'dev'
+Requires-Dist: pylint-gitlab >=2.0.0 ; extra == 'dev'
 
 # MHI Common Library
 
 The MHI Common Library is a collection of common functions
 designed to assist control of the MHI applications from a Python script.
 
 By itself, it does not perform any useful functions.
```

