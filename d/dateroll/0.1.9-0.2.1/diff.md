# Comparing `tmp/dateroll-0.1.9-py3-none-any.whl.zip` & `tmp/dateroll-0.2.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,42 +1,42 @@
-Zip file size: 467653 bytes, number of entries: 40
--rw-r--r--  2.0 unx      662 b- defN 24-Mar-28 21:03 dateroll/__init__.py
+Zip file size: 467677 bytes, number of entries: 40
+-rw-r--r--  2.0 unx     1086 b- defN 24-Mar-29 20:42 dateroll/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/__main__.py
--rw-r--r--  2.0 unx     3246 b- defN 24-Mar-26 16:39 dateroll/pretty.py
--rw-r--r--  2.0 unx     3892 b- defN 24-Mar-26 16:39 dateroll/settings.py
--rw-r--r--  2.0 unx     1390 b- defN 24-Mar-27 20:06 dateroll/tblfmt.py
--rw-r--r--  2.0 unx     6115 b- defN 24-Mar-27 13:14 dateroll/utils.py
+-rw-r--r--  2.0 unx     3272 b- defN 24-Apr-01 22:24 dateroll/pretty.py
+-rw-r--r--  2.0 unx     4255 b- defN 24-Apr-03 13:30 dateroll/settings.py
+-rw-r--r--  2.0 unx     1425 b- defN 24-Mar-28 22:33 dateroll/tblfmt.py
+-rw-r--r--  2.0 unx     4493 b- defN 24-Apr-01 16:43 dateroll/utils.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/calendars/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/calendars/__main__.py
--rw-r--r--  2.0 unx    11041 b- defN 24-Mar-26 16:39 dateroll/calendars/calendarmath.py
--rw-r--r--  2.0 unx     9108 b- defN 24-Mar-28 20:56 dateroll/calendars/calendars.py
+-rw-r--r--  2.0 unx    11202 b- defN 24-Apr-03 20:46 dateroll/calendars/calendarmath.py
+-rw-r--r--  2.0 unx     9172 b- defN 24-Apr-03 20:46 dateroll/calendars/calendars.py
 -rw-r--r--  2.0 unx     2197 b- defN 24-Mar-26 16:39 dateroll/calendars/sampledata.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/date/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/date/__main__.py
--rw-r--r--  2.0 unx     8479 b- defN 24-Mar-27 13:26 dateroll/date/date.py
+-rw-r--r--  2.0 unx     8499 b- defN 24-Apr-03 20:42 dateroll/date/date.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/ddh/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/ddh/__main__.py
--rw-r--r--  2.0 unx     2919 b- defN 24-Mar-28 22:04 dateroll/ddh/ddh.py
+-rw-r--r--  2.0 unx     2725 b- defN 24-Apr-03 13:30 dateroll/ddh/ddh.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/duration/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/duration/__main__.py
--rw-r--r--  2.0 unx    24491 b- defN 24-Mar-27 14:24 dateroll/duration/duration.py
+-rw-r--r--  2.0 unx    24755 b- defN 24-Apr-03 20:49 dateroll/duration/duration.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/parser/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/parser/__main__.py
--rw-r--r--  2.0 unx     5968 b- defN 24-Mar-26 16:39 dateroll/parser/parser.py
--rw-r--r--  2.0 unx    11777 b- defN 24-Mar-27 13:14 dateroll/parser/parsers.py
+-rw-r--r--  2.0 unx     6211 b- defN 24-Apr-03 13:30 dateroll/parser/parser.py
+-rw-r--r--  2.0 unx    12159 b- defN 24-Apr-03 20:31 dateroll/parser/parsers.py
 -rw-r--r--  2.0 unx     1135 b- defN 24-Mar-26 16:39 dateroll/parser/patterns.py
 -rw-r--r--  2.0 unx  1607067 b- defN 24-Feb-29 23:50 dateroll/sampledata/ALL.csv
 -rw-r--r--  2.0 unx    39446 b- defN 24-Feb-29 23:50 dateroll/sampledata/BR.csv
 -rw-r--r--  2.0 unx    26400 b- defN 24-Feb-29 23:50 dateroll/sampledata/ECB.csv
 -rw-r--r--  2.0 unx    50116 b- defN 24-Feb-29 23:50 dateroll/sampledata/FED.csv
 -rw-r--r--  2.0 unx    43461 b- defN 24-Feb-29 23:50 dateroll/sampledata/LN.csv
 -rw-r--r--  2.0 unx    50116 b- defN 24-Feb-29 23:50 dateroll/sampledata/NY.csv
 -rw-r--r--  2.0 unx   459162 b- defN 24-Feb-29 23:50 dateroll/sampledata/WE.csv
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/schedule/__init__.py
 -rw-r--r--  2.0 unx        0 b- defN 24-Feb-29 23:50 dateroll/schedule/__main__.py
--rw-r--r--  2.0 unx     5306 b- defN 24-Mar-27 13:14 dateroll/schedule/schedule.py
--rw-r--r--  2.0 unx    11357 b- defN 24-Mar-28 22:05 dateroll-0.1.9.dist-info/LICENSE
--rw-r--r--  2.0 unx     1141 b- defN 24-Mar-28 22:05 dateroll-0.1.9.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Mar-28 22:05 dateroll-0.1.9.dist-info/WHEEL
--rw-r--r--  2.0 unx        9 b- defN 24-Mar-28 22:05 dateroll-0.1.9.dist-info/top_level.txt
--rw-rw-r--  2.0 unx     3258 b- defN 24-Mar-28 22:05 dateroll-0.1.9.dist-info/RECORD
-40 files, 2389351 bytes uncompressed, 462465 bytes compressed:  80.7%
+-rw-r--r--  2.0 unx     5262 b- defN 24-Mar-29 20:18 dateroll/schedule/schedule.py
+-rw-r--r--  2.0 unx    11357 b- defN 24-Apr-03 21:05 dateroll-0.2.1.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1141 b- defN 24-Apr-03 21:05 dateroll-0.2.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-03 21:05 dateroll-0.2.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx        9 b- defN 24-Apr-03 21:05 dateroll-0.2.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     3259 b- defN 24-Apr-03 21:05 dateroll-0.2.1.dist-info/RECORD
+40 files, 2389474 bytes uncompressed, 462489 bytes compressed:  80.7%
```

## zipnote {}

```diff
@@ -99,23 +99,23 @@
 
 Filename: dateroll/schedule/__main__.py
 Comment: 
 
 Filename: dateroll/schedule/schedule.py
 Comment: 
 
-Filename: dateroll-0.1.9.dist-info/LICENSE
+Filename: dateroll-0.2.1.dist-info/LICENSE
 Comment: 
 
-Filename: dateroll-0.1.9.dist-info/METADATA
+Filename: dateroll-0.2.1.dist-info/METADATA
 Comment: 
 
-Filename: dateroll-0.1.9.dist-info/WHEEL
+Filename: dateroll-0.2.1.dist-info/WHEEL
 Comment: 
 
-Filename: dateroll-0.1.9.dist-info/top_level.txt
+Filename: dateroll-0.2.1.dist-info/top_level.txt
 Comment: 
 
-Filename: dateroll-0.1.9.dist-info/RECORD
+Filename: dateroll-0.2.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## dateroll/__init__.py

```diff
@@ -1,11 +1,22 @@
 from dateroll.ddh.ddh import ddh
 from dateroll.date.date import Date
 from dateroll.duration.duration import Duration
 from dateroll.schedule.schedule import Schedule
+from dateroll.calendars.calendarmath import CalendarMath
+from dateroll.calendars.calendarmath import Calendars
+from dateroll.parser.parser import Parser
+
+import dateroll.calendars.calendarmath as calendarmathModule
+import dateroll.calendars.calendars as calendarModule
+import dateroll.settings as settingsModule
+
+settings = settingsModule.settings
+calmath = calendarmathModule.calmath
+cals = calendarmathModule.calmath.cals
 
 
 # for backwards compatibility testing
 # import sys
 # import traceback
 # try:
 #     from dateroll.ddh.ddh import calmath, cals, ddh
```

## dateroll/pretty.py

```diff
@@ -28,15 +28,16 @@
         color holidays/weekends as grey
     """
     if dt2 > dt1:
         _1, _2 = dt1, dt2
     else:
         _1, _2 = dt2, dt1
 
-    print("from", _1, "to", _2, "cals", cals)
+    banner = f'From {_1}, to {_2}, holidays: {cals}'
+    print(banner)
 
     y1, m1, d1 = _1.year, _1.month, _1.day
     y2, m2, d2 = _2.year, _2.month, _2.day
 
     c1 = calendar.month(y1, m1)
     c1s = str(c1).splitlines()
     c1s[-1] = c1s[-1].ljust(len(c1s[-2]))
@@ -78,15 +79,15 @@
             elif ishol:
                 cal1 = replacer(i, "gray", cal1, cals)
 
         c2 = calendar.month(y2, m2)
         cal2 = "\n".join([" " + i for i in str(c2).splitlines()][1:])
         for i in range(0, 32):
             try:
-                _ = datetime.date(year=y1, month=m1, day=i)
+                _ = datetime.date(year=y2, month=m2, day=i)
                 ishol = not calmath.is_bd(_, cals)
             except:
                 ishol = False
             if i == d2:
                 cal2 = replacer(i, "blue", cal2, cals)
             elif i <= d2 and not ishol:
                 cal2 = replacer(i, "cyan", cal2, cals)
@@ -94,11 +95,11 @@
                 cal2 = replacer(i, "gray", cal2, cals)
 
         res = color(
             f"        {_1.strftime('%b')} {y1}                 {_2.strftime('%b')} {y2}                ",
             "yellow",
         )
         for idx, (i, j) in enumerate(zip(cal1.splitlines(), cal2.splitlines())):
-            res += "\n" + f"  {i}  {' '+j}"
+            res += "\n" + f"  {i}   {' '+j}"
             prev = len(i)
 
     return res
```

## dateroll/settings.py

```diff
@@ -1,18 +1,18 @@
 import importlib.util
 import pathlib
 import warnings
 
 path = pathlib.Path("~/.dateroll/settings.py").expanduser()
 
+ctx_conv = '_ctx_convention'
+
 default_settings = {
-    "debug": True,
     "convention": "MDY",
-    "ie": "(]",
-    "twodigityear_cutoff": 2050,
+    "twodigityear_cutoff": 2050
 }
 
 default_settings_validation = {
     "debug": (lambda x: isinstance(x, bool), TypeError("debug must be bool")),
     "convention": (
         lambda x: isinstance(x, str) and x in ["YMD", "MDY", "DMY"],
         ValueError('must be one of "MDY", "DMY" or "YMD".'),
@@ -75,59 +75,73 @@
         with path.open("w") as f:
             txt = f"# Dateroll settings file\n# {path}\n\n"
             for k, v in self.__dict__.items():
                 if not k.startswith("__") and k in default_settings:
                     txt += f"{k}={repr(v)}\n"
             f.write(txt)
 
+    
+
     def validate(self, user_settings):
         """
         2 tests:
             user settings key in default settings
             user settings value passes default settings value check
         1 adjustment:
             append default settings not in user settings for a complete set of settings
         """
 
         reset = False
         for k, v in user_settings.items():
 
             if k not in default_settings:
-                msg = f"Unkonwn setting {k}, ignoring"
+                msg = f"Unknown setting {k}, ignoring"
                 warnings.warn(msg)
             else:
                 test, exc = default_settings_validation[k]
                 if not test(v):
                     raise exc
 
         for k, v in default_settings.items():
             if k not in user_settings:
                 user_settings[k] = v
 
         return user_settings
+    
+    def __getattribute__(self, k):
+        if k=='convention':
+            if hasattr(self,'_convention_override'):
+                return self._convention_override
+
+        return super().__getattribute__(k)
 
     def __setattr__(self, k, v):
         """
-        add a new setting
+        if a new setting value, validate and save
         """
-        # check, set, save
-        func_value_is_valid, exc = default_settings_validation[k]
+        if k in default_settings:
+            # check, set, save
+            func_value_is_valid, exc = default_settings_validation[k]
 
-        if not func_value_is_valid(v):
-            raise exc
+            if not func_value_is_valid(v):
+                raise exc
 
-        super().__setattr__(k, v)
-        self.save()
+            super().__setattr__(k, v)
+            self.save()
+        else:
+            super().__setattr__(k, v)
 
     def __repr__(self):
         """
         show settings
         """
         kwargs = ",".join([f"{k}={repr(v)}" for k, v in self.__dict__.items()])
         string = f"{self.__class__.__name__}({kwargs})"
         return string
 
 
 settings = Settings()
 
 if __name__ == "__main__":  # pragma: no cover
-    settings = Settings()
+    # settings = Settings()
+    ...
+
```

## dateroll/tblfmt.py

```diff
@@ -1,11 +1,12 @@
 def pretty_table(ld, col_widths=None):
+    if len(ld)==0:
+        return ""
     headers = list(ld[0].keys())
     data = [headers] + [list(d.values()) for d in ld]
-    row1 = data[1]
 
     if col_widths is None:
         col_widths = [max(max([len(str(d[h])) for d in ld]),len(h))+2 for h in headers]
 
     x = ""
     
     # Print the top border
@@ -36,12 +37,12 @@
     x += '└'
     for i, width in enumerate(col_widths):
         end = ('┴' if i < len(col_widths)-1 else '┘\n')
         x += '─' * (width + 2)+end
 
     return x
 
-if __name__ == '__main__':
+if __name__ == '__main__':  # pragma:no cover
     from dateroll import cals
-    data = cals._calsdata()
+    data = cals._calsdata
     s = pretty_table(data)
     print(s)
```

## dateroll/utils.py

```diff
@@ -126,74 +126,14 @@
         month_str_numb = month_dict.get(month_str, None)
         if month_str_numb is None:
 
             raise ValueError("Month name is wrong")
         s = patterns.MONTHNAMES.sub(month_str_numb, s.capitalize())
     return s
 
-
-class safe_open:
-    """
-    use separate write lockfile to lock/unlock (fcntl removes dealock if pid w/ lock dies)
-    lock is removed if pid dies
-    """
-
-    def __init__(self, path, mode="r"):
-        """
-        open lockfile and attempt to lock, will block
-        """
-
-        self.path = pathlib.Path(path)
-        self.mode = mode
-        if mode.startswith("w"):
-            self.pathlock = self.path.with_suffix(".lockfile")
-            self.lockfile = open(self.pathlock, "w")
-            fcntl.lockf(self.lockfile, fcntl.LOCK_EX)
-
-    def __enter__(self):
-        """
-        open user file and send it to them
-        """
-
-        self.file = open(self.path, self.mode)
-        return self.file
-
-    def __exit__(self, exc_type, exc_val, exc_tb):
-        """
-        release lock, then close both lockfile and user file
-        do not delete lockfile (even if no exc)
-        """
-        if self.mode.startswith("w"):
-            fcntl.lockf(self.lockfile, fcntl.LOCK_UN)
-            self.lockfile.close()
-            self.file.close()
-
-
-import functools
-import time
-
-
-def timer(func):  # pragma:no cover
-    """
-    timer function is used for performance improvement
-    we use it as a wrapper on the function to see the run time of the function
-    """
-
-    @functools.wraps(func)
-    def wrapper(*args, **kwargs):
-        start_time = time.perf_counter()
-        value = func(*args, **kwargs)
-        end_time = time.perf_counter()
-        run_time = end_time - start_time
-        print("Finished {} in {} secs".format(repr(func.__name__), round(run_time, 7)))
-        return value
-
-    return wrapper
-
-
 convention_map = {"YMD": r"%Y-%m-%d", "DMY": r"%d/%m/%Y", "MDY": r"%m/%d/%Y"}
 
 
 def str_or_date(s):
     if isinstance(s,str):
         d = ddhModule.ddh(s)
     elif isinstance(s,dateModule.DateLike):
```

## dateroll/calendars/calendarmath.py

```diff
@@ -3,15 +3,14 @@
 import os
 import pathlib
 import pickle
 import time
 
 import dateroll.date.date as dateModule
 from dateroll.calendars.calendars import Calendars
-from dateroll.utils import safe_open
 
 PARENT_LOCATION = pathlib.Path.home() / ".dateroll/"
 PARENT_LOCATION.mkdir(exist_ok=True)
 MODULE_LOCATION = PARENT_LOCATION / "calendars/"
 MODULE_LOCATION.mkdir(exist_ok=True)
 DATA_LOCATION_FILE = MODULE_LOCATION / "compiled_cals"
 
@@ -75,16 +74,15 @@
         """
         cached = {
             "fwd": self.fwd,
             "bck": self.bck,
             "ibd": self.ibd,
             "hash": self.hash,
         }
-        with safe_open(self.home, "wb") as f:
-            print("[dateroll] Writing cache (calmath unions)")
+        with open(self.home, "wb") as f:
             pickle.dump(cached, f)
 
     def cached_compile_all(self):
         """
         cached compile/load of calenders, uses temp file in user's home for cache.
         """
         if self.home.exists():
@@ -121,14 +119,17 @@
         cache_is_valid = not self.home.exists()
         return cache_is_valid
 
     @property
     def cal_list(self):
         if not self.has_mutated:
             return self.cal_names
+        else:
+            self.compile_all()
+            return self.cal_names
 
     @property
     def recompile_if_mutated(self):
         if self.has_mutated:
             self.compile_all()
 
     @property
@@ -337,15 +338,15 @@
 
                 raise KeyError(f"There is no calendar {cal}")
 
             # the union operation
             unioned_dates |= set(self.cals[cal])
 
         # compile into large dict
-        print(f"[dateroll] compiling new union [{cal_union_key}]")
+        # print(f"[dateroll] compiling new union [{cal_union_key}]")
         dict_tuple = self.gen_dicts(cal_union_key, unioned_dates, self.ALL)
         self.fwd[cal_union_key], self.bck[cal_union_key], self.ibd[cal_union_key] = (
             dict_tuple
         )
         # save cache
         self.save_cache()
 
@@ -356,7 +357,13 @@
         """
         Show names of cals and unions
         """
         return f'{self.__class__.__name__}(home="{self.home}")\nCals: {self.cals.keys()}\nUnions: {list(self.fwd.keys())}'
 
 
 calmath = CalendarMath()
+
+if __name__=='__main__':  # pragma:no cover
+    from dateroll.settings import settings
+    from dateroll import ddh
+    import code
+    code.interact(local=dict(globals(),**locals()))
```

## dateroll/calendars/calendars.py

```diff
@@ -5,15 +5,15 @@
 import os
 import pathlib
 import pickle
 from collections import OrderedDict
 
 from dateroll.calendars import calendarmath as calendarmathModule
 from dateroll.date import date as dateModule
-from dateroll.utils import safe_open, date_slice, convention_map
+from dateroll.utils import date_slice, convention_map
 from dateroll import settings
 from dateroll.tblfmt import pretty_table
 
 ROOT_DIR = pathlib.Path(__file__).parents[2]
 PARENT_LOCATION = pathlib.Path.home() / ".dateroll/"
 PARENT_LOCATION.mkdir(exist_ok=True)
 MODULE_LOCATION = PARENT_LOCATION / "calendars/"
@@ -53,15 +53,15 @@
             ls = f.readlines()
             l = []
             for i in ls:
                 dt = datetime.date(int(i[0:4]), int(i[5:7]), int(i[8:10]))
                 if dt >= INCEPTION:
                     l.append(dt)
 
-            ds = DateSet(l)
+            ds = DateSet(l,name=name)
             data[name] = ds
     return data
 
 
 class Drawer:
     def __init__(self, cals):
 
@@ -71,15 +71,15 @@
     def __enter__(self):
 
         if self.cals.hash == self.cals.db_hash:
             return self.cals.db
 
         if self.path.exists():
             try:
-                with safe_open(self.path, "rb") as f:
+                with open(self.path, "rb") as f:
                     self.data = pickle.load(f)
                     self.cals.db_hash = self.cals.hash
                     self.cals.db = self.data
 
                     return self.cals.db
             except Exception as e:
                 import traceback
@@ -89,46 +89,50 @@
         else:
             msg = "No cache found"
 
         print(f"[dateroll] Loading sample calendars ({msg})")
         data = load_sample_data()
 
         self.cals.db = data
-        with safe_open(self.path, "wb") as f:
+        with open(self.path, "wb") as f:
             pickle.dump(self.cals.db, f)
-            print("[dateroll] Writing cache (calendars)")
             self.cals.write = False
 
         return self.cals.db
 
     def __exit__(self, exc_type, exc_val, exc_tb):
 
         if exc_val is not None:
             raise exc_val
         else:
             if self.cals.write:
-                with safe_open(self.path, "wb") as f:
+                with open(self.path, "wb") as f:
                     pickle.dump(self.cals.db, f)
-                    print("[dateroll] Writing cache (calendars)")
                 self.cals.write = False
 
 
 class DateSet:
-    def __init__(self, content):
+    def __init__(self, content, name=None):
+        self.name = name
         if not isinstance(content, SetLike):
             raise TypeError("DateSet content must be set-like (castable)")
 
         # ordered dict constructure requires dict not set
         d = {date_check(i): True for i in content if i is not None}
         od = OrderedDict(d)
         self._data = od
 
     def add(self, item):
         dt = date_check(item)
         self._data[dt] = True
+        if self.name is not None:
+            tothing = f' to {self.name}'
+        else:
+            tothing = ''
+        print(f'[dateroll] {item} added{tothing}.')
 
     def __contains__(self, item):
         if isinstance(item, dateModule.Date):
             item = item.date
         if isinstance(item, datetime.datetime):
             item = datetime.date(item.year, item.month, item.day)
         return item in self._data
@@ -208,16 +212,18 @@
 
         if k in self.db.keys():
             raise Exception(f"{k} exists already, delete first.if you want to replace.")
 
         self.write = True
         with Drawer(self) as db:
             # value must be a set-like list of dates
-            verified = DateSet(v)
+            verified = DateSet(v,name=k)
             db[k] = verified
+        
+        print(f'[dateroll] {k} now has {len(verified)} holidays.')
 
     def __getitem__(self, k):
         return self.get(k)
 
 
     def __getattr__(self, k):
         """
@@ -280,36 +286,37 @@
         data = []
         conv = convention_map[settings.settings.convention]
         with Drawer(self) as db:
             for i in sorted(db.keys()):
                 l = db.get(i)
                 years = {}
                 for j in l:
-                    if j.year > 1950 < j.year < 2050:
+                    if j.year > 1950 and j.year < 2050:
                         if j.year in years:
                             years[j.year]+=1
                         else:
                             years[j.year]=1
-                num_this_year = years[datetime.date.today().year]
+            
+                num_this_year = years.get(datetime.date.today().year,0)
                 if len(l) > 0:
                     n = len(l)
                     mn = min(l).strftime(conv)
                     mx = max(l).strftime(conv)
                 else:
-                    n, mn, mx = 0, None, None
+                    n, mn, mx = 0, "", ""
                 data.append({'name':i,'non-working days':n,'oldest':mn,'newest':mx,'# this year':num_this_year})
         return data
     
     def __str__(self):
         data = self._calsdata
         s = pretty_table(data)
         return s
 
-    # def __repr__(self):
-    #     return f'{self.__class__.__name__}(home="{self.home}")'
+    def __repr__(self):
+        return self.__str__()
 
     def copy(self):
         with Drawer(self) as db:
             return db.copy()
 
     def _purge_all(self):
         self.__init__()
@@ -318,12 +325,11 @@
     def info(self):
         print(self.__str__)
 
 
 if __name__ == "__main__":  # pragma: no cover
     
     
-    import code
-    code.interact(local=dict(globals(),**locals()))
+    ...
```

## dateroll/date/date.py

```diff
@@ -124,23 +124,23 @@
     def woty(self):
         """
         week of the year, iso 8601
         """
         return self.isocalendar()[1]
 
     @property
-    def xls(self):
+    def to_xls(self):
         offset = 693594
         n = self.toordinal()
         rs = n - offset
         return rs
 
     @property
-    def unix(self):
-        return self.datetime.timestamp()
+    def to_unix(self):
+        return int(self.datetime.timestamp())
 
     @property
     def iso(self):
         return self.isoformat().split("T")[0]
 
     def __add__(self, o):
         """
@@ -177,30 +177,29 @@
 
     def __sub__(self, o):
         """
         sub
         """
         # convert string if first
         if isinstance(o, str):
-
             o = ddhModule.ddh(o)
         # apply rules by type
 
         if isinstance(o, DateLike):
             # date - date
             # convert all datetimes to datetime.date for sub to be timedelta, then create Duration from timedelta
             if isinstance(o, Date):
                 dt = o.date
             elif isinstance(o, datetime.datetime):
                 # truncates time!
                 dt = datetime.date(o.year, o.month, o.day)
             else:
                 if isinstance(o, datetime.date):
                     dt = o
-
+          
             relative_delta = dateutil.relativedelta.relativedelta(self.date, dt)
             return Duration.from_relativedelta(
                 relative_delta, _anchor_start=dt, _anchor_end=self.date
             )
 
         elif isinstance(o, Duration) or "Duration" in o.__class__.__name__:
             # date + duration
```

## dateroll/ddh/ddh.py

```diff
@@ -16,14 +16,15 @@
 # import dateroll.calendars.calendarmath as calendarmathModule
 import dateroll.date.date as dateModule
 import dateroll.duration.duration as durationModule
 import dateroll.schedule.schedule as scheduleModule
 import dateroll.calendars.calendarmath as calendarmathModule
 import dateroll.calendars.calendars as calendarModule
 import dateroll.settings as settingsModule
+# from dateroll.settings import settings
 
 DEBUG = False
 
 class ddh:
     Date = dateModule.Date
     Duration = durationModule.Duration
     Schedule = scheduleModule.Schedule
@@ -38,59 +39,60 @@
             return dateModule.Date.from_datetime(o)
         elif isinstance(o, durationModule.DurationLike):
             obj = durationModule.Duration.from_relativedelta(o)
         else:
             raise TypeError(f"ddh() cannot handle {type(o).__name__})")
 
         return obj
-
-    def purge_all(self):
+    @staticmethod
+    def purge_all():
         """
         dangerous, deletes all calendars and lockfiles
         """
         p = pathlib.Path("~/.dateroll").expanduser()
         import glob
 
         files = glob.glob(str(p) + "/**/*", recursive=True)
         for file in files:
             if not file.endswith("lockfile"):
                 if pathlib.Path(file).is_file():
                     os.remove(file)
-        self.hols._purge_all()
-        self.calmath._purge_all()
+        ddh.hols._purge_all()
+        ddh.calmath._purge_all()
 
 
     class YMD:
         global settings
         def __init__(self):
-            self.orig = ddh.settings.convention
+            pass
         def __enter__(self):
-            ddh.settings.convention = 'YMD'
+            ddh.settings._convention_override = 'YMD'
         def __exit__(self,*e):
-            ddh.settings.convention = self.orig
+            del ddh.settings._convention_override
 
     class MDY:
         global settings
         def __init__(self):
-            self.orig = ddh.settings.convention
+            pass
         def __enter__(self):
-            ddh.settings.convention = 'MDY'
+            ddh.settings._convention_override = 'MDY'
         def __exit__(self,*e):
-            ddh.settings.convention = self.orig
+            del ddh.settings._convention_override
 
     class DMY:
         global settings
         def __init__(self):
-            self.orig = ddh.settings.convention
+            pass
         def __enter__(self):
-            ddh.settings.convention = 'DMY'
+            ddh.settings._convention_override = 'DMY'
         def __exit__(self,*e):
-            ddh.settings.convention = self.orig
+            del ddh.settings._convention_override
 
 
 if __name__ == "__main__":  # pragma:no cover
-    import time
 
-    a = time.time()
-    # [calmath.bck['NYuWE'][calmath.fwd['NYuWE'][i]-1] for i in ddh('1/1/1900,1/1/2100,1d').dates]
-    [i - "1bd|NYuWE" for i in ddh("1/1/1900,1/1/2100,1d").dates]
-    print(time.time() - a)
+    ddh('t-1y3m')
+    
+    ...
+
+
+
```

## dateroll/duration/duration.py

```diff
@@ -189,14 +189,21 @@
         return parsersModule.parseDurationString(o)
 
     @staticmethod
     def from_relativedelta(rd, _anchor_start=None, _anchor_end=None):
         if isinstance(rd, Duration):
             return rd
         elif isinstance(rd, dateutil.relativedelta.relativedelta):
+            if _anchor_start < _anchor_end:
+                a = _anchor_start
+                b = _anchor_start
+            else:
+                a= _anchor_end
+                b = _anchor_start
+
             return Duration(
                 years=rd.years,
                 months=rd.months,
                 days=rd.days,
                 _anchor_start=_anchor_start,
                 _anchor_end=_anchor_end,
             )
@@ -220,26 +227,27 @@
         else:
             raise TypeError(f"Must be timedelta not {type(td).__name__}")
 
     def _validate_cals(self, cals):
         """
         validates calendars are correct
         """
+        callist = calendarmathModule.calmath.cal_list
         _cals = set()
         if cals is not None:
 
             # str parser if required
             if isinstance(cals, str):
                 cals = parsersModule.parseCalendarUnionString(cals)
             # process normally
             if isinstance(cals, (list, set, tuple)):
                 for cal in cals:
                     if isinstance(cal, str):
                         if len(cal) in (2, 3):
-                            if cal in calendarmathModule.calmath.cal_list:
+                            if cal in callist:
                                 _cals |= {
                                     cal,
                                 }
 
                             else:
                                 raise ValueError(f"Calendar {cal} not found")
                         else:
@@ -391,15 +399,15 @@
                     just_days += dbds
                     warns.append(f"≈{dbds:.6f}d")
 
         if len(warns) > 0:
             w = ",".join(warns)
             message = f"[dateroll] just_days using approx: {w} "
             if not _force_exact:
-                warnings.warn(message)
+                print(message)
             else:
                 raise ValueError(message)
 
         return just_days
 
     def math(self, b, direction):
         """
@@ -749,11 +757,13 @@
             output += f"{self.days:+}d"
         if self.bd:
             output += f"{int(self.bd):+}bd"
         if self.cals:
             output += f'|{"u".join(self.cals)}'
         if self.modified:
             output += f"/MOD"
+        if output=="":
+            output = "+0d"
         return output
 
 
 DurationLike = (Duration, datetime.timedelta, dateutil.relativedelta.relativedelta)
```

## dateroll/parser/parser.py

```diff
@@ -114,25 +114,23 @@
 
     @classmethod
     def parse_one_part(cls, untouched):
         letters = [chr(i) for i in range(65, 65 + 26)]
 
         def gen():
             yield letters.pop(0)
-
         notoday = parsersModule.parseTodayString(untouched)
 
         dates, nodates = parsersModule.parseManyDateStrings(notoday, gen)
 
         durations, nodatesordurations = parsersModule.parseManyDurationString(
             nodates, gen
         )
 
         dates_durations = {**dates, **durations}
-
         processed_answer = parsersModule.parseDateMathString(
             nodatesordurations, dates_durations
         )
 
         return processed_answer
 
     @classmethod
@@ -184,7 +182,15 @@
 
 def parse_to_native(string):
     return Parser(string, use_native_types=True)
 
 
 def parse_to_dateroll(string):
     return Parser(string)
+
+if __name__=='__main__': # pragma:no cover
+    from dateroll import ddh
+    import dateroll
+    dateroll.settings.convention = "MDY"
+    x = ddh('-1y2q3m4w5d6BD')
+    # x = ddh('t') + ddh('+3m') + ddh('-2y')+ ddh('700bd')-ddh('t')
+    print(x)
```

## dateroll/parser/parsers.py

```diff
@@ -1,18 +1,21 @@
 import calendar
 import datetime
 import re
+import math
 
 import dateroll.date.date as dt
 import dateroll.duration.duration as dur
 from dateroll import utils
 from dateroll.parser import patterns
 from dateroll.schedule.schedule import Schedule
 from dateroll.settings import settings
 
+import code
+
 TODAYSTRINGVALUES = ["today", "t0", "t"]
 
 
 def validate_year(y):
     """
     validate year using settings twodigityear_cutoff, and convert all 2-digit years to 4-digit
     """
@@ -189,15 +192,15 @@
         pattern = patterns.DMY
     elif settings.convention == "YMD":
         pattern = patterns.YMD
 
     dates = {}
     matches = re.findall(pattern, s)
     res = s
-
+    
     for match, _, _, _ in matches:
         # must hav 4 components per match
         # match 0 is 1st capture group = whole thing
         # match 1,2,3 are the y/m/d's as strings
 
         date = parseDateString(match)
         date = dt.Date.from_datetime(date)
@@ -230,24 +233,20 @@
     for i in range(2, 12, 2):
         number = capture_groups[i]
         unit = capture_groups[i + 1]
 
         if number and unit:
             # cast number to integer y,s,q,m,w,d
             number = int(number) if unit != "bd" else float(number)
-            if i < 4:
-                # use multiplier on first pair
-                number *= mult
             if unit in duration_constructor_args:
                 raise ParserStringsError(
                     "Only 1 number of each unit per duration string (i.e. no 5d3d or 7m1m)"
                 )
-
-            duration_constructor_args[unit] = number
-
+            duration_constructor_args[unit] = number * mult
+    
     # attach calendars if any
     cals = capture_groups[13:21]
 
     # remove empty strings from cals
     cals = tuple(filter(lambda x: x != "", cals))
     for cal in cals:
         (
@@ -315,25 +314,33 @@
                 WE -> by default is weekend calendar (list of all sat and sun from -100y to +100y)
                 NY -> new york federal holidays
                 EU -> ECB holidays
             calender unions: repreating calendars with "u" for union
                 WEuNY -> all weekend holidays + NY holidays
                 WUuNYuEU -> union of all 3 sets
         modifier after  /
-                /MOD means modified the direction of travel for bd's to stay in current month
+                /MOD means modified the direction of travel for bd's to stay in current month 
     """
     durations = {}
     matches = re.findall(patterns.COMPLETE_DURATION, s)
-
-    for match in matches:
+    
+    for idx,match in enumerate(matches):
         duration_string = match[0]
         duration = parseDurationString(duration_string)
+
+        if idx==1:
+            # its because there is bd in string, eg ddh('-1y3bd), so need to flip the sign of bd when main sign is neg
+            op = -1 if '-' in matches[0][0] else 1
+            if isinstance(duration.bd,(float,int)):
+                duration.bd = op * duration.bd 
+        
         next_letter = next(gen())
         s = s.replace(duration_string, "+" + next_letter, 1)
         durations[next_letter] = duration
+    
     return durations, s
 
 
 def parseScheduleString(s):
     """
     takes a schedule string as "start,stop,step"
     where start resolves to a date
@@ -396,7 +403,12 @@
     # good case, do the math
 
     try:
         total = eval(s, {}, things)
         return total
     except Exception as e:
         raise ParserStringsError("Cannot recognize as date math", s)
+
+if __name__=='__main__':  # pragma:no cover
+    from dateroll.ddh.ddh import ddh
+    x = ddh('111422414')
+    print(x)
```

## dateroll/schedule/schedule.py

```diff
@@ -142,16 +142,16 @@
         return False
 
     @property
     def split(self):
         list_of_dates = self._dates
         start = list_of_dates[:-1]
         stop = list_of_dates[1:]
-        step = [self.step.to_string()] * (len(list_of_dates) - 1)
-        df = pd.DataFrame({"start": start, "stop": stop, "step": step})
+        df = pd.DataFrame({"start": start, "stop": stop})
+        df['step']=df.stop-df.start
         df.index.name = "per"
 
         return df
 
     @property
     def split_bond(self):
         """
```

## Comparing `dateroll-0.1.9.dist-info/LICENSE` & `dateroll-0.2.1.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `dateroll-0.1.9.dist-info/METADATA` & `dateroll-0.2.1.dist-info/METADATA`

 * *Files 14% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: dateroll
-Version: 0.1.9
+Version: 0.2.1
 Summary: dateroll makes working with dates less painful.
 Home-page: https://github.com/disentcorp/dateroll
 Author: Anthony Malizzio
 Author-email: anthony.malizzio@disent.com
 License: Apache Software License
 Classifier: Development Status :: 3 - Alpha
 Classifier: Intended Audience :: Science/Research
```

## Comparing `dateroll-0.1.9.dist-info/RECORD` & `dateroll-0.2.1.dist-info/RECORD`

 * *Files 8% similar despite different names*

```diff
@@ -1,40 +1,40 @@
-dateroll/__init__.py,sha256=PhJnB7b4FaS4SfoG-WU91SjDnM89AOccRLb87zNfKak,662
+dateroll/__init__.py,sha256=-QMxKOSsxa3L4VWY3mf9j_-ucYXjVfkAyRNAaAtJAeY,1086
 dateroll/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/pretty.py,sha256=wwp5_moAAOv5AvWWIcOvIbcjaK48ECgZQ8C7Iq8S8qI,3246
-dateroll/settings.py,sha256=rV1q4jwh2F1i0jdwRim2ceKiJiHSqKSFLLhV3Mluo2w,3892
-dateroll/tblfmt.py,sha256=ecG34grefvhXJ1uCinoUi_fkeflCXrdpEI63KZIBbYA,1390
-dateroll/utils.py,sha256=JQdfn4KJpRpnzEglvLl91DvsDN14CooF6jcgFIE9BwI,6115
+dateroll/pretty.py,sha256=XOuG6HV9Vl2HmR0WLtA3s_xNG3rl_xvIuxKPvr68O-w,3272
+dateroll/settings.py,sha256=3NPbbKR4ARRDGpCLeitoRdmd7jtbC-zTQxJl96a7ABc,4255
+dateroll/tblfmt.py,sha256=gxe09Ie2L2sSa6NO8s_RPfB98LvIIjFk1z16SRYYTls,1425
+dateroll/utils.py,sha256=08ixVKtXEjnNzNfojakggw1k9DgYadup45141Gi6Cas,4493
 dateroll/calendars/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/calendars/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/calendars/calendarmath.py,sha256=vJIeWybL6rK1gRiB1qwX6Xdj_wjqKVlU9RyeQSBZSck,11041
-dateroll/calendars/calendars.py,sha256=kDSI5WLCGC38EDcF3M-7nM5bNY1Mj3bx8SdprSCDBpg,9108
+dateroll/calendars/calendarmath.py,sha256=RZZzq2-D0MEXtxbhhAnyLbsB_CJUXcSWPOoD7Mp-La8,11202
+dateroll/calendars/calendars.py,sha256=God2XmMhizDyzeIsF_By00tWiLiTg0hbTCkd5M10Ghc,9172
 dateroll/calendars/sampledata.py,sha256=ghTTa32jzBhj4woZA5CbyoMa7Ao5o6LhJt6jg2kWDI4,2197
 dateroll/date/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/date/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/date/date.py,sha256=aED4wNr204OLCQuoqrE2Oeb-iS9ZdPSZzbY0nJ2qLkg,8479
+dateroll/date/date.py,sha256=f62gFYr1lmVYwFHf0EQRq3wQtxGF1Da2N_G-lVb9BL4,8499
 dateroll/ddh/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/ddh/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/ddh/ddh.py,sha256=y54f0dEcq2sUDBX8AfMWXSASIa9YRfeC9zUbs3HUjhM,2919
+dateroll/ddh/ddh.py,sha256=07EJ816njt4jT-mARF2SGylA458emJXN31n1jG61wmQ,2725
 dateroll/duration/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/duration/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/duration/duration.py,sha256=lI4zLYpj_ASgX29q2kSquY8DovE29WiK2BnXKAeAH-w,24491
+dateroll/duration/duration.py,sha256=RfplI4Jism1nyAFBIA2faEHFUSAPz21IXFO-tOiWEQA,24755
 dateroll/parser/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/parser/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/parser/parser.py,sha256=3LGqpsu7F6ufjEjflc0AZgbYYyJ8TH5LQAAUTV3QTrI,5968
-dateroll/parser/parsers.py,sha256=alV2NnvKboMO4fG9BcyUrOo27qFwsXZrzDltso5X45Y,11777
+dateroll/parser/parser.py,sha256=9ZzUiDloVGrUv8KX0cglawbVVaGw_xaUPjwiXvpVWBg,6211
+dateroll/parser/parsers.py,sha256=jFGTnXv37ESCasRrxJ27ayblsetypWgHHpMQaWP24Qg,12159
 dateroll/parser/patterns.py,sha256=15H8jgOy7Uv1g0Dkl4oXij4J-e8pu7qMJdeVQfpCKaA,1135
 dateroll/sampledata/ALL.csv,sha256=jv0ywBTvHgplgNCnVT_AhE_vYwZuLfUkZedetp-gFL4,1607067
 dateroll/sampledata/BR.csv,sha256=IsTNxR1y56KHgDmixaTpfLZKaTVxJ8VTPL07lRAxfmM,39446
 dateroll/sampledata/ECB.csv,sha256=QygTagRWTxlgBNEDRfAl-NcQjXj9FSIkRlXi9Cfoywk,26400
 dateroll/sampledata/FED.csv,sha256=WhzeD5Zbrcg4zQ3EK06Yzh9l6-Od7PJ6xZcTvZy6Hy4,50116
 dateroll/sampledata/LN.csv,sha256=5jwkCP6XhDjrXM6dCeIanYt1Lkt5TES114GL9e5ZZFA,43461
 dateroll/sampledata/NY.csv,sha256=WhzeD5Zbrcg4zQ3EK06Yzh9l6-Od7PJ6xZcTvZy6Hy4,50116
 dateroll/sampledata/WE.csv,sha256=dea9eFyNBwyBGYbXqPjoT84tdIgvRwO34oJ42eT0KJs,459162
 dateroll/schedule/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 dateroll/schedule/__main__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-dateroll/schedule/schedule.py,sha256=MXcTSrSJwCYp0sZH04QhpQewuOJf0lEveu4WqSGGhO4,5306
-dateroll-0.1.9.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
-dateroll-0.1.9.dist-info/METADATA,sha256=qffkp_mbVi1mMlqXIEjnP2aWbRX7jPyV8vzMMRgI8w0,1141
-dateroll-0.1.9.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-dateroll-0.1.9.dist-info/top_level.txt,sha256=_nTOdTwmFVeheA44KYWK_l1Z73ynrc4bNPtBClgbmJc,9
-dateroll-0.1.9.dist-info/RECORD,,
+dateroll/schedule/schedule.py,sha256=0ut4lzPDHcxy8ADRGQu9aGL7QxNXI3NMXAh84YlxdSc,5262
+dateroll-0.2.1.dist-info/LICENSE,sha256=xx0jnfkXJvxRnG63LTGOxlggYnIysveWIZ6H3PNdCrQ,11357
+dateroll-0.2.1.dist-info/METADATA,sha256=PC-aXWwd4rJmtF5OJSpUcOS7Ieudhoy7fRNPJ0IpMf8,1141
+dateroll-0.2.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+dateroll-0.2.1.dist-info/top_level.txt,sha256=_nTOdTwmFVeheA44KYWK_l1Z73ynrc4bNPtBClgbmJc,9
+dateroll-0.2.1.dist-info/RECORD,,
```

