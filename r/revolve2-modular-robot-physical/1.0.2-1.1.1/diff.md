# Comparing `tmp/revolve2_modular_robot_physical-1.0.2-py3-none-any.whl.zip` & `tmp/revolve2_modular_robot_physical-1.1.1-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,38 +1,39 @@
-Zip file size: 27629 bytes, number of entries: 36
+Zip file size: 29339 bytes, number of entries: 37
 -rw-r--r--  2.0 unx      317 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/__init__.py
 -rw-r--r--  2.0 unx      144 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/_bin/__init__.py
 -rw-r--r--  2.0 unx      907 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/_bin/robot_daemon.py
 -rw-r--r--  2.0 unx     1285 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/_config.py
 -rw-r--r--  2.0 unx      122 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/_hardware_type.py
 -rw-r--r--  2.0 unx       27 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/_protocol_version.py
 -rw-r--r--  2.0 unx       22 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/_standard_port.py
 -rw-r--r--  2.0 unx     1455 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/_uuid_key.py
 -rw-r--r--  2.0 unx      178 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/physical_interfaces/__init__.py
 -rw-r--r--  2.0 unx     1355 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/physical_interfaces/_get_interface.py
--rw-r--r--  2.0 unx     2165 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/physical_interfaces/_physical_interface.py
+-rw-r--r--  2.0 unx     2481 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/physical_interfaces/_physical_interface.py
 -rw-r--r--  2.0 unx      136 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/physical_interfaces/v1/__init__.py
--rw-r--r--  2.0 unx     3847 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/physical_interfaces/v1/_v1_physical_interface.py
+-rw-r--r--  2.0 unx     4145 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/physical_interfaces/v1/_v1_physical_interface.py
 -rw-r--r--  2.0 unx      136 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/physical_interfaces/v2/__init__.py
--rw-r--r--  2.0 unx     5742 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/physical_interfaces/v2/_v2_physical_interface.py
+-rw-r--r--  2.0 unx     6040 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/physical_interfaces/v2/_v2_physical_interface.py
 -rw-r--r--  2.0 unx      181 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/__init__.py
 -rw-r--r--  2.0 unx      621 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/_active_hinge_sensor_state_impl.py
+-rw-r--r--  2.0 unx      618 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/_camera_sensor_state_impl.py
 -rw-r--r--  2.0 unx     1282 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/_imu_sensor_state_impl.py
 -rw-r--r--  2.0 unx      868 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/_modular_robot_control_interface_impl.py
 -rw-r--r--  2.0 unx     1280 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/_modular_robot_sensor_state_impl_v1.py
--rw-r--r--  2.0 unx     2576 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/_modular_robot_sensor_state_impl_v2.py
--rw-r--r--  2.0 unx    11072 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/_remote.py
+-rw-r--r--  2.0 unx     3200 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/_modular_robot_sensor_state_impl_v2.py
+-rw-r--r--  2.0 unx    12981 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/_remote.py
 -rw-r--r--  2.0 unx     1486 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/remote/_test_physical_robot.py
 -rw-r--r--  2.0 unx      125 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon/__init__.py
--rw-r--r--  2.0 unx     8890 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon/_robo_server_impl.py
+-rw-r--r--  2.0 unx    10055 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon/_robo_server_impl.py
 -rw-r--r--  2.0 unx     2442 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon/_robot_daemon.py
 -rw-r--r--  2.0 unx      363 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon_api/__init__.py
 -rwxr-xr-x  2.0 unx      227 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon_api/_generate_stubs.sh
--rw-r--r--  2.0 unx     1052 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol.capnp
--rw-r--r--  2.0 unx     1414 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.py
--rw-r--r--  2.0 unx    11514 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.pyi
+-rw-r--r--  2.0 unx     1157 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol.capnp
+-rw-r--r--  2.0 unx     1494 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.py
+-rw-r--r--  2.0 unx    12800 b- defN 80-Jan-01 00:00 revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.pyi
 -rw-r--r--  2.0 unx        0 b- defN 80-Jan-01 00:00 revolve2/py.typed
--rw-r--r--  2.0 unx     3494 b- defN 80-Jan-01 00:00 revolve2_modular_robot_physical-1.0.2.dist-info/METADATA
--rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 revolve2_modular_robot_physical-1.0.2.dist-info/WHEEL
--rw-r--r--  2.0 unx       87 b- defN 80-Jan-01 00:00 revolve2_modular_robot_physical-1.0.2.dist-info/entry_points.txt
-?rw-r--r--  2.0 unx     4172 b- defN 16-Jan-01 00:00 revolve2_modular_robot_physical-1.0.2.dist-info/RECORD
-36 files, 71072 bytes uncompressed, 20479 bytes compressed:  71.2%
+-rw-r--r--  2.0 unx     3549 b- defN 80-Jan-01 00:00 revolve2_modular_robot_physical-1.1.1.dist-info/METADATA
+-rw-r--r--  2.0 unx       88 b- defN 80-Jan-01 00:00 revolve2_modular_robot_physical-1.1.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx       87 b- defN 80-Jan-01 00:00 revolve2_modular_robot_physical-1.1.1.dist-info/entry_points.txt
+?rw-r--r--  2.0 unx     4296 b- defN 16-Jan-01 00:00 revolve2_modular_robot_physical-1.1.1.dist-info/RECORD
+37 files, 77950 bytes uncompressed, 21979 bytes compressed:  71.8%
```

## zipnote {}

```diff
@@ -45,14 +45,17 @@
 
 Filename: revolve2/modular_robot_physical/remote/__init__.py
 Comment: 
 
 Filename: revolve2/modular_robot_physical/remote/_active_hinge_sensor_state_impl.py
 Comment: 
 
+Filename: revolve2/modular_robot_physical/remote/_camera_sensor_state_impl.py
+Comment: 
+
 Filename: revolve2/modular_robot_physical/remote/_imu_sensor_state_impl.py
 Comment: 
 
 Filename: revolve2/modular_robot_physical/remote/_modular_robot_control_interface_impl.py
 Comment: 
 
 Filename: revolve2/modular_robot_physical/remote/_modular_robot_sensor_state_impl_v1.py
@@ -90,20 +93,20 @@
 
 Filename: revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.pyi
 Comment: 
 
 Filename: revolve2/py.typed
 Comment: 
 
-Filename: revolve2_modular_robot_physical-1.0.2.dist-info/METADATA
+Filename: revolve2_modular_robot_physical-1.1.1.dist-info/METADATA
 Comment: 
 
-Filename: revolve2_modular_robot_physical-1.0.2.dist-info/WHEEL
+Filename: revolve2_modular_robot_physical-1.1.1.dist-info/WHEEL
 Comment: 
 
-Filename: revolve2_modular_robot_physical-1.0.2.dist-info/entry_points.txt
+Filename: revolve2_modular_robot_physical-1.1.1.dist-info/entry_points.txt
 Comment: 
 
-Filename: revolve2_modular_robot_physical-1.0.2.dist-info/RECORD
+Filename: revolve2_modular_robot_physical-1.1.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## revolve2/modular_robot_physical/_protocol_version.py

```diff
@@ -1 +1 @@
-PROTOCOL_VERSION = "1.0.0"
+PROTOCOL_VERSION = "1.0.2"
```

## revolve2/modular_robot_physical/physical_interfaces/_physical_interface.py

```diff
@@ -1,10 +1,12 @@
 from abc import ABC, abstractmethod
 from typing import Sequence
 
+import numpy as np
+from numpy.typing import NDArray
 from pyrr import Vector3
 
 
 class PhysicalInterface(ABC):
     """Abstract implementation for interfacing with hardware."""
 
     @abstractmethod
@@ -71,7 +73,16 @@
     def get_imu_specific_force(self) -> Vector3:
         """
         Get the specific force from the IMU.
 
         :returns: The specific force.
         :raises NotImplementedError: If the IMU is not supported on this hardware.
         """
+
+    @abstractmethod
+    def get_camera_view(self) -> NDArray[np.uint8]:
+        """
+        Get the current view from the camera.
+
+        :return: The camera view.
+        :raises NotImplementedError: If the Camera is not supported on this hardware.
+        """
```

## revolve2/modular_robot_physical/physical_interfaces/v1/_v1_physical_interface.py

```diff
@@ -1,12 +1,14 @@
 import math
 import time
 from typing import Sequence
 
+import numpy as np
 import pigpio
+from numpy.typing import NDArray
 from pyrr import Vector3
 
 from .._physical_interface import PhysicalInterface
 
 
 class V1PhysicalInterface(PhysicalInterface):
     """Implementation of PhysicalInterface for V1 modular robots."""
@@ -122,7 +124,15 @@
     def get_imu_specific_force(self) -> Vector3:
         """
         Get the specific force from the IMU.
 
         :raises NotImplementedError: Always.
         """
         raise NotImplementedError()
+
+    def get_camera_view(self) -> NDArray[np.uint8]:
+        """
+        Get the current view from the camera.
+
+        :raises NotImplementedError: If the Camera is not supported on this hardware.
+        """
+        raise NotImplementedError()
```

## revolve2/modular_robot_physical/physical_interfaces/v2/_v2_physical_interface.py

```diff
@@ -1,10 +1,12 @@
 import math
 from typing import Sequence
 
+import numpy as np
+from numpy.typing import NDArray
 from pyrr import Vector3
 from robohatlib.hal.assemblyboard.PwmPlug import PwmPlug
 from robohatlib.hal.assemblyboard.servo.ServoData import ServoData
 from robohatlib.hal.assemblyboard.ServoAssemblyConfig import ServoAssemblyConfig
 from robohatlib.Robohat import Robohat
 
 from .._physical_interface import PhysicalInterface
@@ -169,7 +171,15 @@
         :returns: The specific force.
         :raises RuntimeError: When imu could not be read.
         """
         accel = self._robohat.get_imu_acceleration()
         if accel is None:
             raise RuntimeError("Could not get IMU acceleration reading!")
         return Vector3(accel)
+
+    def get_camera_view(self) -> NDArray[np.uint8]:
+        """
+        Get the current view from the camera.
+
+        :raises NotImplementedError: If the Camera is not supported on this hardware.
+        """
+        raise NotImplementedError()
```

## revolve2/modular_robot_physical/remote/_modular_robot_sensor_state_impl_v2.py

```diff
@@ -8,41 +8,46 @@
     CameraSensorState,
     IMUSensorState,
     ModularRobotSensorState,
 )
 
 from .._uuid_key import UUIDKey
 from ._active_hinge_sensor_state_impl import ActiveHingeSensorStateImpl
+from ._camera_sensor_state_impl import CameraSensorStateImpl
 from ._imu_sensor_state_impl import IMUSensorStateImpl
 
 
 class ModularRobotSensorStateImplV2(ModularRobotSensorState):
     """Implementation of ModularRobotSensorState for v2 robots."""
 
     _hinge_sensor_mapping: dict[UUIDKey[ActiveHingeSensor], int]
     _hinge_positions: dict[int, float]
 
     _imu_sensor_states: dict[UUIDKey[IMUSensor], IMUSensorStateImpl]
+    _camera_sensor_states: dict[UUIDKey[CameraSensor], CameraSensorStateImpl]
 
     def __init__(
         self,
         hinge_sensor_mapping: dict[UUIDKey[ActiveHingeSensor], int],
         hinge_positions: dict[int, float],
         imu_sensor_states: dict[UUIDKey[IMUSensor], IMUSensorStateImpl],
+        camera_sensor_states: dict[UUIDKey[CameraSensor], CameraSensorStateImpl],
     ) -> None:
         """
         Initialize this object.
 
         :param hinge_sensor_mapping: Mapping from active hinge sensors to pin ids.
         :param hinge_positions: Position of hinges accessed by pin id.
         :param imu_sensor_states: State of the IMU sensors.
+        :param camera_sensor_states: The states of the Camera sensors.
         """
         self._hinge_sensor_mapping = hinge_sensor_mapping
         self._hinge_positions = hinge_positions
         self._imu_sensor_states = imu_sensor_states
+        self._camera_sensor_states = camera_sensor_states
 
     def get_active_hinge_sensor_state(
         self, sensor: ActiveHingeSensor
     ) -> ActiveHingeSensorState:
         """
         Get sensor states for Hinges.
 
@@ -69,10 +74,16 @@
         return state
 
     def get_camera_sensor_state(self, sensor: CameraSensor) -> CameraSensorState:
         """
         Get the state of the provided camera sensor.
 
         :param sensor: The sensor.
-        :raises NotImplementedError: Always.
+        :raises ValueError: If sensor is not found on the robot.
+        :returns: The camera sensor state.
         """
-        raise NotImplementedError()
+        state = self._camera_sensor_states.get(UUIDKey(sensor))
+        if state is None:
+            raise ValueError(
+                "State for camera sensor not found. Does it exist in the robot definition?"
+            )
+        return state
```

## revolve2/modular_robot_physical/remote/_remote.py

```diff
@@ -1,23 +1,27 @@
 import asyncio
 import time
 from typing import Callable
 
 import capnp
+import numpy as np
+from numpy.typing import NDArray
 from pyrr import Vector3
 
 from revolve2.modular_robot.body.base import ActiveHinge
+from revolve2.modular_robot.body.sensors import CameraSensor, IMUSensor
 from revolve2.modular_robot.sensor_state import ModularRobotSensorState
 
 from .._config import Config
 from .._hardware_type import HardwareType
 from .._protocol_version import PROTOCOL_VERSION
 from .._standard_port import STANDARD_PORT
 from .._uuid_key import UUIDKey
 from ..robot_daemon_api import robot_daemon_protocol_capnp
+from ._camera_sensor_state_impl import CameraSensorStateImpl
 from ._imu_sensor_state_impl import IMUSensorStateImpl
 from ._modular_robot_control_interface_impl import ModularRobotControlInterfaceImpl
 from ._modular_robot_sensor_state_impl_v1 import ModularRobotSensorStateImplV1
 from ._modular_robot_sensor_state_impl_v2 import ModularRobotSensorStateImplV2
 
 
 def _active_hinge_targets_to_pin_controls(
@@ -44,18 +48,17 @@
     hostname: str,
     on_prepared: Callable[[], None],
     port: int,
     debug: bool,
     manual_mode: bool,
 ) -> None:
     active_hinge_sensor_to_pin = {
-        UUIDKey(key.value.sensor): pin
+        UUIDKey(key.value.sensors.active_hinge_sensor): pin
         for key, pin in config.hinge_mapping.items()
-        if key.value.sensor
-        if not None
+        if key.value.sensors.active_hinge_sensor is not None
     }
 
     # Make controller
     controller = config.modular_robot.brain.make_instance()
 
     # Connect to robot
     try:
@@ -102,15 +105,15 @@
             sensor_readings: robot_daemon_protocol_capnp.SensorReadings = (
                 await service.controlAndReadSensors(
                     robot_daemon_protocol_capnp.ControlAndReadSensorsArgs(
                         setPins=pin_controls, readPins=[]
                     )
                 )
             ).response
-            print(f"Battery level is at {sensor_readings.battery*100.0}%.")
+            print(f"Battery level is at {sensor_readings.battery * 100.0}%.")
 
     # Fire prepared callback
     on_prepared()
 
     if manual_mode:
         print(
             "Press Ctrl-C to exit. type a value between -1 and 1 to manually set the target for each active hinge."
@@ -151,33 +154,30 @@
             case HardwareType.v2:
                 pins = [pin for pin in active_hinge_sensor_to_pin.values()]
                 sensor_readings = (
                     await service.readSensors(
                         robot_daemon_protocol_capnp.ReadSensorsArgs(readPins=pins)
                     )
                 ).response
-                if config.modular_robot.body.core.imu_sensor is None:
-                    imu_sensor_states = {}
-                else:
-                    imu_sensor_states = {
-                        UUIDKey(
-                            config.modular_robot.body.core.imu_sensor
-                        ): IMUSensorStateImpl(
-                            _capnp_to_vector3(sensor_readings.imuSpecificForce),
-                            _capnp_to_vector3(sensor_readings.imuAngularRate),
-                            _capnp_to_vector3(sensor_readings.imuOrientation),
-                        )
-                    }
+                imu_sensor_states = _get_imu_sensor_state(
+                    config.modular_robot.body.core.sensors.imu_sensor, sensor_readings
+                )
+                camera_sensor_states = _get_camera_sensor_state(
+                    config.modular_robot.body.core.sensors.camera_sensor,
+                    sensor_readings,
+                )
+
                 sensor_state = ModularRobotSensorStateImplV2(
                     hinge_sensor_mapping=active_hinge_sensor_to_pin,
                     hinge_positions={
                         pin: position
                         for pin, position in zip(pins, sensor_readings.pins)
                     },
                     imu_sensor_states=imu_sensor_states,
+                    camera_sensor_states=camera_sensor_states,
                 )
             case _:
                 raise NotImplementedError("Hardware type not supported.")
 
         while (current_time := time.time()) - start_time < config.run_duration:
             # Sleep until next control update
             next_update_at = last_update_time + control_period
@@ -218,46 +218,110 @@
                     sensor_readings = (
                         await service.controlAndReadSensors(
                             robot_daemon_protocol_capnp.ControlAndReadSensorsArgs(
                                 setPins=pin_controls, readPins=pins
                             )
                         )
                     ).response
-                    if config.modular_robot.body.core.imu_sensor is None:
-                        imu_sensor_states = {}
-                    else:
-                        imu_sensor_states = {
-                            UUIDKey(
-                                config.modular_robot.body.core.imu_sensor
-                            ): IMUSensorStateImpl(
-                                _capnp_to_vector3(sensor_readings.imuSpecificForce),
-                                _capnp_to_vector3(sensor_readings.imuAngularRate),
-                                _capnp_to_vector3(sensor_readings.imuOrientation),
-                            )
-                        }
+
+                    imu_sensor_states = _get_imu_sensor_state(
+                        config.modular_robot.body.core.sensors.imu_sensor,
+                        sensor_readings,
+                    )
+                    camera_sensor_states = _get_camera_sensor_state(
+                        config.modular_robot.body.core.sensors.camera_sensor,
+                        sensor_readings,
+                    )
+
                     sensor_state = ModularRobotSensorStateImplV2(
                         hinge_sensor_mapping=active_hinge_sensor_to_pin,
                         hinge_positions={
                             pin: position
                             for pin, position in zip(pins, sensor_readings.pins)
                         },
                         imu_sensor_states=imu_sensor_states,
+                        camera_sensor_states=camera_sensor_states,
                     )
 
                     if battery_print_timer > 5.0:
-                        print(f"Battery level is at {sensor_readings.battery*100.0}%.")
+                        print(
+                            f"Battery level is at {sensor_readings.battery * 100.0}%."
+                        )
                         battery_print_timer = 0.0
                 case _:
                     raise NotImplementedError("Hardware type not supported.")
 
 
 def _capnp_to_vector3(vector: robot_daemon_protocol_capnp.Vector3) -> Vector3:
     return Vector3([vector.x, vector.y, vector.z])
 
 
+def _capnp_to_camera_view(
+    image: robot_daemon_protocol_capnp.Image, camera_size: tuple[int, int]
+) -> NDArray[np.uint8]:
+    """
+    Convert a capnp compatible Image into an NDArray.
+
+    :param image: The capnp Image.
+    :param camera_size: The camera size to reconstruct the image.
+    :return: The NDArray imag.
+    """
+    np_image = np.zeros(shape=(3, *camera_size), dtype=np.uint8)
+    np_image[0] = np.array(image.r).reshape(camera_size).astype(np.uint8)
+    np_image[1] = np.array(image.g).reshape(camera_size).astype(np.uint8)
+    np_image[2] = np.array(image.b).reshape(camera_size).astype(np.uint8)
+    return np_image
+
+
+def _get_imu_sensor_state(
+    imu_sensor: IMUSensor | None,
+    sensor_readings: robot_daemon_protocol_capnp.SensorReadings,
+) -> dict[UUIDKey[IMUSensor], IMUSensorStateImpl]:
+    """
+    Get the IMU sensor state.
+
+    :param imu_sensor: The sensor in question.
+    :param sensor_readings: The sensor readings.
+    :return: The Sensor state.
+    """
+    if imu_sensor is None:
+        return {}
+    else:
+        return {
+            UUIDKey(imu_sensor): IMUSensorStateImpl(
+                _capnp_to_vector3(sensor_readings.imuSpecificForce),
+                _capnp_to_vector3(sensor_readings.imuAngularRate),
+                _capnp_to_vector3(sensor_readings.imuOrientation),
+            )
+        }
+
+
+def _get_camera_sensor_state(
+    camera_sensor: CameraSensor | None,
+    sensor_readings: robot_daemon_protocol_capnp.SensorReadings,
+) -> dict[UUIDKey[CameraSensor], CameraSensorStateImpl]:
+    """
+    Get the camera sensor state.
+
+    :param camera_sensor: The sensor in question.
+    :param sensor_readings: The sensor readings.
+    :return: The Sensor state.
+    """
+    if camera_sensor is None:
+        return {}
+    else:
+        return {
+            UUIDKey(camera_sensor): CameraSensorStateImpl(
+                _capnp_to_camera_view(
+                    sensor_readings.cameraView, camera_sensor.camera_size
+                )
+            )
+        }
+
+
 def run_remote(
     config: Config,
     hostname: str,
     on_prepared: Callable[[], None] = lambda: None,
     port: int = STANDARD_PORT,
     debug: bool = False,
     manual_mode: bool = False,
```

## revolve2/modular_robot_physical/robot_daemon/_robo_server_impl.py

```diff
@@ -1,17 +1,21 @@
 import threading
 import time
 from typing import Any, Sequence
 
+import numpy as np
+from numpy.typing import NDArray
 from pyrr import Vector3
 
 from .._hardware_type import HardwareType
 from .._protocol_version import PROTOCOL_VERSION
 from ..physical_interfaces import PhysicalInterface
 from ..robot_daemon_api import robot_daemon_protocol_capnp
+from ..robot_daemon_api.robot_daemon_protocol_capnp import Image as capnpImage
+from ..robot_daemon_api.robot_daemon_protocol_capnp import Vector3 as capnpVector3
 
 
 class RoboServerImpl(robot_daemon_protocol_capnp.RoboServer.Server):  # type: ignore
     """Implements the Cap'n Proto interface."""
 
     _CAREFUL_STEP = 0.1
 
@@ -94,15 +98,17 @@
                                     max(
                                         (desired_target - maybe_current_target),
                                         -self._CAREFUL_STEP,
                                     ),
                                     self._CAREFUL_STEP,
                                 )
                             )
-                        case HardwareType.v2:  # careful mode disabled for v2. enable when running into power failures.
+                        case (
+                            HardwareType.v2
+                        ):  # careful mode disabled for v2. enable when running into power failures.
                             targets.append(desired_target)
 
             for pin, target in zip(pins, targets):
                 self._current_targets[pin] = target
 
             self._physical_interface.set_servo_targets(pins, targets)
 
@@ -249,21 +255,45 @@
                 pins_readings.append(value)
 
             battery = self._physical_interface.get_battery_level()
 
             imu_orientation = self._physical_interface.get_imu_orientation()
             imu_specific_force = self._physical_interface.get_imu_specific_force()
             imu_angular_rate = self._physical_interface.get_imu_angular_rate()
+            camera_view = self._physical_interface.get_camera_view()
 
         return robot_daemon_protocol_capnp.SensorReadings(
             pins=pins_readings,
             battery=battery,
             imuOrientation=self._vector3_to_capnp(imu_orientation),
             imuSpecificForce=self._vector3_to_capnp(imu_specific_force),
             imuAngularRate=self._vector3_to_capnp(imu_angular_rate),
+            cameraView=self._camera_view_to_capnp(camera_view),
         )
 
     @staticmethod
-    def _vector3_to_capnp(vector: Vector3) -> Vector3:
+    def _vector3_to_capnp(vector: Vector3) -> capnpVector3:
+        """
+        Convert a pyrr Vector3 object into a capnp compatible Vector3.
+
+        :param vector: The pyrr Vector3.
+        :return: The capnp Vector3.
+        """
         return robot_daemon_protocol_capnp.Vector3(
             x=float(vector.x), y=float(vector.y), z=float(vector.z)
         )
+
+    @staticmethod
+    def _camera_view_to_capnp(image: NDArray[np.uint8]) -> capnpImage:
+        """
+        Convert an image as an NDArray into an capnp compatible Image.
+
+        Not that we flatten the channels so they have to be reconstructed later on.
+
+        :param image: The NDArray image.
+        :return: The capnp Image object.
+        """
+        return robot_daemon_protocol_capnp.Image(
+            r=list(image[0].flatten().astype(np.uint8)),
+            g=list(image[1].flatten().astype(np.uint8)),
+            b=list(image[2].flatten().astype(np.uint8)),
+        )
```

## revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol.capnp

```diff
@@ -35,20 +35,27 @@
 
 struct Vector3 {
   x @0 :Float32;
   y @1 :Float32;
   z @2 :Float32;
 }
 
+struct Image {
+  r @0 :List(Int32);
+  g @1 :List(Int32);
+  b @2 :List(Int32);
+}
+
 struct SensorReadings {
   pins @0 :List(Float32);
   battery @1 :Float32;
   imuOrientation @2 :Vector3;
   imuSpecificForce @3 :Vector3;
   imuAngularRate @4 :Vector3;
+  cameraView @5 :Image;
 }
 
 interface RoboServer {
   setup @0 (args :SetupArgs) -> (response :SetupResponse);
   control @1 (args :ControlArgs);
   readSensors @2 (args :ReadSensorsArgs) -> (response :SensorReadings);
   controlAndReadSensors @3 (args :ControlAndReadSensorsArgs) -> (response :SensorReadings);
```

## revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.py

```diff
@@ -1,12 +1,13 @@
 """
 This is an automatically generated stub for `robot_daemon_protocol.capnp`.
 
 This file was manually edited to contain the RoboServer interface.
 """
+
 import os
 
 import capnp  # type: ignore
 
 capnp.remove_import_hook()
 here = os.path.dirname(os.path.abspath(__file__))
 module_file = os.path.abspath(os.path.join(here, "robot_daemon_protocol.capnp"))
@@ -27,11 +28,14 @@
 ReadSensorsArgsReader = ReadSensorsArgs
 ControlAndReadSensorsArgs = capnp.load(module_file).ControlAndReadSensorsArgs
 ControlAndReadSensorsArgsBuilder = ControlAndReadSensorsArgs
 ControlAndReadSensorsArgsReader = ControlAndReadSensorsArgs
 Vector3 = capnp.load(module_file).Vector3
 Vector3Builder = Vector3
 Vector3Reader = Vector3
+Image = capnp.load(module_file).Image
+ImageBuilder = Image
+ImageReader = Image
 SensorReadings = capnp.load(module_file).SensorReadings
 SensorReadingsBuilder = SensorReadings
 SensorReadingsReader = SensorReadings
 RoboServer = capnp.load(module_file).RoboServer
```

## revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.pyi

```diff
@@ -1,12 +1,11 @@
 """
 This is an automatically generated stub for `robot_daemon_protocol.capnp`.
 
 This file was manually edited to work better with the code tools.
-
 Added __init__ functions
 Made `dict` into `dict[Any,Any]`
 Formatted file with black
 RoboServer
 """
 
 from __future__ import annotations
@@ -285,27 +284,67 @@
     def to_segments(self) -> list[bytes]: ...
     def as_reader(self) -> Vector3Reader: ...
     @staticmethod
     def write(file: BufferedWriter) -> None: ...
     @staticmethod
     def write_packed(file: BufferedWriter) -> None: ...
 
+class Image:
+    r: list[int]
+    g: list[int]
+    b: list[int]
+    def __init__(self, r: list[int], g: list[int], b: list[int]) -> None: ...
+    @staticmethod
+    @contextmanager
+    def from_bytes(
+        data: bytes,
+        traversal_limit_in_words: int | None = ...,
+        nesting_limit: int | None = ...,
+    ) -> Iterator[ImageReader]: ...
+    @staticmethod
+    def from_bytes_packed(
+        data: bytes,
+        traversal_limit_in_words: int | None = ...,
+        nesting_limit: int | None = ...,
+    ) -> ImageReader: ...
+    @staticmethod
+    def new_message() -> ImageBuilder: ...
+    def to_dict(self) -> dict[Any, Any]: ...
+
+class ImageReader(Image):
+    def as_builder(self) -> ImageBuilder: ...
+
+class ImageBuilder(Image):
+    @staticmethod
+    def from_dict(dictionary: dict[Any, Any]) -> ImageBuilder: ...
+    def copy(self) -> ImageBuilder: ...
+    def to_bytes(self) -> bytes: ...
+    def to_bytes_packed(self) -> bytes: ...
+    def to_segments(self) -> list[bytes]: ...
+    def as_reader(self) -> ImageReader: ...
+    @staticmethod
+    def write(file: BufferedWriter) -> None: ...
+    @staticmethod
+    def write_packed(file: BufferedWriter) -> None: ...
+
 class SensorReadings:
     pins: Sequence[float]
     battery: float
     imuOrientation: Vector3 | Vector3Builder | Vector3Reader
     imuSpecificForce: Vector3 | Vector3Builder | Vector3Reader
     imuAngularRate: Vector3 | Vector3Builder | Vector3Reader
+    cameraView: Image | ImageBuilder | ImageReader
     def __init__(
         self,
         pins: Sequence[float],
         battery: float,
         imuOrientation: Vector3 | Vector3Builder | Vector3Reader,
         imuSpecificForce: Vector3 | Vector3Builder | Vector3Reader,
         imuAngularRate: Vector3 | Vector3Builder | Vector3Reader,
+        cameraView: Image | ImageBuilder | ImageReader,
     ) -> None: ...
     @staticmethod
     @contextmanager
     def from_bytes(
         data: bytes,
         traversal_limit_in_words: int | None = ...,
         nesting_limit: int | None = ...,
```

## Comparing `revolve2_modular_robot_physical-1.0.2.dist-info/METADATA` & `revolve2_modular_robot_physical-1.1.1.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 Metadata-Version: 2.1
 Name: revolve2-modular-robot-physical
-Version: 1.0.2
+Version: 1.1.1
 Summary: Revolve2: Everything for physical modular robot control. This package is intended to be installed on the modular robot hardware.
 Home-page: https://github.com/ci-group/revolve2
 Author: Aart Stuurman
 Author-email: aartstuurman@hotmail.com
 Requires-Python: >=3.10,<3.12
-Classifier: Development Status :: 4 - Beta
+Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Topic :: Scientific/Engineering
@@ -18,21 +18,21 @@
 Provides-Extra: botv1
 Provides-Extra: botv2
 Provides-Extra: dev
 Provides-Extra: remote
 Requires-Dist: pigpio (>=1.78,<2.0) ; extra == "botv1" or extra == "dev"
 Requires-Dist: pycapnp (>=2.0.0b2,<3.0.0)
 Requires-Dist: pyrr (>=0.10.3,<0.11.0)
-Requires-Dist: revolve2-modular-robot (==1.0.2)
-Requires-Dist: revolve2-robohat (==0.5.0)
+Requires-Dist: revolve2-modular-robot (==1.1.1)
+Requires-Dist: revolve2-robohat (==0.5.0) ; extra == "botv2" or extra == "dev"
 Requires-Dist: typed-argparse (>=0.3.1,<0.4.0)
 Project-URL: Repository, https://github.com/ci-group/revolve2
 Description-Content-Type: text/markdown
 
-<img  align="right" width="150" height="150"  src="./docs/source/logo.png">
+<img align="right" width="150" height="150"  src="./docs/source/logo_light.png">
 
 # Revolve2
 
 Revolve2 is a collection of Python packages used for researching evolutionary algorithms and modular robotics.
 Its primary features are a modular robot framework, an abstraction layer around physics simulators, and evolutionary algorithms.
 
 **Documentation: [ci-group.github.io/revolve2](https://ci-group.github.io/revolve2)**
```

## Comparing `revolve2_modular_robot_physical-1.0.2.dist-info/RECORD` & `revolve2_modular_robot_physical-1.1.1.dist-info/RECORD`

 * *Files 7% similar despite different names*

```diff
@@ -1,36 +1,37 @@
 revolve2/modular_robot_physical/__init__.py,sha256=qGFqwQqJgMQo41dlojVU2ZiEs9R-4_MBdMYCS_1x2_U,317
 revolve2/modular_robot_physical/_bin/__init__.py,sha256=NZMqU5jat5V_rc-UUsG_nRR19R1Wsa3I65_KKY0WgBo,144
 revolve2/modular_robot_physical/_bin/robot_daemon.py,sha256=Jc_KNrtOV6Kw-8wd-5hEHtt0hs9MBYzI9NocMJptgyo,907
 revolve2/modular_robot_physical/_config.py,sha256=I5Ygw8mPLrWnUkm3ucym8YCQVnpF9I54W9bF9aV6ONQ,1285
 revolve2/modular_robot_physical/_hardware_type.py,sha256=jjM1-gIYmrMpTD-DkMszrr4A0wFmJjOCLMw5EfWlQAo,122
-revolve2/modular_robot_physical/_protocol_version.py,sha256=5MlkRG0O4kkwKVQLNCoXgVTsG3Mc5kROnL4d0un8qns,27
+revolve2/modular_robot_physical/_protocol_version.py,sha256=VCoDC9lraKpxH9AUWsOdJhC6BImGPWwAW7E8qnrBaI0,27
 revolve2/modular_robot_physical/_standard_port.py,sha256=94vKk-i5FtiePjAYEQ-ekk9VYn5gMIm5sR939F9I5os,22
 revolve2/modular_robot_physical/_uuid_key.py,sha256=Z5Rptf8Y_c0K3DrMICSqnm4-QVRs-x8bLDIVMeSD7uQ,1455
 revolve2/modular_robot_physical/physical_interfaces/__init__.py,sha256=5ZZVCoBxZ9c1bX3PbcCoRYTIFYCWBpUiRJyBghjs974,178
 revolve2/modular_robot_physical/physical_interfaces/_get_interface.py,sha256=ByEc0T37arYAGwchJEKiq71_ouAJUbM6uUe2ms6kOCw,1355
-revolve2/modular_robot_physical/physical_interfaces/_physical_interface.py,sha256=sc6_dXGrR8SAm0HRqfbks-ryiPF-FA_erUKYeyf8zr4,2165
+revolve2/modular_robot_physical/physical_interfaces/_physical_interface.py,sha256=QBOVGHFts2a10hzuoE_wBIZPxzrRukbnImxuhxRaVUc,2481
 revolve2/modular_robot_physical/physical_interfaces/v1/__init__.py,sha256=C2wCrSAtoGtX4n-eY7CttlDDAlHKHo1xvTNVKeq5pmI,136
-revolve2/modular_robot_physical/physical_interfaces/v1/_v1_physical_interface.py,sha256=HCuqPQvdm8T_H_DoH6Zf-TL2QfPXflOGb8qmJWfTUa8,3847
+revolve2/modular_robot_physical/physical_interfaces/v1/_v1_physical_interface.py,sha256=aXR4TuJU8_JMM8YiUPhGUZtzkS5sZyEcWQGoYTpLtNQ,4145
 revolve2/modular_robot_physical/physical_interfaces/v2/__init__.py,sha256=D-qEZkesxwJgugYq1leJs_HWZkVF1wwU7uhW0BCRNCw,136
-revolve2/modular_robot_physical/physical_interfaces/v2/_v2_physical_interface.py,sha256=uc5cf90ACKhg7-8wRA1ixnrbiXQ4epc6yj1IO9I8jpQ,5742
+revolve2/modular_robot_physical/physical_interfaces/v2/_v2_physical_interface.py,sha256=LORS0qZVV2jtQoZxngOVgdJg9AVsKchL0wf2b3pSCkg,6040
 revolve2/modular_robot_physical/remote/__init__.py,sha256=_8ZSfPlDWPyxpsnXHv__ECcgrsWbMaTmeAU15GIQvHo,181
 revolve2/modular_robot_physical/remote/_active_hinge_sensor_state_impl.py,sha256=K6Fuc5wpGSJbVZsKjMk4R73BpxyNM2tLlaEV1olGsN0,621
+revolve2/modular_robot_physical/remote/_camera_sensor_state_impl.py,sha256=7JRrDClojB41Gotp-8Cuma6IfblDVpJrS8P3Xr1gTpw,618
 revolve2/modular_robot_physical/remote/_imu_sensor_state_impl.py,sha256=88t8A7B9NusbSoiodZbBbScl6adlatwClF88EjFPhfo,1282
 revolve2/modular_robot_physical/remote/_modular_robot_control_interface_impl.py,sha256=rur75K8hxH40_2OS6Rt_i7RccCnrLeUNsyH8t0smpIQ,868
 revolve2/modular_robot_physical/remote/_modular_robot_sensor_state_impl_v1.py,sha256=f2eBtnvi8QzUwKbu12Nt30mDf_VwXQSbq8p97M3OC-A,1280
-revolve2/modular_robot_physical/remote/_modular_robot_sensor_state_impl_v2.py,sha256=tiE0cTXAvs9m0aDLSRYps09ba6WTKUODTO9mByvsvU0,2576
-revolve2/modular_robot_physical/remote/_remote.py,sha256=QmYHsxmLobg4TBg0mADbUi6eguNgNMhwGD5YqpegqfM,11072
+revolve2/modular_robot_physical/remote/_modular_robot_sensor_state_impl_v2.py,sha256=q3wsG1eGVSxRokKHBEQXF3rCdiioZBCeGkjW_C8A98A,3200
+revolve2/modular_robot_physical/remote/_remote.py,sha256=HsB4xIlIwnuXJtpn9YDoExF5SwP7jLU_7DRa0JTUghI,12981
 revolve2/modular_robot_physical/remote/_test_physical_robot.py,sha256=n75edU4CVqOIEjONTgXwhMfg1MXejoNp1kLB4I6wTBQ,1486
 revolve2/modular_robot_physical/robot_daemon/__init__.py,sha256=o9A5NPuyJnj7IkbTgjMwxa52j8BzNWrKS2Clkdy7W1w,125
-revolve2/modular_robot_physical/robot_daemon/_robo_server_impl.py,sha256=AOHcvG8lGVoqzCpPMoS5H3t6tV0WUisFEJ-PE9dKYx8,8890
+revolve2/modular_robot_physical/robot_daemon/_robo_server_impl.py,sha256=CRnPN724RabqgBDai6LXeJG-7XgLsz57fh3DsMI8HQA,10055
 revolve2/modular_robot_physical/robot_daemon/_robot_daemon.py,sha256=PZBxNImJybzcIkSC8DYSX_pqFe9a_9Y4C0a5rMq-8Nk,2442
 revolve2/modular_robot_physical/robot_daemon_api/__init__.py,sha256=tSOv0a86RO2JT33zJIEJyD5-F9j2PjEKVnHfYt_h74U,363
 revolve2/modular_robot_physical/robot_daemon_api/_generate_stubs.sh,sha256=LlnSmp08oGS6bXDTeTSxe1zknqBbYqjgvAeK0hntHok,227
-revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol.capnp,sha256=6OjCW4QA-QIj0mMYg2wewC76RpK2RzW5o4cLU2zEYFs,1052
-revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.py,sha256=1ndPaa1muCa1c932rGK5XfUS93gIOGtKt1IbAu8p8O0,1414
-revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.pyi,sha256=YbN_7NSgOcXixBw-cFNyQ9Y1FOZzQsk-U4CXU5ARjvc,11514
+revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol.capnp,sha256=wOITWyJGiWyVK2nkakTyLdA7-ia-gxXdLEhGbjpUbT8,1157
+revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.py,sha256=5USX3BzeDqsfBdKHde63V6CujfX90-qpPoG__ZBjDys,1494
+revolve2/modular_robot_physical/robot_daemon_api/robot_daemon_protocol_capnp.pyi,sha256=NOM9g0BxOZcKGOeD9c9cxs8NsvU9pdHt2mQ0BEiOur0,12800
 revolve2/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-revolve2_modular_robot_physical-1.0.2.dist-info/METADATA,sha256=GDMDJ2iqh2ZiIDygQ-QfOZmVTz9bEoH_3k0UC3PO1uk,3494
-revolve2_modular_robot_physical-1.0.2.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
-revolve2_modular_robot_physical-1.0.2.dist-info/entry_points.txt,sha256=3lOtroPAw2KS4WWFyVWMZIOwPvTN3j0S66_ycrHXDX8,87
-revolve2_modular_robot_physical-1.0.2.dist-info/RECORD,,
+revolve2_modular_robot_physical-1.1.1.dist-info/METADATA,sha256=lvc3_M_K5fTOHHGSMytoCNqT1KOK0VlsNSqtArmtrXw,3549
+revolve2_modular_robot_physical-1.1.1.dist-info/WHEEL,sha256=sP946D7jFCHeNz5Iq4fL4Lu-PrWrFsgfLXbbkciIZwg,88
+revolve2_modular_robot_physical-1.1.1.dist-info/entry_points.txt,sha256=3lOtroPAw2KS4WWFyVWMZIOwPvTN3j0S66_ycrHXDX8,87
+revolve2_modular_robot_physical-1.1.1.dist-info/RECORD,,
```

