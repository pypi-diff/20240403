# Comparing `tmp/huaweicloudsdkcore-3.1.9-py2.py3-none-any.whl.zip` & `tmp/huaweicloudsdkcore-3.1.90-py2.py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,57 +1,76 @@
-Zip file size: 57654 bytes, number of entries: 55
--rw-------  2.0 unx        0 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/__init__.py
--rw-------  2.0 unx    22007 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/client.py
--rw-------  2.0 unx     1283 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/sdk_request.py
--rw-------  2.0 unx     2388 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/sdk_response.py
--rw-------  2.0 unx      951 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/sdk_stream_request.py
--rw-------  2.0 unx     1142 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/sdk_stream_response.py
--rw-------  2.0 unx        0 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/auth/__init__.py
--rw-------  2.0 unx     1070 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/auth/cache.py
--rw-------  2.0 unx    12950 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/auth/credentials.py
--rw-------  2.0 unx     8173 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/auth/internal.py
--rw-------  2.0 unx     8955 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/auth/provider.py
--rw-------  2.0 unx        0 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/exceptions/__init__.py
--rw-------  2.0 unx     7464 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/exceptions/exceptions.py
--rw-------  2.0 unx        0 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/http/__init__.py
--rw-------  2.0 unx     1825 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/http/formdata.py
--rw-------  2.0 unx     8231 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/http/http_client.py
--rw-------  2.0 unx     4040 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/http/http_config.py
--rw-------  2.0 unx     1842 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/http/http_handler.py
--rw-------  2.0 unx     1173 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/http/primitive_types.py
--rw-------  2.0 unx        0 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/region/__init__.py
--rw-------  2.0 unx     2512 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/region/cache.py
--rw-------  2.0 unx     2611 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/region/provider.py
--rw-------  2.0 unx     1423 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/region/region.py
--rw-------  2.0 unx        0 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/signer/__init__.py
--rw-------  2.0 unx     2722 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/signer/hkdf.py
--rw-------  2.0 unx     9274 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/signer/signer.py
--rw-------  2.0 unx        0 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/utils/__init__.py
--rw-------  2.0 unx      893 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/utils/core_utils.py
--rw-------  2.0 unx     4329 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/utils/http_utils.py
--rw-------  2.0 unx     1195 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/utils/path_utils.py
--rw-------  2.0 unx     1418 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/utils/six_utils.py
--rw-------  2.0 unx     1289 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/utils/string_utils.py
--rw-------  2.0 unx      203 b- defN 22-Nov-08 07:42 huaweicloudsdkcore/utils/time_utils.py
--rw-------  2.0 unx        0 b- defN 22-Nov-08 07:42 tests/__init__.py
--rw-------  2.0 unx     3499 b- defN 22-Nov-08 07:42 tests/test_client_build.py
--rw-------  2.0 unx     9160 b- defN 22-Nov-08 07:42 tests/test_credential_provider.py
--rw-------  2.0 unx     1608 b- defN 22-Nov-08 07:42 tests/test_endpoint_without_scheme.py
--rw-------  2.0 unx     3181 b- defN 22-Nov-08 07:42 tests/test_federal_credentials.py
--rw-------  2.0 unx     3798 b- defN 22-Nov-08 07:42 tests/test_region_provider.py
--rw-------  2.0 unx     3909 b- defN 22-Nov-08 07:42 tests/test_region_with_project_id.py
--rw-------  2.0 unx     2355 b- defN 22-Nov-08 07:42 tests/test_region_without_project_id.py
--rw-------  2.0 unx     7306 b- defN 22-Nov-08 07:42 tests/test_request_and_exceptions.py
--rw-------  2.0 unx     2065 b- defN 22-Nov-08 07:42 tests/test_signer.py
--rw-------  2.0 unx     2022 b- defN 22-Nov-08 07:42 tests/test_upload_download.py
--rw-------  2.0 unx        0 b- defN 22-Nov-08 07:42 tests/model/__init__.py
--rw-------  2.0 unx        0 b- defN 22-Nov-08 07:42 tests/model/service/__init__.py
--rw-------  2.0 unx     1449 b- defN 22-Nov-08 07:42 tests/model/service/service_client.py
--rw-------  2.0 unx     1486 b- defN 22-Nov-08 07:42 tests/model/service/service_region.py
--rw-------  2.0 unx       76 b- defN 22-Nov-08 07:42 tests/model/vpc/__init__.py
--rw-------  2.0 unx     2388 b- defN 22-Nov-08 07:42 tests/model/vpc/list_vpcs_response.py
--rw-------  2.0 unx      604 b- defN 22-Nov-08 07:44 huaweicloudsdkcore-3.1.9.dist-info/LICENSE
--rw-------  2.0 unx     1478 b- defN 22-Nov-08 07:44 huaweicloudsdkcore-3.1.9.dist-info/METADATA
--rw-------  2.0 unx      110 b- defN 22-Nov-08 07:44 huaweicloudsdkcore-3.1.9.dist-info/WHEEL
--rw-------  2.0 unx       25 b- defN 22-Nov-08 07:44 huaweicloudsdkcore-3.1.9.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     4990 b- defN 22-Nov-08 07:44 huaweicloudsdkcore-3.1.9.dist-info/RECORD
-55 files, 162872 bytes uncompressed, 49560 bytes compressed:  69.6%
+Zip file size: 87434 bytes, number of entries: 74
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/__init__.py
+-rw-r--r--  2.0 unx    29157 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/client.py
+-rw-r--r--  2.0 unx     3221 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/sdk_request.py
+-rw-r--r--  2.0 unx     2225 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/sdk_response.py
+-rw-r--r--  2.0 unx      997 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/sdk_stream_request.py
+-rw-r--r--  2.0 unx     1188 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/sdk_stream_response.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/auth/__init__.py
+-rw-r--r--  2.0 unx     1116 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/auth/cache.py
+-rw-r--r--  2.0 unx    14444 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/auth/credentials.py
+-rw-r--r--  2.0 unx     9104 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/auth/internal.py
+-rw-r--r--  2.0 unx     8993 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/auth/provider.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/exceptions/__init__.py
+-rw-r--r--  2.0 unx     4581 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/exceptions/exception_handler.py
+-rw-r--r--  2.0 unx     6398 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/exceptions/exceptions.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/http/__init__.py
+-rw-r--r--  2.0 unx     2258 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/http/formdata.py
+-rw-r--r--  2.0 unx     1176 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/http/future_session.py
+-rw-r--r--  2.0 unx     5021 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/http/http_client.py
+-rw-r--r--  2.0 unx     5048 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/http/http_config.py
+-rw-r--r--  2.0 unx     2224 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/http/http_handler.py
+-rw-r--r--  2.0 unx     1218 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/http/primitive_types.py
+-rw-r--r--  2.0 unx     4009 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/http/progress.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/invoker/__init__.py
+-rw-r--r--  2.0 unx     2625 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/invoker/invoker.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/region/__init__.py
+-rw-r--r--  2.0 unx     2778 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/region/cache.py
+-rw-r--r--  2.0 unx     2699 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/region/provider.py
+-rw-r--r--  2.0 unx     3149 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/region/region.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/signer/__init__.py
+-rw-r--r--  2.0 unx     1129 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/signer/algorithm.py
+-rw-r--r--  2.0 unx     3757 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/signer/hkdf.py
+-rw-r--r--  2.0 unx    14108 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/signer/signer.py
+-rw-r--r--  2.0 unx    14260 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/signer/utils.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/utils/__init__.py
+-rw-r--r--  2.0 unx      939 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/utils/core_utils.py
+-rw-r--r--  2.0 unx     1699 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/utils/filepath_utils.py
+-rw-r--r--  2.0 unx     4405 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/utils/http_utils.py
+-rw-r--r--  2.0 unx     1596 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/utils/six_utils.py
+-rw-r--r--  2.0 unx     1335 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/utils/string_utils.py
+-rw-r--r--  2.0 unx     1046 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/utils/time_utils.py
+-rw-r--r--  2.0 unx     6407 b- defN 24-Apr-03 11:22 huaweicloudsdkcore/utils/xml_utils.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 tests/__init__.py
+-rw-r--r--  2.0 unx     3612 b- defN 24-Apr-03 11:22 tests/test_client.py
+-rw-r--r--  2.0 unx     3528 b- defN 24-Apr-03 11:22 tests/test_client_build.py
+-rw-r--r--  2.0 unx     9195 b- defN 24-Apr-03 11:22 tests/test_credential_provider.py
+-rw-r--r--  2.0 unx     2893 b- defN 24-Apr-03 11:22 tests/test_credentials.py
+-rw-r--r--  2.0 unx     1615 b- defN 24-Apr-03 11:22 tests/test_endpoint_without_scheme.py
+-rw-r--r--  2.0 unx     4109 b- defN 24-Apr-03 11:22 tests/test_extract_error_message.py
+-rw-r--r--  2.0 unx     3181 b- defN 24-Apr-03 11:22 tests/test_federal_credentials.py
+-rw-r--r--  2.0 unx     1446 b- defN 24-Apr-03 11:22 tests/test_new_region.py
+-rw-r--r--  2.0 unx     2255 b- defN 24-Apr-03 11:22 tests/test_parse_body.py
+-rw-r--r--  2.0 unx     3571 b- defN 24-Apr-03 11:22 tests/test_region_provider.py
+-rw-r--r--  2.0 unx     3924 b- defN 24-Apr-03 11:22 tests/test_region_with_project_id.py
+-rw-r--r--  2.0 unx     2357 b- defN 24-Apr-03 11:22 tests/test_region_without_project_id.py
+-rw-r--r--  2.0 unx     7315 b- defN 24-Apr-03 11:22 tests/test_request_and_exceptions.py
+-rw-r--r--  2.0 unx     6652 b- defN 24-Apr-03 11:22 tests/test_signer.py
+-rw-r--r--  2.0 unx     2191 b- defN 24-Apr-03 11:22 tests/test_upload_download.py
+-rw-r--r--  2.0 unx     3575 b- defN 24-Apr-03 11:22 tests/test_xml_transfer.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 tests/mocker/__init__.py
+-rw-r--r--  2.0 unx     1241 b- defN 24-Apr-03 11:22 tests/mocker/file_response_mocker.py
+-rw-r--r--  2.0 unx     1446 b- defN 24-Apr-03 11:22 tests/mocker/project_response_mocker.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 tests/model/__init__.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 tests/model/obs/__init__.py
+-rw-r--r--  2.0 unx     4790 b- defN 24-Apr-03 11:22 tests/model/obs/model.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:22 tests/model/service/__init__.py
+-rw-r--r--  2.0 unx     1449 b- defN 24-Apr-03 11:22 tests/model/service/service_client.py
+-rw-r--r--  2.0 unx     1476 b- defN 24-Apr-03 11:22 tests/model/service/service_region.py
+-rw-r--r--  2.0 unx       76 b- defN 24-Apr-03 11:22 tests/model/vpc/__init__.py
+-rw-r--r--  2.0 unx     2388 b- defN 24-Apr-03 11:22 tests/model/vpc/list_vpcs_response.py
+-rw-r--r--  2.0 unx      604 b- defN 24-Apr-03 11:23 huaweicloudsdkcore-3.1.90.dist-info/LICENSE
+-rw-r--r--  2.0 unx     1566 b- defN 24-Apr-03 11:23 huaweicloudsdkcore-3.1.90.dist-info/METADATA
+-rw-r--r--  2.0 unx      110 b- defN 24-Apr-03 11:23 huaweicloudsdkcore-3.1.90.dist-info/WHEEL
+-rw-r--r--  2.0 unx       25 b- defN 24-Apr-03 11:23 huaweicloudsdkcore-3.1.90.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     6690 b- defN 24-Apr-03 11:23 huaweicloudsdkcore-3.1.90.dist-info/RECORD
+74 files, 247590 bytes uncompressed, 76650 bytes compressed:  69.0%
```

## zipnote {}

```diff
@@ -30,35 +30,50 @@
 
 Filename: huaweicloudsdkcore/auth/provider.py
 Comment: 
 
 Filename: huaweicloudsdkcore/exceptions/__init__.py
 Comment: 
 
+Filename: huaweicloudsdkcore/exceptions/exception_handler.py
+Comment: 
+
 Filename: huaweicloudsdkcore/exceptions/exceptions.py
 Comment: 
 
 Filename: huaweicloudsdkcore/http/__init__.py
 Comment: 
 
 Filename: huaweicloudsdkcore/http/formdata.py
 Comment: 
 
+Filename: huaweicloudsdkcore/http/future_session.py
+Comment: 
+
 Filename: huaweicloudsdkcore/http/http_client.py
 Comment: 
 
 Filename: huaweicloudsdkcore/http/http_config.py
 Comment: 
 
 Filename: huaweicloudsdkcore/http/http_handler.py
 Comment: 
 
 Filename: huaweicloudsdkcore/http/primitive_types.py
 Comment: 
 
+Filename: huaweicloudsdkcore/http/progress.py
+Comment: 
+
+Filename: huaweicloudsdkcore/invoker/__init__.py
+Comment: 
+
+Filename: huaweicloudsdkcore/invoker/invoker.py
+Comment: 
+
 Filename: huaweicloudsdkcore/region/__init__.py
 Comment: 
 
 Filename: huaweicloudsdkcore/region/cache.py
 Comment: 
 
 Filename: huaweicloudsdkcore/region/provider.py
@@ -66,56 +81,80 @@
 
 Filename: huaweicloudsdkcore/region/region.py
 Comment: 
 
 Filename: huaweicloudsdkcore/signer/__init__.py
 Comment: 
 
+Filename: huaweicloudsdkcore/signer/algorithm.py
+Comment: 
+
 Filename: huaweicloudsdkcore/signer/hkdf.py
 Comment: 
 
 Filename: huaweicloudsdkcore/signer/signer.py
 Comment: 
 
+Filename: huaweicloudsdkcore/signer/utils.py
+Comment: 
+
 Filename: huaweicloudsdkcore/utils/__init__.py
 Comment: 
 
 Filename: huaweicloudsdkcore/utils/core_utils.py
 Comment: 
 
-Filename: huaweicloudsdkcore/utils/http_utils.py
+Filename: huaweicloudsdkcore/utils/filepath_utils.py
 Comment: 
 
-Filename: huaweicloudsdkcore/utils/path_utils.py
+Filename: huaweicloudsdkcore/utils/http_utils.py
 Comment: 
 
 Filename: huaweicloudsdkcore/utils/six_utils.py
 Comment: 
 
 Filename: huaweicloudsdkcore/utils/string_utils.py
 Comment: 
 
 Filename: huaweicloudsdkcore/utils/time_utils.py
 Comment: 
 
+Filename: huaweicloudsdkcore/utils/xml_utils.py
+Comment: 
+
 Filename: tests/__init__.py
 Comment: 
 
+Filename: tests/test_client.py
+Comment: 
+
 Filename: tests/test_client_build.py
 Comment: 
 
 Filename: tests/test_credential_provider.py
 Comment: 
 
+Filename: tests/test_credentials.py
+Comment: 
+
 Filename: tests/test_endpoint_without_scheme.py
 Comment: 
 
+Filename: tests/test_extract_error_message.py
+Comment: 
+
 Filename: tests/test_federal_credentials.py
 Comment: 
 
+Filename: tests/test_new_region.py
+Comment: 
+
+Filename: tests/test_parse_body.py
+Comment: 
+
 Filename: tests/test_region_provider.py
 Comment: 
 
 Filename: tests/test_region_with_project_id.py
 Comment: 
 
 Filename: tests/test_region_without_project_id.py
@@ -126,17 +165,35 @@
 
 Filename: tests/test_signer.py
 Comment: 
 
 Filename: tests/test_upload_download.py
 Comment: 
 
+Filename: tests/test_xml_transfer.py
+Comment: 
+
+Filename: tests/mocker/__init__.py
+Comment: 
+
+Filename: tests/mocker/file_response_mocker.py
+Comment: 
+
+Filename: tests/mocker/project_response_mocker.py
+Comment: 
+
 Filename: tests/model/__init__.py
 Comment: 
 
+Filename: tests/model/obs/__init__.py
+Comment: 
+
+Filename: tests/model/obs/model.py
+Comment: 
+
 Filename: tests/model/service/__init__.py
 Comment: 
 
 Filename: tests/model/service/service_client.py
 Comment: 
 
 Filename: tests/model/service/service_region.py
@@ -144,23 +201,23 @@
 
 Filename: tests/model/vpc/__init__.py
 Comment: 
 
 Filename: tests/model/vpc/list_vpcs_response.py
 Comment: 
 
-Filename: huaweicloudsdkcore-3.1.9.dist-info/LICENSE
+Filename: huaweicloudsdkcore-3.1.90.dist-info/LICENSE
 Comment: 
 
-Filename: huaweicloudsdkcore-3.1.9.dist-info/METADATA
+Filename: huaweicloudsdkcore-3.1.90.dist-info/METADATA
 Comment: 
 
-Filename: huaweicloudsdkcore-3.1.9.dist-info/WHEEL
+Filename: huaweicloudsdkcore-3.1.90.dist-info/WHEEL
 Comment: 
 
-Filename: huaweicloudsdkcore-3.1.9.dist-info/top_level.txt
+Filename: huaweicloudsdkcore-3.1.90.dist-info/top_level.txt
 Comment: 
 
-Filename: huaweicloudsdkcore-3.1.9.dist-info/RECORD
+Filename: huaweicloudsdkcore-3.1.90.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## huaweicloudsdkcore/client.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -16,56 +18,79 @@
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
 import datetime
 import decimal
-import importlib
 import logging
+import os
 import re
 import sys
+import threading
+import warnings
+from collections import OrderedDict
+from typing import Iterable
 from logging.handlers import RotatingFileHandler
 
-import six
 import simplejson as json
-from six.moves.urllib.parse import quote, urlparse
+import six
 from requests_toolbelt import MultipartEncoder
+from six.moves.urllib.parse import quote, urlparse
 
 from huaweicloudsdkcore.auth.credentials import BasicCredentials, DerivedCredentials
 from huaweicloudsdkcore.auth.provider import CredentialProviderChain
+from huaweicloudsdkcore.exceptions.exceptions import HostUnreachableException
+from huaweicloudsdkcore.exceptions.exception_handler import ExceptionHandler, DefaultExceptionHandler
+from huaweicloudsdkcore.http import progress
+from huaweicloudsdkcore.http.formdata import FormFile
 from huaweicloudsdkcore.http.http_client import HttpClient
 from huaweicloudsdkcore.http.http_config import HttpConfig
 from huaweicloudsdkcore.http.http_handler import HttpHandler
-from huaweicloudsdkcore.http.primitive_types import native_types_mapping
-from huaweicloudsdkcore.http.primitive_types import primitive_types
+from huaweicloudsdkcore.http.primitive_types import NATIVE_TYPES_MAPPING
+from huaweicloudsdkcore.http.primitive_types import PRIMITIVE_TYPES
 from huaweicloudsdkcore.sdk_request import SdkRequest
-from huaweicloudsdkcore.sdk_response import FutureSdkResponse
+from huaweicloudsdkcore.sdk_response import FutureSdkResponse, SdkResponse
 from huaweicloudsdkcore.sdk_stream_response import SdkStreamResponse
 from huaweicloudsdkcore.utils import http_utils, core_utils
-from huaweicloudsdkcore.http.formdata import FormFile
-
+from huaweicloudsdkcore.utils.filepath_utils import ensure_file_in_rb_mode
+from huaweicloudsdkcore.utils.xml_utils import XmlTransfer
 
-class ClientBuilder(object):
+try:
+    from typing import TypeVar, Generic
+except ImportError:
+    from typing_extensions import TypeVar, Generic
+if six.PY3:
+    from typing import Mapping
+
+    _BASE_ITER_TYPES = (str, bytes, list, tuple, Mapping)
+else:
+    _BASE_ITER_TYPES = (str, bytes, list, tuple, dict)
+
+T = TypeVar("T")
+
+
+class ClientBuilder(Generic[T]):
+    _HTTP_SCHEME = "http"
+    _HTTPS_SCHEME = "https"
 
     def __init__(self, client_type, credential_type=BasicCredentials.__name__):
+        # type: (T, str) -> None
         self._client_type = client_type
         self._credential_type = credential_type.split(',')
         self._derived_auth_service_name = None
         self._config = None
         self._credentials = None
         self._region = None
-        self._endpoint = None
+        self._endpoints = []
 
         self._http_handler = None
         self._file_logger_handler = None
         self._stream_logger_handler = None
-
-        self._http_scheme = "http"
-        self._https_scheme = "https"
+        self._exception_handler = None
 
     def with_http_config(self, config):
         """
         :param config: Config for ClientBuilder
         :type config: :class:`huaweicloudsdkcore.http.http_config.HttpConfig`
         """
         self._config = config
@@ -88,15 +113,28 @@
         return self
 
     def with_endpoint(self, endpoint):
         """
         :param endpoint: Endpoint for ClientBuilder
         :type endpoint: str
         """
-        self._endpoint = endpoint
+        warnings.warn("As of 3.1.27, because of the support of the multi-endpoint feature, use with_endpoints instead",
+                      DeprecationWarning)
+        return self.with_endpoints([endpoint])
+
+    def with_endpoints(self, endpoints):
+        self._endpoints = endpoints
+        return self
+
+    def with_exception_handler(self, exception_handler):
+        """
+        :param exception_handler: ExceptionHandler for ClientBuilder
+        :type exception_handler: :class:`huaweicloudsdkcore.exceptions.exception_handler.ExceptionHandler`
+        """
+        self._exception_handler = exception_handler
         return self
 
     def with_http_handler(self, http_handler):
         """
         :param http_handler: HttpHandler for ClientBuilder
         :type http_handler: :class:`huaweicloudsdkcore.http.http_handler.HttpHandler`
         """
@@ -122,75 +160,84 @@
         return self
 
     def _with_derived_auth_service_name(self, derived_auth_service_name):
         self._derived_auth_service_name = derived_auth_service_name
         return self
 
     def build(self):
+        # type: () -> T
         if self._config is None:
             self._config = HttpConfig.get_default_config()
 
         client = self._client_type() \
             .with_credentials(self._credentials) \
             .with_config(self._config) \
-            .with_http_handler(self._http_handler)
+            .with_http_handler(self._http_handler) \
+            .with_exception_handler(self._exception_handler)
 
         client.init_http_client()
+        if self._file_logger_handler is not None:
+            client.add_file_logger(**self._file_logger_handler)
+        if self._stream_logger_handler is not None:
+            client.add_stream_logger(**self._stream_logger_handler)
 
         if not self._credentials:
             provider = CredentialProviderChain.get_default_credential_provider_chain(self._credential_type[0])
             self._credentials = provider.get_credentials()
 
         if not self._credentials:
             raise ValueError("credential can not be None, %s credential objects are required"
                              % ",".join(self._credential_type))
         if self._credentials.__class__.__name__ not in self._credential_type:
             raise TypeError("credential type error, supported credential type is %s" % ",".join(self._credential_type))
 
         if self._region is not None:
-            self._endpoint = self._region.endpoint
+            self._endpoints += self._region.endpoints
             self._credentials = self._credentials.process_auth_params(client.get_http_client(), self._region.id)
 
             if isinstance(self._credentials, DerivedCredentials):
                 self._credentials._process_derived_auth_params(self._derived_auth_service_name, self._region.id)
 
-        if not self._endpoint.startswith(self._http_scheme):
-            self._endpoint = self._https_scheme + "://" + self._endpoint
+        if not self._endpoints:
+            raise ValueError("Could not find any endpoints, at least one endpoint is required")
+        self._endpoints = [endpoint if endpoint.startswith(self._HTTP_SCHEME) else self._HTTPS_SCHEME + "://" + endpoint
+                           for endpoint in self._endpoints]
 
-        client.with_endpoint(self._endpoint) \
-            .with_credentials(self._credentials)
-
-        if self._file_logger_handler is not None:
-            client.add_file_logger(**self._file_logger_handler)
-        if self._stream_logger_handler is not None:
-            client.add_stream_logger(**self._stream_logger_handler)
+        client.with_endpoints(self._endpoints).with_credentials(self._credentials)
 
         return client
 
 
 class Client(object):
+    _CONTENT_TYPE = "Content-Type"
+    _APPLICATION_JSON = "application/json"
+    _APPLICATION_XML = "application/xml"
+    _APPLICATION_OCTET_STREAM = "application/octet-stream"
+    _APPLICATION_X_WWW_FORM_URLENCODED = "application/x-www-form-urlencoded"
+    _MULTIPART_FORM_DATA = "multipart/form-data"
+    _XML_NAME = "xml_name"
+    _AUTHORIZATION = "Authorization"
+    _HEADERS = "headers"
+
     def __init__(self):
         self.preset_headers = {}
-
         self._agent = {"User-Agent": "huaweicloud-usdk-python/3.0"}
         self._logger = self._init_logger()
 
         self._credentials = None
         self._config = None
-        self._endpoint = None
+        self._endpoint_index = 0
+        self._endpoints = []
+        self._mutex = threading.Lock()
 
         self._http_client = None
         self._http_handler = None
+        self._exception_handler = None
 
         self.model_package = None
-        try:
-            exception_handler_model_name = "%s.exception_handler" % self.__module__[:self.__module__.rindex('.')]
-            self.exception_handler_model = importlib.import_module(exception_handler_model_name)
-        except ImportError:
-            self.exception_handler_model = None
 
     @classmethod
     def _init_logger(cls):
         logger_name = 'HuaweiCloud-SDK-%s' % cls.__name__
         logger = logging.getLogger(logger_name)
         logger.propagate = False
         return logger
@@ -207,34 +254,43 @@
         """
         :param credentials: Credential for Client
         :type credentials: :class:`huaweicloudsdkcore.auth.credentials.Credentials`
         """
         self._credentials = credentials
         return self
 
-    def with_endpoint(self, endpoint):
+    def with_endpoints(self, endpoints):
         """
-        :param endpoint: Endpoint for Client
-        :type endpoint: str
+        :param endpoints: Endpoint for Client
+        :type endpoints: str
+        """
+        self._endpoints += endpoints
+        return self
+
+    def with_exception_handler(self, exception_handler):
+        """
+        :param exception_handler: ExceptionHandler for Client
+        :type exception_handler: :class:`huaweicloudsdkcore.exceptions.exception_handler.ExceptionHandler`
         """
-        self._endpoint = endpoint
+        self._exception_handler = exception_handler
         return self
 
     def with_http_handler(self, http_handler):
         """
         :param http_handler: HttpHandler for Client
         :type http_handler: :class:`huaweicloudsdkcore.http.http_handler.HttpHandler`
         """
         self._http_handler = http_handler if http_handler is not None else HttpHandler()
         return self
 
     def init_http_client(self):
-        exception_handler = None \
-            if self.exception_handler_model is None else getattr(self.exception_handler_model, "handle_exception")
-        self._http_client = HttpClient(self._config, self._http_handler, exception_handler, self._logger)
+        if not self._exception_handler or not isinstance(self._exception_handler, ExceptionHandler):
+            self._exception_handler = DefaultExceptionHandler()
+        if not self._http_client:
+            self._http_client = HttpClient(self._config, self._http_handler, self._exception_handler, self._logger)
 
     def add_stream_logger(self, stream, log_level, format_string):
         self._logger.setLevel(log_level)
         stream_handler = logging.StreamHandler(stream)
         stream_handler.setLevel(log_level)
         formatter = logging.Formatter(format_string if format_string is not None else core_utils.LOG_FORMAT)
         stream_handler.setFormatter(formatter)
@@ -258,212 +314,302 @@
     def get_credentials(self):
         return self._credentials
 
     def get_http_client(self):
         return self._http_client
 
     def _parse_header_params(self, collection_formats, header_params):
-        header_params = self.post_process_params(header_params) or {}
-        header_params.update(self.preset_headers)
+        header_params = self._post_process_params(header_params) or {}
         if header_params:
             header_params = http_utils.sanitize_for_serialization(header_params)
             header_params = dict(http_utils.parameters_to_tuples(header_params, collection_formats))
             header_params = {k: str(v) for k, v in header_params.items()}
         header_params.update(self._agent)
+        if self.preset_headers:
+            header_params.update(self.preset_headers)
         return header_params
 
     def _parse_path_params(self, collection_formats, path_params, resource_path, update_path_params):
-        path_params = self.post_process_params(path_params) or {}
+        path_params = self._post_process_params(path_params) or {}
         if path_params:
             path_params = http_utils.sanitize_for_serialization(path_params)
-            path_params = http_utils.parameters_to_tuples(path_params, collection_formats)
-            for k, v in path_params:
+            for k, v in http_utils.parameters_to_tuples(path_params, collection_formats):
                 resource_path = resource_path.replace('{%s}' % k, quote(str(v), safe=''))
         if update_path_params:
             update_path_params = http_utils.sanitize_for_serialization(update_path_params)
-            update_path_params = http_utils.parameters_to_tuples(update_path_params, collection_formats)
-            for k, v in update_path_params:
+            for k, v in http_utils.parameters_to_tuples(update_path_params, collection_formats):
                 resource_path = resource_path.replace('{%s}' % k, quote(str(v), safe=''))
         return resource_path
 
     def _parse_query_params(self, collection_formats, query_params):
-        query_params = self.post_process_params(query_params) or []
+        query_params = self._post_process_params(query_params) or []
         if query_params:
             query_params = http_utils.sanitize_for_serialization(query_params)
-            query_params = http_utils.parameters_to_tuples(query_params, collection_formats)
+            # Use 'multi' collection format to parse query params
+            multi_collection_formats = {k: 'multi' for k, v in collection_formats.items()} \
+                if isinstance(collection_formats, dict) else {}
+            query_params = http_utils.parameters_to_tuples(query_params, multi_collection_formats)
         return query_params
 
     def _parse_post_params(self, collection_formats, post_params):
-        post_params = self.post_process_params(post_params) if post_params else {}
+        post_params = self._post_process_params(post_params) if post_params else {}
         if post_params:
             post_params = http_utils.sanitize_for_serialization(post_params)
-            post_params = http_utils.parameters_to_tuples(post_params, collection_formats)
+            return http_utils.parameters_to_tuples(post_params, collection_formats)
         return post_params
 
     @classmethod
-    def _parse_body(cls, body, post_params):
-        if body:
-            if six.PY3:
-                from typing import Mapping
-                if all([hasattr(body, '__iter__'), not isinstance(body, (str, bytes, list, tuple, Mapping))]):
-                    return body
-            else:
-                if all([hasattr(body, '__iter__'), not isinstance(body, (str, bytes, list, tuple, dict))]):
-                    return body
-            body = http_utils.sanitize_for_serialization(body)
-            body = json.dumps(body, use_decimal=True)
-        elif len(post_params) != 0:
-            body = post_params
-        else:
-            body = ""
-        return body
+    def _parse_xml_body(cls, body):
+        root_name = getattr(body, cls._XML_NAME) if hasattr(body, cls._XML_NAME) else body.__class__.__name__
+        _dict = {root_name: http_utils.sanitize_for_serialization(body)}
+        return XmlTransfer().to_string(_dict)
+
+    @classmethod
+    def _parse_body(cls, body, post_params=None):
+        # type: (str|list|dict|Iterable|None, dict) -> dict|str|Iterable|None
+        if post_params:
+            return post_params
+        if body is None or isinstance(body, six.text_type) or cls._is_iterable_body(body):
+            return body
+
+        return json.dumps(http_utils.sanitize_for_serialization(body), use_decimal=True) if body else json.dumps(body)
+
+    @classmethod
+    def _is_iterable_body(cls, body):
+        if not isinstance(body, Iterable):
+            return False
+
+        return not isinstance(body, _BASE_ITER_TYPES)
+
+    @classmethod
+    def _parse_form_urlencoded_body(cls, body):
+        if not body:
+            body = {}
+        body = http_utils.sanitize_for_serialization(body)
+        # handle bool: True -> 'true'
+        return {k: str(v).lower() if isinstance(v, bool) else v for k, v in body.items()}
 
     @classmethod
-    def _parse_formdata_body(cls, body, headers):
+    def _parse_form_data_body(cls, body):
         if not body:
-            return body, headers
+            body = {}
         body = http_utils.sanitize_for_serialization(body)
-        body = {k: v.convert_to_file_tuple() if isinstance(v, FormFile) else str(v) for k, v in body.items()}
-        multipart = MultipartEncoder(fields=body)
-        headers["Content-Type"] = multipart.content_type
-        return multipart, headers
+
+        fields = OrderedDict()
+        files = []
+        for key, value in body.items():
+            if isinstance(value, FormFile):
+                files.append((key, value))
+            else:
+                fields[key] = str(value).lower() if isinstance(value, bool) else str(value)
+        for file_tuple in files:
+            fields[file_tuple[0]] = file_tuple[1].convert_to_file_tuple()
+
+        return MultipartEncoder(fields=fields)
+
+    @classmethod
+    def _parse_stream_body(cls, body, callback, content_length):
+        file_stream = ensure_file_in_rb_mode(body)
+        if callback:
+            if not content_length:
+                try:
+                    content_length = os.fstat(file_stream.fileno()).st_size
+                except (IOError, OSError):
+                    content_length = -1
+            notifier = progress.ProgressNotifier(callback=callback, total_amount=content_length)
+            stream_body = progress.ProgressRequestBody(file_stream, notifier)
+        else:
+            stream_body = file_stream
+
+        return stream_body
 
     def _is_stream(self, response_type):
-        if type(response_type) == str and hasattr(self.model_package, response_type):
+        if isinstance(response_type, str) and hasattr(self.model_package, response_type):
             klass = getattr(self.model_package, response_type)
             if issubclass(klass, SdkStreamResponse):
                 return True
         return False
 
     @classmethod
-    def post_process_params(cls, params):
-        if type(params) == dict:
+    def _post_process_params(cls, params):
+        if isinstance(params, dict):
             for key in list(params.keys()):
                 if params[key] is None:
                     del [params[key]]
             return params
-        elif type(params) == list:
-            list_filter = filter(lambda x: type(x) == tuple and len(x) == 2 and x[1] is not None, params)
+
+        if isinstance(params, list):
+            list_filter = filter(lambda x: isinstance(x, tuple) and len(x) == 2 and x[1] is not None, params)
             return [i for i in list_filter]
 
-    def do_http_request(self, method, resource_path, path_params=None, query_params=None, header_params=None, body=None,
-                        post_params=None, response_type=None, response_headers=None, collection_formats=None,
-                        request_type=None, async_request=False):
-        url_parse_result = urlparse(self._endpoint)
+        return None
+
+    def _url_parse(self, cname):
+        parse_result = urlparse(self._endpoints[self._endpoint_index])
+        if cname:
+            endpoint = "%s://%s.%s" % (parse_result.scheme, cname, parse_result.netloc)
+            parse_result = urlparse(endpoint)
+        return parse_result
+
+    def do_http_request(self, method, resource_path, path_params=None, query_params=None, header_params=None,
+                        body=None, post_params=None, cname=None, response_type=None, response_headers=None,
+                        collection_formats=None, request_type=None, async_request=False, progress_callback=None):
+
+        if async_request:
+            future_request = self.build_future_request(method, resource_path, path_params, query_params, header_params,
+                                                       body, post_params, cname, response_type, collection_formats,
+                                                       progress_callback)
+            future_response = self._http_client.executor.submit(self._do_http_request_async, future_request,
+                                                                response_type, response_headers, progress_callback)
+            return FutureSdkResponse(future_response, self._logger)
+
+        while True:
+            try:
+                request = self.build_future_request(method, resource_path, path_params, query_params, header_params,
+                                                    body, post_params, cname, response_type,
+                                                    collection_formats, progress_callback).result()
+                response = self._do_http_request_sync(request)
+                break
+            except HostUnreachableException as e:
+                with self._mutex:
+                    if self._endpoint_index < len(self._endpoints) - 1:
+                        self._endpoint_index += 1
+                    else:
+                        self._endpoint_index = 0
+                        raise e
+
+        return self.sync_response_handler(response, response_type, response_headers, progress_callback)
+
+    def build_future_request(self, method, resource_path, path_params, query_params, header_params,
+                             request_body, post_params, cname, response_type, collection_formats, progress_callback):
+        url_parse_result = self._url_parse(cname)
         schema = url_parse_result.scheme
         host = url_parse_result.netloc
 
         header_params = self._parse_header_params(collection_formats, header_params)
         resource_path = self._parse_path_params(collection_formats, path_params, resource_path,
                                                 self._credentials.get_update_path_params())
         query_params = self._parse_query_params(collection_formats, query_params)
         post_params = self._parse_post_params(collection_formats, post_params)
 
-        if isinstance(header_params, dict) \
-                and header_params.setdefault("Content-Type", "").startswith("multipart/form-data"):
-            body, header_params = self._parse_formdata_body(body, header_params)
+        if self._config.ignore_content_type_for_get_request and method == "GET" and not request_body:
+            content_type = header_params.pop(self._CONTENT_TYPE, None)
         else:
-            body = self._parse_body(body, post_params)
+            content_type = header_params.setdefault(self._CONTENT_TYPE, self._APPLICATION_JSON)
 
-        stream = self._is_stream(response_type)
-        sdk_request = SdkRequest(method=method, schema=schema, host=host, resource_path=resource_path,
-                                 query_params=query_params, header_params=header_params, body=body, stream=stream)
-        if "Authorization" not in header_params:
-            future_request = self._credentials.process_auth_request(sdk_request, self._http_client)
+        if content_type == self._MULTIPART_FORM_DATA:
+            body = self._parse_form_data_body(request_body)
+            header_params[self._CONTENT_TYPE] = body.content_type
+        elif content_type == self._APPLICATION_X_WWW_FORM_URLENCODED:
+            body = self._parse_form_urlencoded_body(request_body)
+        elif content_type == self._APPLICATION_XML:
+            body = self._parse_xml_body(request_body)
+        elif content_type == self._APPLICATION_OCTET_STREAM:
+            content_length = header_params.get("content-length")
+            body = self._parse_stream_body(request_body, progress_callback, content_length)
         else:
-            future_request = self._http_client.executor.submit(lambda: sdk_request)
+            body = self._parse_body(request_body, post_params)
 
-        if async_request:
-            future_response = self._http_client.executor.submit(self._do_http_request_async, future_request,
-                                                                response_type, response_headers)
-            return FutureSdkResponse(future_response, self._logger)
+        stream = self._is_stream(response_type)
+        sdk_request = SdkRequest(method=method, schema=schema, host=host, resource_path=resource_path,
+                                 query_params=query_params, header_params=header_params, body=body, stream=stream,
+                                 signing_algorithm=self._config.signing_algorithm)
+        if self._AUTHORIZATION not in header_params:
+            return self._credentials.process_auth_request(sdk_request, self._http_client)
         else:
-            request = future_request.result()
-            response = self._do_http_request_sync(request)
-            return self.sync_response_handler(response, response_type, response_headers)
+            return self._http_client.executor.submit(lambda: sdk_request)
 
     def _do_http_request_sync(self, request):
         response = self._http_client.do_request_sync(request)
         return response
 
-    def _do_http_request_async(self, future_request, response_type, response_headers):
+    def _do_http_request_async(self, future_request, response_type, response_headers, progress_callback):
         request = future_request.result()
         future_response = self._http_client.do_request_async(
-            request=request, hooks=[self.async_response_hook_factory(response_type, response_headers)]
+            request=request,
+            hooks=[self.async_response_hook_factory(response_type, response_headers, progress_callback)]
         )
         return future_response
 
-    def sync_response_handler(self, response, response_type, response_headers):
-        return_data = self.deserialize(response, response_type)
-        self.set_response_status_code(return_data, response)
-        if response_headers is not None and len(response_headers) > 0:
-            self.set_response_headers(return_data, response, response_headers)
+    def sync_response_handler(self, response, response_type, response_headers, progress_callback):
+        concrete_response = self.deserialize(response, response_type, progress_callback)
+        if isinstance(concrete_response, SdkResponse):
+            concrete_response.status_code = response.status_code
+        if response_headers:
+            self._set_response_headers(concrete_response, response, response_headers)
 
-        if not issubclass(return_data.__class__, SdkStreamResponse):
-            return_data.raw_content = response.content
+        if not isinstance(concrete_response, SdkStreamResponse):
+            concrete_response.raw_content = response.content
 
-        return return_data
+        return concrete_response
 
-    def async_response_hook_factory(self, response_type, response_headers):
+    def async_response_hook_factory(self, response_type, response_headers, progress_callback):
         def response_hook(resp, *args, **kwargs):
-            resp.data = self.sync_response_handler(resp, response_type, response_headers)
+            resp.data = self.sync_response_handler(resp, response_type, response_headers, progress_callback)
 
         return response_hook
 
     @classmethod
-    def set_response_status_code(cls, return_data, response):
-        setattr(return_data, "status_code", response.status_code)
-
-    @classmethod
-    def set_response_headers(cls, return_data, response, response_headers):
-        if not hasattr(return_data, "attribute_map"):
+    def _set_response_headers(cls, concrete_response, response, response_headers):
+        if not hasattr(concrete_response, "attribute_map"):
             return
 
-        for attr in return_data.attribute_map:
-            if getattr(return_data, attr) is not None:
+        attribute_map = getattr(concrete_response, "attribute_map")
+        for attr in attribute_map:
+            if getattr(concrete_response, attr) is not None:
                 continue
-            key_in_response_headers = return_data.attribute_map[attr]
+            key_in_response_headers = attribute_map[attr]
             if key_in_response_headers in response_headers and key_in_response_headers in response.headers:
-                setattr(return_data, attr, response.headers[key_in_response_headers])
+                setattr(concrete_response, attr, response.headers[key_in_response_headers])
 
-    def deserialize(self, response, response_type):
-        if type(response_type) == str and hasattr(self.model_package, response_type):
+    def deserialize(self, response, response_type, progress_callback):
+        if isinstance(response_type, str) and hasattr(self.model_package, response_type):
             klass = getattr(self.model_package, response_type)
             if issubclass(klass, SdkStreamResponse):
+                if progress_callback:
+                    content_length = int(response.headers.get("Content-Length")) \
+                        if "Content-Length" in response.headers else -1
+                    notifier = progress.ProgressNotifier(callback=progress_callback, total_amount=content_length)
+                    progress.ProgressHTTPResponse.convert(response.raw, notifier)
                 return klass(response)
 
         try:
-            data = json.loads(six.ensure_str(response.text), parse_float=decimal.Decimal)
+            if hasattr(response, self._HEADERS) and response.headers.get(self._CONTENT_TYPE) == self._APPLICATION_XML:
+                data = XmlTransfer().to_dict(response.content, ignore_root=True)
+            else:
+                data = json.loads(six.ensure_str(response.text), parse_float=decimal.Decimal)
         except ValueError:
             data = response.text
         return self._deserialize(data, response_type)
 
     def _deserialize(self, data, klass):
         if data is None:
             return None
 
-        if type(klass) == str:
+        if isinstance(klass, str):
             if klass.startswith('list['):
+                if not isinstance(data, list):
+                    data = [data]
                 sub_kls = re.match(r'list\[(.*)\]', klass).group(1)
                 return [self._deserialize(sub_data, sub_kls)
                         for sub_data in data]
 
             if klass.startswith('dict('):
                 sub_kls = re.match(r'dict\(([^,]*), (.*)\)', klass).group(2)
                 return {k: self._deserialize(v, sub_kls)
                         for k, v in six.iteritems(data)}
 
-            if klass in native_types_mapping:
-                klass = native_types_mapping[klass]
+            if klass in NATIVE_TYPES_MAPPING:
+                klass = NATIVE_TYPES_MAPPING[klass]
             elif klass == FormFile.TYPE:
-                return FormFile(open(data, "rb"))
+                return FormFile(data)
             else:
                 klass = getattr(self.model_package, klass)
 
-        if klass in primitive_types:
+        if klass in PRIMITIVE_TYPES:
             return self._deserialize_primitive(data, klass)
         elif klass == decimal.Decimal:
             return data
         elif klass == object:
             return self._deserialize_object(data)
         elif klass == datetime.date:
             return self._deserialize_date(data)
@@ -503,34 +649,46 @@
         except ImportError:
             return string
         except ValueError:
             return string
 
     def _deserialize_model(self, data, klass):
         if not klass.openapi_types and not hasattr(klass, 'get_real_child_model'):
-            if type(data) == int and hasattr(klass, "_%s" % data):
-                return getattr(klass, "_%s" % data)
-            if type(data) == str and hasattr(klass, re.sub(r'\W+', '_', data).upper()):
+            if isinstance(data, str) and hasattr(klass, re.sub(r'\W+', '_', data).upper()):
                 return getattr(klass, re.sub(r'\W+', '_', data).upper())
-            if type(data) == bool and hasattr(klass, str(data).upper()):
+
+            if isinstance(data, bool) and hasattr(klass, str(data).upper()):
                 return getattr(klass, str(data).upper())
-            if type(data) == float and hasattr(klass, ("_%s" % data).replace('.', '_')):
+
+            if isinstance(data, float) and hasattr(klass, ("_%s" % data).replace('.', '_')):
                 return getattr(klass, ("_%s" % data).replace('.', '_'))
-            return klass()
 
-        kwargs = {}
-        if klass.openapi_types is not None:
-            for attr, attr_type in six.iteritems(klass.openapi_types):
-                if data is not None and isinstance(data, (list, dict)):
-                    if klass.attribute_map[attr] == "body":
-                        kwargs[attr] = self._deserialize(data, attr_type)
-                    if klass.attribute_map[attr] in data:
-                        value = data[klass.attribute_map[attr]]
-                        kwargs[attr] = self._deserialize(value, attr_type)
+            if isinstance(data, int) and hasattr(klass, "_%s" % data):
+                return getattr(klass, "_%s" % data)
+
+            return klass()
 
-        instance = klass(**kwargs)
+        instance = klass(**self._extract_kwargs(data, klass))
 
         if hasattr(instance, 'get_real_child_model'):
             klass_name = instance.get_real_child_model(data)
             if klass_name:
                 instance = self._deserialize(data, klass_name)
         return instance
+
+    def _extract_kwargs(self, data, klass):
+        kwargs = {}
+        if not klass.openapi_types or not data:
+            return kwargs
+
+        for attr, attr_type in six.iteritems(klass.openapi_types):
+            if isinstance(data, (list, dict)):
+                if klass.attribute_map[attr] == "body":
+                    kwargs[attr] = self._deserialize(data, attr_type)
+                if klass.attribute_map[attr] in data:
+                    value = data[klass.attribute_map[attr]]
+                    kwargs[attr] = self._deserialize(value, attr_type)
+            elif isinstance(data, six.text_type):
+                if klass.attribute_map[attr] == "body":
+                    kwargs[attr] = self._deserialize(data, attr_type)
+
+        return kwargs
```

## huaweicloudsdkcore/sdk_request.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -13,21 +15,107 @@
  Unless required by applicable law or agreed to in writing,
  software distributed under the LICENSE is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
+from huaweicloudsdkcore.signer.algorithm import SigningAlgorithm
 
 
 class SdkRequest(object):
     def __init__(self, method='GET', schema=None, host=None, resource_path=None, uri=None, query_params=None,
-                 header_params=None, body=None, stream=False):
-        self.method = method
-        self.schema = schema
-        self.host = host
-        self.resource_path = resource_path
-        self.uri = uri
-        self.query_params = query_params
-        self.header_params = header_params
-        self.body = body
-        self.stream = stream
+                 header_params=None, body=None, stream=False, signing_algorithm=SigningAlgorithm.get_default()):
+        self._method = method
+        self._schema = schema
+        self._host = host
+        self._resource_path = resource_path
+        self._uri = uri
+        self._query_params = query_params
+        self._header_params = header_params
+        self._body = body
+        self._stream = stream
+        self._signing_algorithm = signing_algorithm
+
+    @property
+    def method(self):
+        return self._method
+
+    @method.setter
+    def method(self, method):
+        self._method = method
+
+    @property
+    def schema(self):
+        return self._schema
+
+    @schema.setter
+    def schema(self, schema):
+        self._schema = schema
+
+    @property
+    def host(self):
+        return self._host
+
+    @host.setter
+    def host(self, host):
+        self._host = host
+
+    @property
+    def resource_path(self):
+        return self._resource_path
+
+    @resource_path.setter
+    def resource_path(self, resource_path):
+        self._resource_path = resource_path
+
+    @property
+    def uri(self):
+        return self._uri
+
+    @uri.setter
+    def uri(self, uri):
+        self._uri = uri
+
+    @property
+    def query_params(self):
+        return self._query_params
+
+    @query_params.setter
+    def query_params(self, query_params):
+        self._query_params = query_params
+
+    @property
+    def header_params(self):
+        return self._header_params
+
+    @header_params.setter
+    def header_params(self, header_params):
+        self._header_params = header_params
+
+    @property
+    def body(self):
+        return self._body
+
+    @body.setter
+    def body(self, body):
+        self._body = body
+
+    @property
+    def stream(self):
+        return self._stream
+
+    @stream.setter
+    def stream(self, stream):
+        self._stream = stream
+
+    @property
+    def signing_algorithm(self):
+        return self._signing_algorithm
+
+    @signing_algorithm.setter
+    def signing_algorithm(self, signing_algorithm):
+        self._signing_algorithm = signing_algorithm
+
+    @property
+    def url(self):
+        return "%s://%s%s" % (self.schema, self.host, self.uri)
```

## huaweicloudsdkcore/sdk_response.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -15,44 +17,54 @@
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
 import json
-from huaweicloudsdkcore.exceptions import exceptions
+
 from requests.exceptions import ConnectionError
-from urllib3.exceptions import SSLError, NewConnectionError
+
+from huaweicloudsdkcore.exceptions.exception_handler import process_connection_error
 
 
 class SdkResponse(object):
     def __init__(self):
-        self.status_code = None
-        self.header_params = None
-        self.raw_content = None
+        self._status_code = None  # type: int | None
+        self._raw_content = None  # type: bytes | None
+
+    @property
+    def status_code(self):
+        return self._status_code
+
+    @status_code.setter
+    def status_code(self, status_code):
+        if not self._status_code:
+            self._status_code = status_code
+
+    @property
+    def raw_content(self):
+        return self._raw_content
+
+    @raw_content.setter
+    def raw_content(self, raw_content):
+        if not self._raw_content:
+            self._raw_content = raw_content
 
     def to_json_object(self):
-        if self.raw_content is not None:
-            return json.loads(self.raw_content.decode("utf-8"))
+        return json.loads(self._raw_content.decode("utf-8")) if self._raw_content else None
 
 
 class FutureSdkResponse:
     def __init__(self, future, logger):
         self._future = future
         self._logger = logger
 
     def result(self):
         try:
             future_response = self._future.result().result()
             response = future_response.data \
-                if hasattr(future_response, 'data') and future_response.data is not None else future_response
-        except ConnectionError as connectionError:
-            for each in connectionError.args:
-                if isinstance(each.reason, SSLError):
-                    self._logger.error("Sync SslHandShakeException occurred. %s" % str(each.reason))
-                    raise exceptions.SslHandShakeException(str(each.reason))
-                if isinstance(each.reason, NewConnectionError):
-                    self._logger.error("Sync ConnectionException occurred. %s" % str(each.reason))
-                    raise exceptions.ConnectionException(str(each.reason))
-            self._logger.error("ConnectionException occurred. %s" % str(connectionError))
-            raise exceptions.ConnectionException(str(connectionError))
+                if hasattr(future_response, "data") and future_response.data is not None else future_response
+        except ConnectionError as conn_err:
+            raise process_connection_error(conn_err, self._logger)
+
         return response
```

## huaweicloudsdkcore/sdk_stream_request.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
```

## huaweicloudsdkcore/sdk_stream_response.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
```

## huaweicloudsdkcore/auth/cache.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2021 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
```

## huaweicloudsdkcore/auth/credentials.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -13,72 +15,85 @@
  Unless required by applicable law or agreed to in writing,
  software distributed under the LICENSE is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
-
-import re
 import os
+import re
 from abc import abstractmethod
 
-from huaweicloudsdkcore.auth.internal import Iam, Metadata
-from huaweicloudsdkcore.exceptions.exceptions import ApiValueError, ServiceResponseException
-from huaweicloudsdkcore.signer.signer import Signer, DerivationAKSKSigner
 from huaweicloudsdkcore.auth.cache import AuthCache
+from huaweicloudsdkcore.auth.internal import Iam, Metadata
+from huaweicloudsdkcore.exceptions.exceptions import ApiValueError, ServiceResponseException, SdkException
+from huaweicloudsdkcore.signer.algorithm import SigningAlgorithm
+from huaweicloudsdkcore.signer.signer import Signer, SM3Signer, DerivationAKSKSigner, P256SHA256Signer, SM2SM3Signer
 from huaweicloudsdkcore.utils import time_utils, six_utils
+from huaweicloudsdkcore.sdk_request import SdkRequest
+from huaweicloudsdkcore.http.http_client import HttpClient
 
 
 class DerivedCredentials(six_utils.get_abstract_meta_class()):
     _DEFAULT_ENDPOINT_REG = "^[a-z][a-z0-9-]+(\\.[a-z]{2,}-[a-z]+-\\d{1,2})?\\.(my)?(huaweicloud|myhwclouds).(com|cn)"
 
     @abstractmethod
     def _process_derived_auth_params(self, derived_auth_service_name, region_id):
+        # type: (str, str) -> None
         pass
 
     @abstractmethod
     def with_derived_predicate(self, derived_predicate):
         pass
 
     @abstractmethod
     def _is_derived_auth(self, request):
+        # type: (SdkRequest) -> bool
         pass
 
     @classmethod
     def get_default_derived_predicate(cls):
         return lambda request: False if re.match(cls._DEFAULT_ENDPOINT_REG, request.host) else True
 
 
 class TempCredentials(six_utils.get_abstract_meta_class()):
     @abstractmethod
     def _need_update_security_token(self):
+        # type: () -> bool
         pass
 
     @abstractmethod
     def update_security_token_from_metadata(self):
         pass
 
 
 class FederalCredentials(six_utils.get_abstract_meta_class()):
     @abstractmethod
     def _need_update_auth_token(self):
+        # type: () -> bool
         pass
 
     @abstractmethod
     def _update_auth_token_by_id_token(self, http_client):
         pass
 
 
 class Credentials(DerivedCredentials, TempCredentials, FederalCredentials):
     _TIME_FORMAT = "%Y-%m-%dT%H:%M:%S.%fZ"
     _X_SECURITY_TOKEN = "X-Security-Token"
     _X_AUTH_TOKEN = "X-Auth-Token"
+    _SIGNER_CASE = {
+        SigningAlgorithm.HMAC_SHA256: Signer,
+        SigningAlgorithm.HMAC_SM3: SM3Signer,
+        SigningAlgorithm.ECDSA_P256_SHA256: P256SHA256Signer,
+        SigningAlgorithm.SM2_SM3: SM2SM3Signer
+    }
 
     def __init__(self, ak=None, sk=None):
+        super(Credentials, self).__init__()
         self.ak = ak
         self.sk = sk
         self.idp_id = None
         self.id_token_file = None
         self.iam_endpoint = None
         self.security_token = None
         self._derived_auth_service_name = None
@@ -108,41 +123,45 @@
         return self
 
     def with_security_token(self, token):
         self.security_token = token
         return self
 
     def get_update_path_params(self):
+        # type: () -> dict
         pass
 
     def process_auth_params(self, http_client, region_id):
+        # type: (HttpClient, str) -> Credentials
         pass
 
     def process_auth_request(self, request, http_client):
         if self._need_update_auth_token():
             self._update_auth_token_by_id_token(http_client)
         elif self._need_update_security_token():
             self.update_security_token_from_metadata()
 
         return http_client.executor.submit(self.sign_request, request)
 
     def sign_request(self, request):
+        # type: (SdkRequest) -> SdkRequest
         if self._auth_token:
             request.header_params[self._X_AUTH_TOKEN] = self._auth_token
             Signer.process_request_uri(request)
             return request
         if self.security_token is not None:
             request.header_params["X-Security-Token"] = self.security_token
 
-        if "Content-Type" in request.header_params and not request.header_params["Content-Type"].startswith(
-                "application/json"):
-            request.header_params["X-Sdk-Content-Sha256"] = "UNSIGNED-PAYLOAD"
+        if self._is_derived_auth(request):
+            return DerivationAKSKSigner(self).sign(request, self._derived_auth_service_name, self._region_id)
 
-        return DerivationAKSKSigner(self).sign(request, self._derived_auth_service_name, self._region_id) \
-            if self._is_derived_auth(request) else Signer(self).sign(request)
+        signer_cls = self._SIGNER_CASE.get(request.signing_algorithm)
+        if not signer_cls:
+            raise SdkException("unsupported signing algorithm: " + str(request.signing_algorithm))
+        return signer_cls(self).sign(request)
 
     def _is_derived_auth(self, request):
         if not self._derived_predicate:
             return False
 
         return self._derived_predicate(request)
 
@@ -236,37 +255,41 @@
             return self
 
         derived_predicate = self._derived_predicate
         self._derived_predicate = None
 
         if self.iam_endpoint is None:
             self.iam_endpoint = Iam.get_iam_endpoint()
-        future_request = self.process_auth_request(
-            Iam.get_keystone_list_projects_request(self.iam_endpoint, region_id=region_id), http_client)
+        req = Iam.get_keystone_list_projects_request(http_client.config, self.iam_endpoint, region_id=region_id)
+        future_request = self.process_auth_request(req, http_client)
         request = future_request.result()
         try:
+            http_client.logger.info("project id of region '%s' not found in BasicCredentials, "
+                                    "trying to obtain project id from IAM service: %s", region_id, self.iam_endpoint)
             self.project_id = Iam.keystone_list_projects(http_client, request)
+            http_client.logger.info("success to obtain project id of region '%s': %s", region_id, self.project_id)
             AuthCache.put_auth(ak_with_name, self.project_id)
         except ServiceResponseException as e:
-            err_msg = e.error_msg if hasattr(e, "error_msg") else "unknown exception."
-            raise ApiValueError("Failed to get project id, " + err_msg)
+            err_msg = "failed to obtain project id, " \
+                      + (e.error_msg if hasattr(e, "error_msg") else "unknown exception.")
+            raise ApiValueError(err_msg)
 
         self._derived_predicate = derived_predicate
 
         return self
 
     def sign_request(self, request):
         if self.project_id:
             request.header_params[self._X_PROJECT_ID] = self.project_id
         return super(BasicCredentials, self).sign_request(request)
 
     def _update_auth_token_by_id_token(self, http_client):
         iam_endpoint = self.iam_endpoint if self.iam_endpoint else Iam.get_iam_endpoint()
-        request = Iam.get_create_token_by_id_token_request(iam_endpoint, self.idp_id, self._get_id_token(),
-                                                           project_id=self.project_id)
+        request = Iam.get_create_token_by_id_token_request(http_client.config, iam_endpoint, self.idp_id,
+                                                           self._get_id_token(), project_id=self.project_id)
         token, expired_str = Iam.create_token_by_id_token(http_client, request)
         self._expired_at = time_utils.get_timestamp_from_str(expired_str, self._TIME_FORMAT)
         self._auth_token = token
 
 
 class GlobalCredentials(Credentials):
     _X_DOMAIN_ID = "X-Domain-Id"
@@ -309,23 +332,27 @@
             return self
 
         derived_predicate = self._derived_predicate
         self._derived_predicate = None
 
         if self.iam_endpoint is None:
             self.iam_endpoint = Iam.get_iam_endpoint()
-        future_request = self.process_auth_request(Iam.get_keystone_list_auth_domains_request(self.iam_endpoint),
-                                                   http_client)
+        req = Iam.get_keystone_list_auth_domains_request(http_client.config, self.iam_endpoint)
+        future_request = self.process_auth_request(req, http_client)
         request = future_request.result()
         try:
+            http_client.logger.info('domain id not found in GlobalCredentials, '
+                                    'trying to obtain domain id from IAM service: %s', self.iam_endpoint)
             self.domain_id = Iam.keystone_list_auth_domains(http_client, request)
+            http_client.logger.info('success to obtain domain id: %s', self.domain_id)
             AuthCache.put_auth(self.ak, self.domain_id)
         except ServiceResponseException as e:
-            err_msg = e.error_msg if hasattr(e, "error_msg") else "unknown exception."
-            raise ApiValueError("Failed to get domain id, " + err_msg)
+            err_msg = "failed to obtain domain id, " \
+                      + (e.error_msg if hasattr(e, "error_msg") else "unknown exception.")
+            raise ApiValueError(err_msg)
 
         self._derived_predicate = derived_predicate
 
         return self
 
     def sign_request(self, request):
         if self.domain_id:
@@ -337,12 +364,12 @@
             self._derived_auth_service_name = derived_auth_service_name
 
         if not self._region_id:
             self._region_id = "globe"
 
     def _update_auth_token_by_id_token(self, http_client):
         iam_endpoint = self.iam_endpoint if self.iam_endpoint else Iam.get_iam_endpoint()
-        request = Iam.get_create_token_by_id_token_request(iam_endpoint, self.idp_id, self._get_id_token(),
-                                                           domain_id=self.domain_id)
+        request = Iam.get_create_token_by_id_token_request(http_client.config, iam_endpoint, self.idp_id,
+                                                           self._get_id_token(), domain_id=self.domain_id)
         token, expired_str = Iam.create_token_by_id_token(http_client, request)
         self._expired_at = time_utils.get_timestamp_from_str(expired_str, self._TIME_FORMAT)
         self._auth_token = token
```

## huaweicloudsdkcore/auth/internal.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2022 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -14,23 +16,35 @@
  software distributed under the LICENSE is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
-import os
 import json
-import six
+import os
+
 import requests
 from requests.exceptions import HTTPError
+from six.moves.urllib.parse import urlparse
 from urllib3.exceptions import SSLError, NewConnectionError
+
+from huaweicloudsdkcore.utils.six_utils import JSON_DECODE_ERROR
 from huaweicloudsdkcore.exceptions import exceptions
 from huaweicloudsdkcore.sdk_request import SdkRequest
-from six.moves.urllib.parse import urlparse
+
+_NO_DOMAIN_ID_ERR_MSG = '''no domain id found, please select one of the following solutions:
+  1. Manually specify domain_id when initializing the credentials, credentials = GlobalCredentials(ak, sk, domain_id)
+  2. Use the domain account to grant IAM read permission to the current account
+  3. Replace the ak/sk of the IAM account with the ak/sk of the domain account'''
+
+_NO_PROJECT_ID_ERR_MSG = '''no project id found, please select one of the following solutions:
+  1. Manually specify project_id when initializing the credentials, credentials = BasicCredentials(ak, sk, project_id)
+  2. Use the domain account to grant IAM read permission to the current account
+  3. Replace the ak/sk of the IAM account with the ak/sk of the domain account'''
 
 
 class Metadata(object):
     TIME_OUT = 3
     URL = "http://169.254.169.254/openstack/latest/securitykey"
 
     @classmethod
@@ -51,45 +65,50 @@
 
         if not resp or not resp.content:
             raise exceptions.ApiValueError("failed to get credential from metadata, metadata is empty")
 
         try:
             credential = json.loads(resp.content).get("credential")
             return credential
-        except json.decoder.JSONDecodeError as decode_err:
+        except JSON_DECODE_ERROR as decode_err:
             raise exceptions.ApiValueError("failed to get credential from metadata: {}".format(decode_err))
 
 
 class Iam(object):
     DEFAULT_ENDPOINT = "https://iam.myhuaweicloud.com"
     KEYSTONE_LIST_PROJECT_URI = "/v3/projects"
     KEYSTONE_LIST_AUTH_DOMAINS_URI = "/v3/auth/domains"
     CREATE_TOKEN_BY_ID_TOKEN_URI = "/v3.0/OS-AUTH/id-token/tokens"
     IAM_ENDPOINT_ENV_NAME = "HUAWEICLOUD_SDK_IAM_ENDPOINT"
 
     @classmethod
     def get_iam_endpoint(cls):
-        iam_endpoint = os.environ.get(cls.IAM_ENDPOINT_ENV_NAME)
-        return iam_endpoint if iam_endpoint else cls.DEFAULT_ENDPOINT
+        return os.environ.get(cls.IAM_ENDPOINT_ENV_NAME, cls.DEFAULT_ENDPOINT)
 
     @classmethod
-    def get_keystone_list_projects_request(cls, iam_endpoint=None, region_id=None):
+    def get_keystone_list_projects_request(cls, config, iam_endpoint=None, region_id=None):
         url_parse_result = urlparse(iam_endpoint)
         schema = url_parse_result.scheme
         host = url_parse_result.netloc
         resource_path = cls.KEYSTONE_LIST_PROJECT_URI
         query_params = [('name', region_id)]
 
-        sdk_request = SdkRequest(method="GET", schema=schema, host=host, resource_path=resource_path, header_params={},
-                                 query_params=query_params, body="")
+        sdk_request = SdkRequest(method="GET",
+                                 schema=schema,
+                                 host=host,
+                                 resource_path=resource_path,
+                                 header_params={"User-Agent": "huaweicloud-usdk-python/3.0"},
+                                 query_params=query_params,
+                                 body="",
+                                 signing_algorithm=config.signing_algorithm)
 
         return sdk_request
 
     @staticmethod
-    def get_create_token_by_id_token_request(iam_endpoint, idp_id, id_token, project_id=None, domain_id=None):
+    def get_create_token_by_id_token_request(config, iam_endpoint, idp_id, id_token, project_id=None, domain_id=None):
         scope, _id = ("project", project_id) if project_id else ("domain", domain_id)
         request_body = {
             "auth": {
                 "id_token": {
                     "id": id_token
                 },
                 "scope": {
@@ -99,17 +118,26 @@
                 }
             }
         }
         url_parse_result = urlparse(iam_endpoint)
         schema = url_parse_result.scheme
         host = url_parse_result.netloc
         resource_path = Iam.CREATE_TOKEN_BY_ID_TOKEN_URI
-        header_params = {"X-Idp-Id": idp_id, "Content-Type": "application/json;charset=UTF-8"}
-        return SdkRequest(method="POST", schema=schema, host=host, resource_path=resource_path, uri=resource_path,
-                          header_params=header_params, query_params=[], body=json.dumps(request_body), stream=False)
+        header_params = {"X-Idp-Id": idp_id,
+                         "Content-Type": "application/json;charset=UTF-8", "User-Agent": "huaweicloud-usdk-python/3.0"}
+        return SdkRequest(method="POST",
+                          schema=schema,
+                          host=host,
+                          resource_path=resource_path,
+                          uri=resource_path,
+                          header_params=header_params,
+                          query_params=[],
+                          body=json.dumps(request_body),
+                          stream=False,
+                          signing_algorithm=config.signing_algorithm)
 
     @classmethod
     def create_token_by_id_token(cls, http_client, request):
         resp = http_client.do_request_sync(request)
         if not resp or not resp.content or "X-Subject-Token" not in resp.headers:
             raise exceptions.ApiValueError("failed to get token by id_token")
 
@@ -119,57 +147,60 @@
 
     @classmethod
     def keystone_list_projects(cls, http_client, request):
         try:
             http_response = http_client.do_request_sync(request)
         except exceptions.ServiceResponseException as e:
             raise e
-        if http_response and hasattr(http_response, "content"):
-            content = getattr(http_response, "content")
-            response = json.loads(six.ensure_str(content))
-            if "projects" in response and len(response["projects"]) == 1:
-                return response["projects"][0]["id"]
-            elif "projects" in response and len(response["projects"]) > 1:
-                raise exceptions.ApiValueError("Multiple project ids have been returned, \
-                     please specify one when initializing the credentials.")
-            else:
-                raise exceptions.ApiValueError("No project id found, "
-                                               "please specify project_id manually when initializing the credentials.")
-        else:
-            raise exceptions.ApiValueError("No project id found, "
-                                           "please specify project_id manually when initializing the credentials.")
+
+        if not hasattr(http_response, "content"):
+            raise exceptions.ApiValueError(_NO_PROJECT_ID_ERR_MSG)
+
+        content = json.loads(http_response.content)
+        projects = content.get("projects")
+        if not projects:
+            raise exceptions.ApiValueError("Result projects is null. " + _NO_PROJECT_ID_ERR_MSG)
+        if len(projects) > 1:
+            project_ids = ",".join((project.get("id") for project in projects))
+            raise exceptions.ApiValueError("multiple project ids found: [%s], "
+                                           "please specify one when initializing the credentials, "
+                                           "credentials = BasicCredentials(ak, sk, project_id)" % project_ids)
+        return projects[0]["id"]
 
     @classmethod
-    def get_keystone_list_auth_domains_request(cls, iam_endpoint=None):
+    def get_keystone_list_auth_domains_request(cls, config, iam_endpoint=None):
         url_parse_result = urlparse(iam_endpoint)
         schema = url_parse_result.scheme
         host = url_parse_result.netloc
         resource_path = cls.KEYSTONE_LIST_AUTH_DOMAINS_URI
 
-        sdk_request = SdkRequest(method="GET", schema=schema, host=host, resource_path=resource_path, header_params={},
-                                 query_params=[], body="")
+        sdk_request = SdkRequest(method="GET",
+                                 schema=schema,
+                                 host=host,
+                                 resource_path=resource_path,
+                                 header_params={"User-Agent": "huaweicloud-usdk-python/3.0"},
+                                 query_params=[],
+                                 body="",
+                                 signing_algorithm=config.signing_algorithm)
 
         return sdk_request
 
     @classmethod
     def keystone_list_auth_domains(cls, http_client, request):
         try:
             http_response = http_client.do_request_sync(request)
         except exceptions.ServiceResponseException as e:
             raise e
-        if http_response and hasattr(http_response, "content"):
-            content = getattr(http_response, "content")
-            response = json.loads(six.ensure_str(content))
-            if "domains" in response and len(response["domains"]) == 1:
-                return response["domains"][0]["id"]
-            else:
-                raise exceptions.ApiValueError("No domain id found, please select one of the following solutions:\n\t"
-                                               "1. Manually specify domain_id when initializing the credentials.\n\t"
-                                               "2. Use the domain account to grant the current account permissions "
-                                               "of the IAM service.\n\t"
-                                               "3. Use AK/SK of the domain account.")
-        else:
-            raise exceptions.ApiValueError("No domain id found, please select one of the following solutions:\n\t"
-                                           "1. Manually specify domain_id when initializing the credentials.\n\t"
-                                           "2. Use the domain account to grant the current account permissions of "
-                                           "the IAM service.\n\t "
-                                           "3. Use AK/SK of the domain account.")
+
+        if not hasattr(http_response, "content"):
+            raise exceptions.ApiValueError(_NO_DOMAIN_ID_ERR_MSG)
+
+        content = json.loads(http_response.content)
+        domains = content.get("domains")
+        if not domains:
+            raise exceptions.ApiValueError("result domains is null. " + _NO_DOMAIN_ID_ERR_MSG)
+        if len(domains) > 1:
+            domain_ids = ",".join((domain.get("id") for domain in domains))
+            raise exceptions.ApiValueError("multiple domain ids found: [%s], "
+                                           "please specify one when initializing the credentials, "
+                                           "credentials = GlobalCredentials(ak, sk, domain_id)" % domain_ids)
+        return domains[0]["id"]
```

## huaweicloudsdkcore/auth/provider.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2022 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -16,15 +18,15 @@
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 import os
 import six
 from abc import abstractmethod
-from huaweicloudsdkcore.utils import six_utils, path_utils
+from huaweicloudsdkcore.utils import six_utils, filepath_utils
 from huaweicloudsdkcore.auth.credentials import BasicCredentials, GlobalCredentials
 from huaweicloudsdkcore.exceptions.exceptions import ApiTypeError, ApiValueError, SdkException
 
 
 class _CredentialType:
     BASIC = "basic"
     GLOBAL = "global"
@@ -110,19 +112,19 @@
             import configparser
             parser = configparser.ConfigParser()
         else:
             from backports import configparser
             parser = configparser.SafeConfigParser()
 
         path = self._get_credentials_file_path()
-        if not path_utils.is_path_exist(path) or not parser.read(path, encoding=self._ENCODING):
-            raise ApiValueError("credentials file '{}' does not exist".format(path))
+        if not filepath_utils.is_path_exist(path) or not parser.read(path, encoding=self._ENCODING):
+            raise ApiValueError("credentials file '%s' does not exist" % path)
 
         if not parser.has_section(self._credential_type):
-            raise ApiValueError("credential type '{}' does not exist in credentials file '{}'".format(
+            raise ApiValueError("credential type '%s' does not exist in credentials file '%s'" % (
                 self._credential_type, path))
 
         profile_dict = {}
         for item in parser.items(self._credential_type):
             profile_dict[item[0]] = item[1]
 
         ak = profile_dict.get(self._AK_NAME)
@@ -133,35 +135,35 @@
         iam_endpoint = profile_dict.get(self._IAM_ENDPOINT_NAME)
 
         if self._credential_type.startswith(_CredentialType.BASIC):
             credentials = BasicCredentials().with_project_id(profile_dict.get(self._PROJECT_ID_NAME))
         elif self._credential_type.startswith(_CredentialType.GLOBAL):
             credentials = GlobalCredentials().with_domain_id(profile_dict.get(self._DOMAIN_ID_NAME))
         else:
-            raise ApiTypeError("unsupported credential type '{}'".format(self._credential_type))
+            raise ApiTypeError("unsupported credential type '%s'" % self._credential_type)
 
         if idp_id and id_token_file:
             credentials.with_idp_id(idp_id).with_id_token_file(id_token_file)
         elif ak and sk:
             credentials.with_ak(ak).with_sk(sk).with_security_token(security_token)
         else:
-            raise ApiValueError("{}&{} or {}&{} does not exist in credentials file '{}'".format(
+            raise ApiValueError("%s&%s or %s&%s does not exist in credentials file '%s'" % (
                 self._AK_NAME, self._SK_NAME, self._AK_NAME, self._SK_NAME, path))
         if iam_endpoint:
             credentials.with_iam_endpoint(iam_endpoint)
 
         return credentials
 
     @classmethod
     def _get_credentials_file_path(cls):
         credentials_file = os.getenv(cls._CREDENTIALS_FILE_ENV_NAME)
         if credentials_file:
             return credentials_file
 
-        home_path = path_utils.get_home_path()
+        home_path = filepath_utils.get_home_path()
         return os.path.join(home_path, cls._DEFAULT_CREDENTIALS_FILE_DIR, cls._DEFAULT_CREDENTIALS_FILE_NAME
                             ) if home_path else home_path
 
 
 class MetadataCredentialProvider(CredentialProvider):
     @staticmethod
     def get_basic_credential_metadata_provider():
```

## huaweicloudsdkcore/exceptions/exceptions.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -18,55 +20,112 @@
  under the LICENSE.
 """
 
 import six
 
 
 class SdkException(Exception):
-    def __init__(self):
+    def __init__(self, error_msg):
         """
         The base exception class.
         """
-        pass
+        super(SdkException, self).__init__()
+        self.error_msg = error_msg
+
+    def __str__(self):
+        return "%s - %s" % (self.__class__.__name__, self.error_msg)
 
 
 class ConnectionException(SdkException):
-    def __init__(self, err_message):
+    def __init__(self, error_msg):
         """
         The base exception class of connection exceptions.
         """
-        super(ConnectionException, self).__init__()
-        self.err_message = err_message
-
-    def __str__(self):
-        return "ConnectionException - %s" % self.err_message
+        super(ConnectionException, self).__init__(error_msg)
 
 
 class HostUnreachableException(ConnectionException):
-    def __init__(self, err_message):
+    def __init__(self, error_msg):
         """
         Host Unreachable Exception
         """
-        super(HostUnreachableException, self).__init__(err_message)
-        self.err_message = err_message
-
-    def __str__(self):
-        return "HostUnreachableException - %s" % self.err_message
+        super(HostUnreachableException, self).__init__(error_msg)
 
 
 class SslHandShakeException(ConnectionException):
-    def __init__(self, err_message):
+    def __init__(self, error_msg):
         """
         Ssl HandShake Exception
         """
-        super(SslHandShakeException, self).__init__(err_message)
-        self.err_message = err_message
+        super(SslHandShakeException, self).__init__(error_msg)
+
+
+class ServiceResponseException(SdkException):
+    def __init__(self, status_code, sdk_error):
+        """
+        The base exception class of service response exceptions.
+        """
+        super(ServiceResponseException, self).__init__(sdk_error.error_msg)
+        self.status_code = status_code
+        self.error_code = sdk_error.error_code
+        self.request_id = sdk_error.request_id
+        self.encoded_auth_msg = sdk_error.encoded_auth_msg
 
     def __str__(self):
-        return "SslHandShakeException - %s" % self.err_message
+        return "%s - {status_code:%s,request_id:%s,error_code:%s,error_msg:%s,encoded_authorization_message:%s }" % (
+            self.__class__.__name__, self.status_code, self.request_id, self.error_code, self.error_msg,
+            self.encoded_auth_msg)
+
+
+class ClientRequestException(ServiceResponseException):
+    def __init__(self, status_code, sdk_error):
+        """
+        Client Request Exception
+        """
+        super(ClientRequestException, self).__init__(status_code, sdk_error)
+
+
+class ServerResponseException(ServiceResponseException):
+    def __init__(self, status_code, sdk_error):
+        """
+        Server Response Exception
+        """
+        super(ServerResponseException, self).__init__(status_code, sdk_error)
+
+
+class RequestTimeoutException(SdkException):
+    def __init__(self, error_msg):
+        """
+        The base exception class of timeout exceptions.
+        """
+        super(RequestTimeoutException, self).__init__(error_msg)
+
+
+class CallTimeoutException(RequestTimeoutException):
+    def __init__(self, error_msg):
+        """
+        Call Timeout Exception
+        """
+        super(CallTimeoutException, self).__init__(error_msg)
+
+
+class RetryOutageException(RequestTimeoutException):
+    def __init__(self, error_msg):
+        """
+        Retry Outage Exception
+        """
+        super(RetryOutageException, self).__init__(error_msg)
+
+
+class SdkError(object):
+    def __init__(self, request_id=None, error_code=None, error_msg=None, encoded_auth_msg=None):
+        self.error_msg = error_msg
+        self.error_code = error_code
+        self.request_id = request_id
+        self.encoded_auth_msg = encoded_auth_msg
 
 
 def render_path(path_to_item):
     """Returns a string representation of a path"""
     result = ""
     for pth in path_to_item:
         if isinstance(pth, six.integer_types):
@@ -97,15 +156,15 @@
                              None if unset
         """
         self.path_to_item = path_to_item
         self.valid_classes = valid_classes
         self.key_type = key_type
         full_msg = msg
         if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
+            full_msg = "%s at %s" % (msg, render_path(path_to_item))
         super(ApiTypeError, self).__init__(full_msg)
 
 
 class ApiValueError(ValueError):
     def __init__(self, msg, path_to_item=None):
         """
         Args:
@@ -115,15 +174,15 @@
             path_to_item (list) the path to the exception in the
                 received_data dict. None if unset
         """
 
         self.path_to_item = path_to_item
         full_msg = msg
         if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
+            full_msg = "%s at %s" % (msg, render_path(path_to_item))
         super(ApiValueError, self).__init__(full_msg)
 
 
 class ApiKeyError(KeyError):
     def __init__(self, msg, path_to_item=None):
         """
         Args:
@@ -132,99 +191,9 @@
         Keyword Args:
             path_to_item (None/list) the path to the exception in the
                 received_data dict
         """
         self.path_to_item = path_to_item
         full_msg = msg
         if path_to_item:
-            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
+            full_msg = "%s at %s" % (msg, render_path(path_to_item))
         super(ApiKeyError, self).__init__(full_msg)
-
-
-class ServiceResponseException(SdkException):
-    def __init__(self, status_code, sdk_error):
-        """
-        The base exception class of service response exceptions.
-        """
-        self.status_code = status_code
-        self.error_msg = sdk_error.error_msg
-        self.error_code = sdk_error.error_code
-        self.request_id = sdk_error.request_id
-
-    def __str__(self):
-        return "ServiceResponseException - {status_code:%s,request_id:%s,error_code:%s,error_msg:%s }" % (
-            self.status_code, self.request_id, self.error_code, self.error_msg)
-
-
-class ClientRequestException(ServiceResponseException):
-    def __init__(self, status_code, sdk_error):
-        """
-        Client Request Exception
-        """
-        super(ClientRequestException, self).__init__(status_code, sdk_error)
-        self.status_code = status_code
-        self.error_msg = sdk_error.error_msg
-        self.error_code = sdk_error.error_code
-        self.request_id = sdk_error.request_id
-
-    def __str__(self):
-        return "ClientRequestException - {status_code:%s,request_id:%s,error_code:%s,error_msg:%s }" % (
-            self.status_code, self.request_id, self.error_code, self.error_msg)
-
-
-class ServerResponseException(ServiceResponseException):
-    def __init__(self, status_code, sdk_error):
-        """
-        Server Response Exception
-        """
-        super(ServerResponseException, self).__init__(status_code, sdk_error)
-        self.status_code = status_code
-        self.error_msg = sdk_error.error_msg
-        self.error_code = sdk_error.error_code
-        self.request_id = sdk_error.request_id
-
-    def __str__(self):
-        return "ServerResponseException - {status_code:%s,request_id:%s,error_code:%s,error_msg:%s }" % (
-            self.status_code, self.request_id, self.error_code, self.error_msg)
-
-
-class RequestTimeoutException(SdkException):
-    def __init__(self, err_message):
-        """
-        The base exception class of timeout exceptions.
-        """
-        super(self)
-        self.err_message = err_message
-
-    def __str__(self):
-        return "RequestTimeoutException - %s" % self.err_message
-
-
-class CallTimeoutException(RequestTimeoutException):
-    def __init__(self, err_message):
-        """
-        Call Timeout Exception
-        """
-        super(CallTimeoutException, self).__init__(err_message)
-        self.err_message = err_message
-
-    def __str__(self):
-        return "CallTimeoutException - %s" % self.err_message
-
-
-class RetryOutageException(RequestTimeoutException):
-    def __init__(self, err_message):
-        """
-        Retry Outage Exception
-        """
-        super(RetryOutageException, self).__init__(err_message)
-        self.err_message = err_message
-
-    def __str__(self):
-        return "RetryOutageException - %s" % self.err_message
-
-
-class SdkError(object):
-    def __init__(self, request_id=None, error_code=None, error_msg=None):
-        self.error_msg = error_msg
-        self.error_code = error_code
-        self.request_id = request_id
```

## huaweicloudsdkcore/http/formdata.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2021 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -13,55 +15,58 @@
  Unless required by applicable law or agreed to in writing,
  software distributed under the LICENSE is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
-
 import os
 from mimetypes import MimeTypes
+from huaweicloudsdkcore.utils.filepath_utils import ensure_file_in_rb_mode
 
 
 class FormFile(object):
     TYPE = "file"
 
-    def __init__(self, f):
+    def __init__(self, f, content_type=None):
         """This class is used for the formdata.
 
-        :param f: An opened file, for example, f = open("demo.txt", "r")
-        :type f: stream
+        :param f: An opened file or file path, for example, f = open("demo.txt", "rb") or f = "/tmp/log.txt"
+        :type f: stream or str
+        :param content_type: the content type of the file
+        :type content_type: str
         """
-        self._file = f
+        self._file = ensure_file_in_rb_mode(f)
+        self._content_type = content_type
 
     def close(self):
-        self._file.close()
+        if hasattr(self._file, "closed") and not self._file.closed:
+            self._file.close()
 
-    def get_path(self):
+    @property
+    def path(self):
         return self._file.name
 
-    def get_abs_path(self):
-        return os.path.abspath(self.get_path())
-
-    def get_file_name(self):
-        file_name = self._file.name
-        if "\\" in file_name:
-            return file_name.split("\\")[-1]
-        elif "/" in file_name:
-            return file_name.split("/")[-1]
+    @property
+    def abs_path(self):
+        return os.path.abspath(self.path)
+
+    @property
+    def name(self):
+        name = self._file.name
+        if "\\" in name:
+            return name.split("\\")[-1]
+        elif "/" in name:
+            return name.split("/")[-1]
         else:
-            return file_name
+            return name
+
+    @property
+    def content_type(self):
+        mime_type = MimeTypes().guess_type(self.abs_path)
+        return mime_type[0]
 
     def convert_to_file_tuple(self):
-        mime_type = MimeTypes().guess_type(self.get_abs_path())
-        file_name = self.get_file_name()
-        return (file_name, self._file, mime_type[0]) if mime_type[0] else (file_name, self._file)
+        return (self.name, self._file, str(self._content_type)) if self._content_type else (self.name, self._file)
 
     def __del__(self):
         self.close()
-
-
-
-
-
-
-
```

## huaweicloudsdkcore/http/http_client.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -14,40 +16,35 @@
  software distributed under the LICENSE is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
-import json
+from concurrent.futures import ThreadPoolExecutor
 
-import six
 import requests
 from requests import HTTPError, Timeout, TooManyRedirects
 from requests.adapters import HTTPAdapter
 from requests.exceptions import ConnectionError
 from requests.packages.urllib3.util import Retry
-from requests_futures.sessions import FuturesSession
-from urllib3.exceptions import SSLError, NewConnectionError
-from concurrent.futures import ThreadPoolExecutor
 
 from huaweicloudsdkcore.exceptions import exceptions
+from huaweicloudsdkcore.exceptions.exception_handler import process_connection_error
+from huaweicloudsdkcore.http.future_session import FutureSession
 
 
 class HttpClient(object):
     def __init__(self, config, http_handler, exception_handler, logger):
         self._logger = logger
         self._exception_handler = exception_handler
         self._http_handler = http_handler
-
-        self._timeout = config.timeout
+        self._config = config
         self._proxy = config.get_proxy()
-        self._retry_times = config.retry_times
-        self._pool_connections = config.pool_connections
-        self._pool_maxsize = config.pool_maxsize
+
         if config.ssl_ca_cert is not None:
             self._verify = config.ssl_ca_cert if not config.ignore_ssl_verification else config.ignore_ssl_verification
         else:
             self._verify = not config.ignore_ssl_verification
         if config.cert_file is not None and config.key_file is not None:
             self._cert = (config.cert_file, config.key_file)
         else:
@@ -56,124 +53,82 @@
         self._retry_status_list = [429]
         self._session = self._init_session()
 
         self._executor = ThreadPoolExecutor(max_workers=8)
 
     def _init_session(self):
         sdk_session = requests.Session()
-        sdk_adapter = HTTPAdapter(pool_connections=self._pool_connections, pool_maxsize=self._pool_maxsize,
-                                  max_retries=Retry(total=self._retry_times, status_forcelist=self._retry_status_list))
+        retry = Retry(total=self._config.retry_times, status_forcelist=self._retry_status_list)
+        sdk_adapter = HTTPAdapter(pool_connections=self._config.pool_connections,
+                                  pool_maxsize=self._config.pool_maxsize, max_retries=retry)
         sdk_session.mount('https://', sdk_adapter)
         sdk_session.mount('http://', sdk_adapter)
         return sdk_session
 
     @property
     def executor(self):
         return self._executor
 
+    @property
+    def config(self):
+        return self._config
+
+    @property
+    def logger(self):
+        return self._logger
+
     def do_request_sync(self, request):
-        fun = getattr(self._session, request.method.lower())
+        invoke = getattr(self._session, request.method.lower())
 
         try:
             if self._http_handler is not None:
                 self._http_handler.process_request(request=request, logger=self._logger)
-            response = fun(
-                "%s://%s%s" % (request.schema, request.host, request.uri),
-                timeout=self._timeout,
+            response = invoke(
+                request.url,
+                timeout=self._config.timeout,
                 headers=request.header_params,
                 proxies=self._proxy,
                 verify=self._verify,
                 cert=self._cert,
                 data=request.body,
-                stream=request.stream
+                stream=request.stream,
+                allow_redirects=self._config.allow_redirects
             )
-        except ConnectionError as connectionError:
-            for each in connectionError.args:
-                if isinstance(each.reason, SSLError):
-                    self._logger.error("SslHandShakeException occurred. %s" % str(each.reason))
-                    raise exceptions.SslHandShakeException(str(each.reason))
-                if isinstance(each.reason, NewConnectionError):
-                    self._logger.error("ConnectionException occurred. %s" % str(each.reason))
-                    raise exceptions.ConnectionException(str(each.reason))
-            self._logger.error("ConnectionException occurred. %s" % str(connectionError))
-            raise exceptions.ConnectionException(str(connectionError))
+        except ConnectionError as conn_err:
+            raise process_connection_error(conn_err, self._logger)
 
         self.response_error_hook_factory()(response)
         return response
 
     def do_request_async(self, request, hooks):
-        fun = getattr(FuturesSession(session=self._session), request.method.lower())
+        fun = getattr(FutureSession(self._session, self._executor), request.method.lower())
         hooks.append(self.response_error_hook_factory())
 
         future = fun(
-            "%s://%s%s" % (request.schema, request.host, request.uri),
-            timeout=self._timeout,
+            request.url,
+            timeout=self._config.timeout,
             headers=request.header_params,
             proxies=self._proxy,
             verify=self._verify,
             cert=self._cert,
             data=request.body,
             stream=request.stream,
+            allow_redirects=self._config.allow_redirects,
             hooks={'response': hooks}
         )
         return future
 
     def response_error_hook_factory(self):
         def response_hook(resp, *args, **kwargs):
             if self._http_handler is not None:
                 self._http_handler.process_response(response=resp, logger=self._logger)
 
             try:
                 resp.raise_for_status()
             except HTTPError as httpError:
-                response_status_code = httpError.response.status_code
-                response_header_params = httpError.response.headers
-                if "X-Request-Id" in response_header_params:
-                    request_id = response_header_params["X-Request-Id"]
-                else:
-                    request_id = ""
-                response_body = httpError.response.text
-                sdk_error = self.get_sdk_error_from_response(request_id, response_body, response_status_code)
-                if 400 <= response_status_code < 500:
-                    raise exceptions.ClientRequestException(response_status_code, sdk_error)
-                else:
-                    raise exceptions.ServerResponseException(response_status_code, sdk_error)
+                self._exception_handler.handle_exception(httpError.request, httpError.response)
             except Timeout as timeout:
                 raise exceptions.CallTimeoutException(str(timeout))
             except TooManyRedirects as tooManyRedirects:
                 raise exceptions.RetryOutageException(str(tooManyRedirects))
 
         return response_hook
-
-    def get_sdk_error_from_response(self, request_id, response_body, response_status_code):
-        sdk_error = exceptions.SdkError()
-
-        try:
-            sdk_error_dict = json.loads(six.ensure_str(response_body))
-            if "error_code" in sdk_error_dict and "error_msg" in sdk_error_dict:
-                sdk_error = exceptions.SdkError(request_id, sdk_error_dict["error_code"],
-                                                sdk_error_dict["error_msg"])
-            elif "code" in sdk_error_dict and "message" in sdk_error_dict:
-                sdk_error = exceptions.SdkError(request_id, sdk_error_dict["code"],
-                                                sdk_error_dict["message"])
-            else:
-                for key in sdk_error_dict:
-                    if type(sdk_error_dict[key]) == dict and "error_code" in sdk_error_dict[key] \
-                            and "error_msg" in sdk_error_dict[key]:
-                        sdk_error = exceptions.SdkError(request_id, sdk_error_dict[key]["error_code"],
-                                                        sdk_error_dict[key]["error_msg"])
-                    if type(sdk_error_dict[key]) == dict and "code" in sdk_error_dict[key] and "message" in \
-                            sdk_error_dict[key]:
-                        sdk_error = exceptions.SdkError(request_id, sdk_error_dict[key]["code"],
-                                                        sdk_error_dict[key]["message"])
-        except Exception:
-            raise exceptions.ServerResponseException(response_status_code,
-                                                     exceptions.SdkError(error_msg=str(response_body)))
-
-        if sdk_error.error_msg is None or sdk_error.error_msg == "":
-            if self._exception_handler is not None:
-                sdk_error = self._exception_handler(response_body)
-        if sdk_error.error_msg is None or sdk_error.error_msg == "":
-            sdk_error = exceptions.SdkError(error_msg=response_body)
-
-        sdk_error.request_id = request_id
-        return sdk_error
```

## huaweicloudsdkcore/http/http_config.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -16,33 +18,36 @@
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
 import six
 
+from huaweicloudsdkcore.signer.algorithm import SigningAlgorithm
+
 
 class HttpConfig(object):
     def __init__(self, proxy_protocol=None, proxy_host=None, proxy_port=None, proxy_user=None, proxy_password=None,
                  ignore_ssl_verification=False, ssl_ca_cert=None, cert_file=None, key_file=None, timeout=(60, 120),
-                 retry_times=0, pool_connections=1, pool_maxsize=1):
+                 retry_times=0, pool_connections=10, pool_maxsize=10, allow_redirects=False,
+                 ignore_content_type_for_get_request=False, signing_algorithm=SigningAlgorithm.get_default()):
         """
         :param proxy_protocol(optional) : proxy protocol, http or https
         :type proxy_protocol: str
 
         :param proxy_host(optional) : hostname or ip address of proxy server
         :type proxy_host: str
 
         :param proxy_port(optional) : port of proxy server
         :type proxy_port: str
 
-        :param proxy_user(optional) : user name used for proxy authentication
+        :param proxy_user(optional) : username used for proxy authentication
         :type proxy_user: str
 
-        :param proxy_password(optional) : user name used for proxy authentication
+        :param proxy_password(optional) : username used for proxy authentication
         :type proxy_password: str
 
         :param ignore_ssl_verification: whether skip SSL certificate validation while sending https request,
          default, value is False
         :type ignore_ssl_verification: bool
 
         :param ssl_ca_cert: (optional) a path to a CA bundle to use
@@ -59,41 +64,57 @@
         :type timeout: float or tuple
 
         :param retry_times: maximum number of retries each connection should attempt,
          default, does not retry failed connections.
         :type retry_times: int
 
         :param pool_connections: number of urllib3 connection pools to cache,
-         default, value is 1
+         default, value is 10
         :type pool_connections: int
 
         :param pool_maxsize: maximum number of connections to save in the pool
-         default, value is 1
+         default, value is 10
         :type pool_maxsize: int
+
+        :param allow_redirects: Experimental configuration.
+         Automatic redirection is allowed when turns on, which may cause some request exceptions.
+         default, value is False
+        :type allow_redirects: bool
+
+        :param ignore_content_type_for_get_request: Ignore the request header Content-Type when sending a GET request,
+         default, value is False
+        :type ignore_ssl_verification: bool
+
+        :param signing_algorithm: signing algorithm of request
+         default, value is HMAC_SHA256
+        :type signing_algorithm: SigningAlgorithm
         """
         self.proxy_protocol = proxy_protocol
         self.proxy_host = proxy_host
         self.proxy_port = proxy_port
         self.proxy_user = proxy_user
         self.proxy_password = proxy_password
 
         self.ignore_ssl_verification = ignore_ssl_verification
+        self.allow_redirects = allow_redirects
 
         self.ssl_ca_cert = ssl_ca_cert
         self.cert_file = cert_file
         self.key_file = key_file
 
         self.timeout = timeout
         self.retry_times = retry_times
         self.pool_connections = pool_connections
         self.pool_maxsize = pool_maxsize
+        self.ignore_content_type_for_get_request = ignore_content_type_for_get_request
+        self.signing_algorithm = signing_algorithm
 
     def get_proxy(self):
         if self.proxy_host is None:
-            return None
+            return {}
 
         if six.PY2:
             from urllib import quote_plus
         else:
             from urllib.parse import quote_plus
 
         return {
```

## huaweicloudsdkcore/http/http_handler.py

```diff
@@ -1,9 +1,10 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -21,17 +22,25 @@
 
 def default_request_handler(**kwargs):
     pass
 
 
 def default_response_handler(**kwargs):
     _response = kwargs.get("response")
+
+    content_type = _response.headers.get("Content-Type")
+    content_length = _response.headers.get("Content-Length")
+    if content_type and content_type.endswith("octet-stream"):
+        content_length = content_length if content_length else -1
+    else:
+        content_length = content_length if content_length else len(_response.content)
+
     kwargs.get("logger").info("\"{} {}\" {} {} {} {}".format(
         _response.request.method,
-        _response.request.url, _response.status_code, len(_response.content),
+        _response.request.url, _response.status_code, content_length,
         _response.elapsed, _response.headers.get("X-Request-Id") if "X-Request-Id" in _response.headers else "")
     )
 
 
 class HttpHandler(object):
     def __init__(self):
         self._request_handlers = [default_request_handler]
```

## huaweicloudsdkcore/http/primitive_types.py

```diff
@@ -1,9 +1,10 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -19,17 +20,17 @@
 """
 
 import datetime
 import decimal
 
 import six
 
-primitive_types = (float, bool, bytes, six.text_type) + six.integer_types
+PRIMITIVE_TYPES = (float, bool, bytes, six.text_type) + six.integer_types
 
-native_types_mapping = {
+NATIVE_TYPES_MAPPING = {
     'int': int,
     'long': int if six.PY3 else long,
     'float': float,
     'str': str,
     'bool': bool,
     'date': datetime.date,
     'datetime': datetime.datetime,
```

## huaweicloudsdkcore/region/cache.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2022 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -15,19 +17,18 @@
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
 import os
-import sys
 import yaml
 
 from huaweicloudsdkcore.region.region import Region
-from huaweicloudsdkcore.utils import six_utils, path_utils
+from huaweicloudsdkcore.utils import six_utils, filepath_utils
 
 
 class EnvRegionCache(six_utils.get_singleton_meta_class()):
     def __init__(self):
         self._value = {}
 
     def set(self, name, region):
@@ -49,32 +50,40 @@
         return self._value.get(name)
 
     @classmethod
     def _resolve_profile(cls):
         result = {}
 
         path = cls._get_regions_file_path()
-        if not path_utils.is_path_exist(path):
+        if not filepath_utils.is_path_exist(path):
             return result
 
         with open(path, "r") as f:
             _dict = yaml.safe_load(f)
 
         for service, regions in _dict.items():
             for region in regions:
                 _id = region.get("id")
-                endpoint = region.get("endpoint")
-                if not _id or not endpoint:
+                if not _id:
                     continue
-                result[service.upper() + _id] = Region(_id, endpoint)
+
+                endpoints = region.get("endpoints")
+                if not endpoints:
+                    endpoints = []
+                endpoint = region.get("endpoint")
+                if endpoint:
+                    endpoints.append(endpoint)
+
+                if endpoints:
+                    result[service.upper() + _id] = Region(_id, *endpoints)
 
         return result
 
     @classmethod
     def _get_regions_file_path(cls):
         regions_file = os.environ.get(cls._REGIONS_FILE_ENV_NAME)
         if regions_file:
             return regions_file
 
-        home_path = path_utils.get_home_path()
+        home_path = filepath_utils.get_home_path()
         return os.path.join(home_path,
                             cls._DEFAULT_REGIONS_FILE_DIR, cls._DEFAULT_REGIONS_FILE) if home_path else home_path
```

## huaweicloudsdkcore/region/provider.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2022 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -67,15 +69,16 @@
             return region
 
         env_name = "{}_{}_{}".format(self._REGION_ENV_PREFIX, self._service_name, region_id.replace("-", "_").upper())
         endpoint = os.getenv(env_name)
         if not endpoint:
             return None
 
-        region = Region(region_id, endpoint)
+        endpoints = endpoint.split(',')
+        region = Region(region_id, *endpoints)
         cache.set(self._service_name + region_id, region)
         return region
 
 
 class ProfileRegionProvider(RegionProvider):
     def get_region(self, region_id):
         return ProfileRegionCache().get(self._service_name + region_id)
```

## huaweicloudsdkcore/region/region.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2022 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -14,37 +16,78 @@
  software distributed under the LICENSE is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
+import warnings
+
 
 class Region(object):
-    def __init__(self, id=None, endpoint=None):
+    def __init__(self, *args, **kwargs):
+        """
+        There are two ways to initialize the region object.
+
+        In the first way, only one region and one endpoint can be specified.
+        region1 = Region(id="region-id", endpoint="region-endpoint")
+
+        In the second way, one region and multiple endpoints can be specified.
+        region2 = Region("region-id", "endpoint1", "endpoint2")
+
+        It is not recommended to mix the two initialization ways.
+        If two initialization ways are mixed, the first way has priority over the second.
+        """
         self._id = None
-        self._endpoint = None
+        self._endpoints = None
 
-        if id is not None:
-            self.id = id
-        if endpoint is not None:
-            self.endpoint = endpoint
+        if len(args) > 1:
+            self._id = args[0]
+            self._endpoints = list(args[1:])
+
+        if kwargs:
+            if "id" in kwargs:
+                self._id = kwargs.get("id")
+            if "endpoint" in kwargs:
+                self._endpoints = [kwargs.get("endpoint")]
+
+        if not self._id:
+            raise ValueError("id is required")
+        if not self.endpoints:
+            raise ValueError("at lease one endpoint is required")
 
     @property
     def id(self):
         return self._id
 
     @id.setter
-    def id(self, id):
-        self._id = id
+    def id(self, _id):
+        self._id = _id
 
     @property
     def endpoint(self):
-        return self._endpoint
+        warnings.warn("As of 3.1.27, because of the support of the multi-endpoint feature, use endpoints instead",
+                      DeprecationWarning)
+        return self.endpoints[0] if self.endpoints else None
 
     @endpoint.setter
     def endpoint(self, endpoint):
-        self._endpoint = endpoint
+        warnings.warn("As of 3.1.27, because of the support of the multi-endpoint feature, use endpoints instead",
+                      DeprecationWarning)
+        self.endpoints = [endpoint]
+
+    @property
+    def endpoints(self):
+        return self._endpoints
+
+    @endpoints.setter
+    def endpoints(self, endpoints):
+        self._endpoints = endpoints
 
     def with_endpoint_override(self, endpoint):
-        self._endpoint = endpoint
+        warnings.warn("As of 3.1.27, because of the support of the multi-endpoint feature,"
+                      "use with_endpoints_override instead", DeprecationWarning)
+        return self.with_endpoints_override([endpoint])
+
+    def with_endpoints_override(self, endpoints):
+        self.endpoints = endpoints
         return self
```

## huaweicloudsdkcore/signer/hkdf.py

```diff
@@ -1,9 +1,28 @@
 # coding: utf-8
+"""
+ Copyright 2022 Huawei Technologies Co.,Ltd.
 
+ Licensed to the Apache Software Foundation (ASF) under one
+ or more contributor license agreements.  See the NOTICE file
+ distributed with this work for additional information
+ regarding copyright ownership.  The ASF licenses this file
+ to you under the Apache LICENSE, Version 2.0 (the
+ "LICENSE"); you may not use this file except in compliance
+ with the LICENSE.  You may obtain a copy of the LICENSE at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing,
+ software distributed under the LICENSE is distributed on an
+ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ KIND, either express or implied.  See the LICENSE for the
+ specific language governing permissions and limitations
+ under the LICENSE.
+"""
 from __future__ import absolute_import
 
 import hashlib
 import math
 import hmac
 import six
 import copy
@@ -43,21 +62,21 @@
 
 def expand(prk, info, hmac_algorithm, okm_len, ceil):
     if ceil == 1:
         raw_result = expand_first(prk, info, hmac_algorithm)
     else:
         raw_result = bytes()
         tmp = bytes()
-        for i in range(1, ceil+1):
+        for i in range(1, ceil + 1):
             tmp = expand_once(prk, info, tmp, i, hmac_algorithm)
             raw_result = raw_result + tmp
     if okm_len == len(raw_result):
         return raw_result
     elif okm_len < len(raw_result):
-        return raw_result[:okm_len+1]
+        return raw_result[:okm_len + 1]
     else:
         return None
 
 
 def expand_first(prk, info, hmac_algorithm):
     result = copy.deepcopy(info)
     result = result + bytearray((1,))
@@ -65,22 +84,28 @@
 
 
 def expand_once(prk, info, pre_tmp, i, hmac_algorithm):
     result = pre_tmp + info + bytearray((i,))
     return hmac_sha256(prk, result, hmac_algorithm)
 
 
+def _get_expand_ceil(derivation_key_len, algorithm_hash_len):
+    try:
+        return int(math.ceil(float(derivation_key_len) / float(algorithm_hash_len)))
+    except ZeroDivisionError as e:
+        raise ValueError(e)
+
+
 HMAC_SHA1 = hashlib.sha1
 HMAC_SHA256 = hashlib.sha256
 DERIVATION_KEY_LENGTH = 32
 HMAC_ALGORITHM = HMAC_SHA256
 ALGORITHM_HASH_LENGTH = get_hash_len(HMAC_ALGORITHM)
 UTF_8 = "utf-8"
-EXPAND_CEIL = int(math.ceil(float(DERIVATION_KEY_LENGTH) / float(ALGORITHM_HASH_LENGTH)))
-
+EXPAND_CEIL = _get_expand_ceil(DERIVATION_KEY_LENGTH, ALGORITHM_HASH_LENGTH)
 
 if six.PY2:
 
     def hmac_sha256(key_byte, message, hmac_algorithm):
         return hmac.new(key_byte, message, digestmod=hmac_algorithm).digest()
 
 else:
```

## huaweicloudsdkcore/signer/signer.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -14,241 +16,363 @@
  software distributed under the LICENSE is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
-import binascii
 import hashlib
 import hmac
 from datetime import datetime
 
 import six
 
+from huaweicloudsdkcore.exceptions.exceptions import SdkException
+from huaweicloudsdkcore.sdk_request import SdkRequest
 from huaweicloudsdkcore.signer import hkdf
+from huaweicloudsdkcore.signer.utils import new_sm3_hash, SM2SigningKey, P256SigningKey
 
-if six.PY2:
-    from urllib import quote, unquote
-else:
+if six.PY3:
     from urllib.parse import quote, unquote
+else:
+    from urllib import quote, unquote
 
 
 class Signer(object):
-    EncodeUtf8 = "utf-8"
-    BasicDateFormat = "%Y%m%dT%H%M%SZ"
-    Algorithm = "SDK-HMAC-SHA256"
-    HeaderXDate = "X-Sdk-Date"
-    HeaderHost = "Host"
-    HeaderAuthorization = "Authorization"
-    HeaderContentSha256 = "X-Sdk-Content-Sha256"
+    _ENCODE_UTF8 = "utf-8"
+    _ENCODE_ISO_8859_1 = "iso-8859-1"
+    _BASIC_DATE_FORMAT = "%Y%m%dT%H%M%SZ"
+    _ALGORITHM = "SDK-HMAC-SHA256"
+    _HEADER_X_DATE = "X-Sdk-Date"
+    _HEADER_HOST = "Host"
+    _HEADER_AUTHORIZATION = "Authorization"
+    _HEADER_CONTENT = "X-Sdk-Content-Sha256"
+    _EMPTY_HASH = "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
 
     def __init__(self, credentials):
         self._ak = credentials.ak
         self._sk = credentials.sk
+        self._hash_func = hashlib.sha256
+
+    def _verify_required(self):
+        if not self._ak:
+            raise ValueError("ak is required in credentials")
+        if not self._sk:
+            raise ValueError("sk is required in credentials")
 
     def sign(self, request):
+        # type: (SdkRequest) -> SdkRequest
+        self._verify_required()
         if isinstance(request.body, six.text_type):
             request.body = six.ensure_binary(request.body)
 
-        t = self.process_header_time(request)
-        self.process_header_host(request)
-
-        signed_headers = self.process_signed_headers(request)
-        canonical_request = self.process_canonical_request(request, signed_headers)
-        string_to_sign = self.process_string_to_sign(canonical_request, t)
-        signature = self.sign_string_to_sign(string_to_sign, self._sk)
-        auth_value = self.process_auth_header_value(signature, self._ak, signed_headers)
-        request.header_params[self.HeaderAuthorization] = auth_value
+        self._process_content_header(request)
+        t = self._process_header_time(request)
+        self._process_header_host(request)
+
+        signed_headers = self._process_signed_headers(request)
+        canonical_request = self._process_canonical_request(request, signed_headers)
+        string_to_sign = self._process_string_to_sign(canonical_request, t)
+        signature = self._sign_string_to_sign(string_to_sign, self._sk)
+        auth_value = self._process_auth_header_value(signature, self._ak, signed_headers)
+        request.header_params[self._HEADER_AUTHORIZATION] = auth_value
 
         self.process_request_uri(request)
 
         return request
 
     @classmethod
+    def _process_content_header(cls, request):
+        # type: (SdkRequest) -> None
+        content_type = request.header_params.get("Content-Type")
+        if content_type and not content_type.startswith("application/json"):
+            request.header_params[cls._HEADER_CONTENT] = "UNSIGNED-PAYLOAD"
+
+    @classmethod
     def process_request_uri(cls, request):
-        canonical_query_string = cls.process_canonical_query_string(request)
+        # type: (SdkRequest) -> None
+        canonical_query_string = cls._process_canonical_query_string(request)
         request.uri = "%s?%s" % (request.resource_path, canonical_query_string) \
             if canonical_query_string != "" else request.resource_path
 
     @classmethod
-    def process_header_time(cls, request):
-        header_time = cls.find_header(request, cls.HeaderXDate)
+    def _process_header_time(cls, request):
+        # type: (SdkRequest) -> datetime
+        header_time = cls._get_header_ignore_case(request, cls._HEADER_X_DATE)
         if header_time is None:
             t = datetime.utcnow()
-            request.header_params[cls.HeaderXDate] = datetime.strftime(t, cls.BasicDateFormat)
+            request.header_params[cls._HEADER_X_DATE] = datetime.strftime(t, cls._BASIC_DATE_FORMAT)
         else:
-            t = datetime.strptime(header_time, cls.BasicDateFormat)
+            t = datetime.strptime(header_time, cls._BASIC_DATE_FORMAT)
         return t
 
     @classmethod
-    def process_header_host(cls, request):
+    def _process_header_host(cls, request):
+        # type: (SdkRequest) -> None
         has_host_header = False
         for key in request.header_params:
             if key.lower() == 'host':
                 has_host_header = True
                 break
         if not has_host_header:
             request.header_params["Host"] = request.host
 
-    @classmethod
-    def hmac_sha256(cls, key_byte, message):
-        return hmac.new(six.ensure_binary(key_byte), six.ensure_binary(message), digestmod=hashlib.sha256).digest()
+    def _hash_hex_string(self, data):
+        # type: (bytes) -> str
+        _hash = self._hash_func(data)
+        return _hash.hexdigest()
+
+    def _hmac(self, key, data):
+        # type: (bytes, bytes) -> bytes
+        return hmac.new(key, data, digestmod=self._hash_func).digest()
 
-    @classmethod
-    def process_string_to_sign(cls, canonical_request, time):
+    def _process_string_to_sign(self, canonical_request, time):
+        # type: (str, datetime) -> str
         return "%s\n%s\n%s" % (
-            cls.Algorithm,
-            datetime.strftime(time, cls.BasicDateFormat),
-            cls.hex_encode_sha256_hash(six.ensure_binary(canonical_request))
+            self._ALGORITHM,
+            datetime.strftime(time, self._BASIC_DATE_FORMAT),
+            self._hash_hex_string(six.ensure_binary(canonical_request))
         )
 
     @classmethod
-    def url_encode(cls, s):
+    def _url_encode(cls, s):
+        # type: (str) -> str
         return quote(s, safe='~')
 
     @classmethod
-    def find_header(cls, r, header):
+    def _get_header_ignore_case(cls, r, header):
+        # type: (SdkRequest, str) -> str|None
         for k in r.header_params:
             if k.lower() == header.lower():
                 return r.header_params[k]
         return None
 
-    @classmethod
-    def hex_encode_sha256_hash(cls, data):
-        sha256 = hashlib.sha256()
-        sha256.update(data)
-        return sha256.hexdigest()
-
-    @classmethod
-    def process_canonical_request(cls, request, signed_headers):
+    def _process_canonical_request(self, request, signed_headers):
+        # type: (SdkRequest, dict) -> str
         """
         Build a CanonicalRequest from a regular request string
 
         CanonicalRequest consists of several parts:
           Part 1. HTTPRequestMethod
           Part 2. CanonicalURI
           Part 3. CanonicalQueryString
           Part 4. CanonicalHeaders
           Part 5 SignedHeaders
           Part 6 HexEncode(Hash(RequestPayload))
         """
-        canonical_headers = cls.process_canonical_headers(request, signed_headers)
-        hex_encode = cls.find_header(request, cls.HeaderContentSha256)
-        if hex_encode is None:
-            hex_encode = cls.hex_encode_sha256_hash(request.body)
-        canonical_uri = cls.process_canonical_uri(request)
-        canonical_query_string = cls.process_canonical_query_string(request)
+        canonical_headers = self._process_canonical_headers(request, signed_headers)
+
+        hex_encode = self._process_hash_payload(request)
+        canonical_uri = self._process_canonical_uri(request)
+        canonical_query_string = self._process_canonical_query_string(request)
         return "%s\n%s\n%s\n%s\n%s\n%s" % (request.method.upper(), canonical_uri, canonical_query_string,
                                            canonical_headers, ";".join(signed_headers), hex_encode)
 
-    @classmethod
-    def process_canonical_uri(cls, request):
+    def _process_hash_payload(self, request):
+        # type: (SdkRequest) -> str
+        if not request.body:
+            return self._EMPTY_HASH
+
+        hex_encode = self._get_header_ignore_case(request, self._HEADER_CONTENT)
+        if hex_encode:
+            return hex_encode
+
+        return self._hash_hex_string(request.body)
+
+    def _process_canonical_uri(self, request):
+        # type: (SdkRequest) -> str
         pattens = unquote(request.resource_path).split('/')
         uri = []
         for v in pattens:
-            uri.append(cls.url_encode(v))
+            uri.append(self._url_encode(v))
         url_path = "/".join(uri)
 
         if url_path[-1] != '/':
             url_path = url_path + "/"
 
         return url_path
 
     @classmethod
-    def process_canonical_query_string(cls, request):
+    def _process_canonical_query_string(cls, request):
+        # type: (SdkRequest) -> str
         params = []
         for param in request.query_params:
             params.append(param)
         params.sort()
 
         canonical_query_param = []
         for (key, value) in params:
-            k = cls.url_encode(key)
+            k = cls._url_encode(key)
             if isinstance(value, list):
                 value.sort()
                 for v in value:
-                    kv = "%s=%s" % (k, cls.url_encode(str(v)))
+                    kv = "%s=%s" % (k, cls._url_encode(str(v)))
                     canonical_query_param.append(kv)
             elif isinstance(value, bool):
-                kv = "%s=%s" % (k, cls.url_encode(str(value).lower()))
+                kv = "%s=%s" % (k, cls._url_encode(str(value).lower()))
                 canonical_query_param.append(kv)
             else:
-                kv = "%s=%s" % (k, cls.url_encode(str(value)))
+                kv = "%s=%s" % (k, cls._url_encode(str(value)))
                 canonical_query_param.append(kv)
 
         return '&'.join(canonical_query_param)
 
-    @classmethod
-    def process_canonical_headers(cls, request, signed_headers):
+    def _process_canonical_headers(self, request, signed_headers):
+        # type: (SdkRequest, dict) -> str
         canonical_headers = []
         __headers = {}
         for key in request.header_params:
             key_encoded = key.lower()
             value = request.header_params[key]
             value_encoded = str(value).strip()
             __headers[key_encoded] = value_encoded
             if six.PY3:
-                request.header_params[key] = value_encoded.encode(cls.EncodeUtf8).decode('iso-8859-1')
+                request.header_params[key] = value_encoded.encode(self._ENCODE_UTF8).decode('iso-8859-1')
 
         for key in signed_headers:
             canonical_headers.append(key + ":" + __headers.get(key))
 
         return '\n'.join(canonical_headers) + "\n"
 
     @classmethod
-    def process_signed_headers(cls, request):
+    def _process_signed_headers(cls, request):
+        # type: (SdkRequest) -> list
         signed_headers = []
         for key in request.header_params:
             signed_headers.append(key.lower())
         signed_headers.sort()
         return signed_headers
 
-    @classmethod
-    def sign_string_to_sign(cls, string_to_sign, key):
-        hm = cls.hmac_sha256(key, string_to_sign)
-        return binascii.hexlify(hm).decode()
+    def _sign_string_to_sign(self, string_to_sign, key):
+        # type: (str, str) -> str
+        return self._hex(self._hmac(six.ensure_binary(key), six.ensure_binary(string_to_sign)))
 
-    @classmethod
-    def process_auth_header_value(cls, signature, app_key, signed_headers):
+    def _process_auth_header_value(self, signature, app_key, signed_headers):
+        # type: (str, str, list) -> str
         return "%s Access=%s, SignedHeaders=%s, Signature=%s" % (
-            cls.Algorithm, app_key, ";".join(signed_headers), signature)
+            self._ALGORITHM, app_key, ";".join(signed_headers), signature)
+
+    def _hex(self, data):
+        if six.PY2:
+            return "".join("{:02x}".format(ord(c)) for c in six.ensure_binary(data))
+        return data.hex()
+
+
+class SM3Signer(Signer):
+    _ALGORITHM = "SDK-HMAC-SM3"
+    _HEADER_CONTENT = "X-Sdk-Content-Sm3"
+    _EMPTY_HASH = "1ab21d8355cfa17f8e61194831e81a8f22bec8c728fefb747ed035eb5082aa2b"
+
+    def __init__(self, credentials):
+        super(SM3Signer, self).__init__(credentials)
+        self._hash_func = new_sm3_hash
+
+    def _verify_required(self):
+        super(SM3Signer, self)._verify_required()
+        if six.PY2:
+            raise SdkException("Signing algorithm %s is not supported in python2" % self._ALGORITHM)
 
 
 class DerivationAKSKSigner(Signer):
     BasicISODateFormat = "%Y%m%d"
-    Algorithm = "V11-HMAC-SHA256"
+    _ALGORITHM = "V11-HMAC-SHA256"
 
-    @classmethod
-    def process_string_to_sign(cls, canonical_request, time, info=None):
+    def _process_string_to_sign(self, canonical_request, time, info=None):
+        # type: (str, datetime, str) -> str
         return "%s\n%s\n%s\n%s" % (
-            cls.Algorithm,
-            datetime.strftime(time, cls.BasicDateFormat),
+            self._ALGORITHM,
+            datetime.strftime(time, self._BASIC_DATE_FORMAT),
             info,
-            cls.hex_encode_sha256_hash(six.ensure_binary(canonical_request))
+            self._hash_hex_string(six.ensure_binary(canonical_request))
         )
 
-    @classmethod
-    def process_auth_header_value(cls, signature, app_key, signed_headers, info=None):
+    def _process_auth_header_value(self, signature, app_key, signed_headers, info=None):
+        # type: (str, str, list, str) -> str
         return "%s Credential=%s/%s, SignedHeaders=%s, Signature=%s" % (
-            cls.Algorithm, app_key, info, ";".join(signed_headers), signature)
+            self._ALGORITHM, app_key, info, ";".join(signed_headers), signature)
 
     def sign(self, request, derived_auth_service_name=None, region_id=None):
-        request.body = six.ensure_binary(request.body)
+        # type: (SdkRequest, str, str) -> SdkRequest
+        self._verify_required()
+        if not derived_auth_service_name:
+            raise ValueError("derivedAuthServiceName is required in credentials when using derived auth")
+        if not region_id:
+            raise ValueError("regionId is required in credentials when using derived auth")
 
-        t = self.process_header_time(request)
-        self.process_header_host(request)
+        if isinstance(request.body, six.text_type):
+            request.body = six.ensure_binary(request.body)
 
-        signed_headers = self.process_signed_headers(request)
-        canonical_request = self.process_canonical_request(request, signed_headers)
-        date_str = datetime.strftime(datetime.utcnow(), self.BasicISODateFormat)
+        self._process_content_header(request)
+        t = self._process_header_time(request)
+        self._process_header_host(request)
+
+        signed_headers = self._process_signed_headers(request)
+        canonical_request = self._process_canonical_request(request, signed_headers)
+        date_str = datetime.strftime(t, self.BasicISODateFormat)
         info_str = "%s/%s/%s" % (date_str, region_id, derived_auth_service_name)
-        string_to_sign = self.process_string_to_sign(canonical_request, t, info_str)
+        string_to_sign = self._process_string_to_sign(canonical_request, t, info_str)
         derivation_key = hkdf.get_der_key_sha256(access_key=self._ak, secret_key=self._sk, info=info_str)
-        signature = self.sign_string_to_sign(string_to_sign, derivation_key)
-        auth_value = self.process_auth_header_value(signature, self._ak, signed_headers, info_str)
-        request.header_params[self.HeaderAuthorization] = auth_value
+        signature = self._sign_string_to_sign(string_to_sign, derivation_key)
+        auth_value = self._process_auth_header_value(signature, self._ak, signed_headers, info_str)
+        request.header_params[self._HEADER_AUTHORIZATION] = auth_value
 
         self.process_request_uri(request)
 
         return request
 
+
+class P256SHA256Signer(Signer):
+    _ALGORITHM = "SDK-ECDSA-P256-SHA256"
+    _N_MINUS_TWO = P256SigningKey.N_MINUS_TWO
+
+    def _verify_required(self):
+        super(P256SHA256Signer, self)._verify_required()
+        if six.PY2:
+            raise SdkException("Signing algorithm %s is not supported in python2" % self._ALGORITHM)
+
+    def _sign_string_to_sign(self, data, key=None):
+        # type: (str, str) -> str
+        signing_key = self.get_signing_key()
+        signature = signing_key.sign(six.ensure_binary(data))
+        return self._hex(signature)
+
+    def _derive_key(self):
+        # type: () -> int
+        context = bytearray()
+        data = bytearray()
+        for counter in range(0xff):
+            context.clear()
+            data.clear()
+
+            context.extend(six.ensure_binary(self._ak))
+            context.append(counter)
+
+            data.extend(b'\x00\x00\x00\x01')
+            data.extend(six.ensure_binary(self._ALGORITHM))
+            data.append(0x00)
+            data.extend(context)
+            data.extend(b'\x00\x00\x01\x00')
+
+            candidate = int.from_bytes(self._hmac(six.ensure_binary(self._sk), bytes(data)), 'big')
+            if candidate <= self._N_MINUS_TWO:
+                return candidate + 1
+
+        raise SdkException("derive candidate failed, counter out of range")
+
+    def get_signing_key(self):
+        private_key = self._derive_key()
+        return P256SigningKey(private_key)
+
+
+class SM2SM3Signer(P256SHA256Signer):
+    _ALGORITHM = "SDK-SM2-SM3"
+    _HEADER_CONTENT = "X-Sdk-Content-Sm3"
+    _EMPTY_HASH = "1ab21d8355cfa17f8e61194831e81a8f22bec8c728fefb747ed035eb5082aa2b"
+    _N_MINUS_TWO = SM2SigningKey.N_MINUS_TWO
+
+    def __init__(self, credentials):
+        super(SM2SM3Signer, self).__init__(credentials)
+        self._hash_func = new_sm3_hash
+
+    def get_signing_key(self):
+        private_key = self._derive_key()
+        return SM2SigningKey(private_key)
```

## huaweicloudsdkcore/utils/core_utils.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
```

## huaweicloudsdkcore/utils/http_utils.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -16,27 +18,26 @@
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
 import datetime
 import decimal
-from mimetypes import MimeTypes
 
 import six
 
 from huaweicloudsdkcore.http.formdata import FormFile
-from huaweicloudsdkcore.http.primitive_types import primitive_types
+from huaweicloudsdkcore.http.primitive_types import PRIMITIVE_TYPES
 
 
 def sanitize_for_serialization(obj):
     if obj is None:
         return None
 
-    elif isinstance(obj, primitive_types):
+    elif isinstance(obj, PRIMITIVE_TYPES):
         return obj
 
     elif isinstance(obj, decimal.Decimal):
         return obj
 
     elif isinstance(obj, list):
         return [sanitize_for_serialization(sub_obj) for sub_obj in obj]
@@ -106,25 +107,25 @@
             if collection_format == 'multi':
                 new_params.extend((k, value) for value in v)
             else:
                 new_params.append(
                     (k, ','.join(str(value) for value in v)))
         else:
             if isinstance(v, dict):
-                dict_params = get_dict_params(k, v)
-                for dict_param in dict_params:
-                    new_params.append(dict_param)
+                value_tuples = parameters_to_tuples(v, collection_formats)
+                for value_tuple in value_tuples:
+                    new_params.append((k, "%s=%s" % (value_tuple[0], value_tuple[1])))
             else:
                 new_params.append((k, v))
     return new_params
 
 
 def select_header_accept(accepts):
     if not accepts:
-        return
+        return ''
     accepts = [x.lower() for x in accepts]
     if 'application/json' in accepts:
         return 'application/json'
     else:
         return ', '.join(accepts)
 
 
@@ -132,10 +133,7 @@
     if not content_types:
         return 'application/json'
     content_types = [x.lower() for x in content_types]
     if 'application/json' in content_types or '*/*' in content_types:
         return 'application/json'
     else:
         return content_types[0]
-
-
-
```

## huaweicloudsdkcore/utils/six_utils.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2022 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -17,14 +19,21 @@
  specific language governing permissions and limitations
  under the LICENSE.
 """
 from threading import Lock
 
 import six
 
+if six.PY3:
+    from json import JSONDecodeError
+
+    JSON_DECODE_ERROR = JSONDecodeError
+else:
+    JSON_DECODE_ERROR = ValueError
+
 
 class SingletonMeta(type):
     _instances = {}
 
     _lock = Lock()
 
     def __call__(cls, *args, **kwargs):
```

## huaweicloudsdkcore/utils/string_utils.py

```diff
@@ -1,9 +1,11 @@
 # coding: utf-8
 """
+ Copyright 2020 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
```

## huaweicloudsdkcore/utils/time_utils.py

```diff
@@ -1,7 +1,30 @@
+# coding: utf-8
+"""
+ Copyright 2022 Huawei Technologies Co.,Ltd.
+
+ Licensed to the Apache Software Foundation (ASF) under one
+ or more contributor license agreements.  See the NOTICE file
+ distributed with this work for additional information
+ regarding copyright ownership.  The ASF licenses this file
+ to you under the Apache LICENSE, Version 2.0 (the
+ "LICENSE"); you may not use this file except in compliance
+ with the LICENSE.  You may obtain a copy of the LICENSE at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing,
+ software distributed under the LICENSE is distributed on an
+ "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ KIND, either express or implied.  See the LICENSE for the
+ specific language governing permissions and limitations
+ under the LICENSE.
+"""
+
+
 import time
 import datetime
 
 
 def get_timestamp_utc():
     return time.mktime(datetime.datetime.utcnow().timetuple())
```

## tests/test_client_build.py

```diff
@@ -26,18 +26,18 @@
 import pytest
 
 from huaweicloudsdkcore.auth.credentials import BasicCredentials
 from huaweicloudsdkcore.client import Client, ClientBuilder
 from huaweicloudsdkcore.http.http_client import HttpClient
 from huaweicloudsdkcore.http.http_config import HttpConfig
 
-ak = "my ak"
-sk = "my sk"
-endpoint = "my endpoint"
-project_id = "my project_id"
+ak = "AccessKey"
+sk = "SecretKey"
+endpoint = "Endpoint"
+project_id = "ProjectId"
 logger_name = 'HuaweiCloud-SDK-Client'
 config = HttpConfig.get_default_config()
 config.ignore_ssl_verification = True
 credentials = BasicCredentials(ak, sk, project_id)
 
 
 def test_build_client_by_client_builder():
@@ -45,20 +45,20 @@
         .with_http_config(config) \
         .with_credentials(credentials) \
         .with_endpoint(endpoint) \
         .build()
 
     assert isinstance(client, Client)
     assert client.get_agent() == {"User-Agent": "huaweicloud-usdk-python/3.0"}
-    assert client.get_credentials().ak == "my ak"
-    assert client.get_credentials().sk == "my sk"
+    assert client.get_credentials().ak == "AccessKey"
+    assert client.get_credentials().sk == "SecretKey"
 
     assert isinstance(client.get_http_client(), HttpClient)
-    assert client.get_http_client()._timeout == (60, 120)
-    assert client.get_http_client()._verify is False
+    assert client.get_http_client().config.timeout == (60, 120)
+    assert client.get_http_client().config.ignore_ssl_verification
 
 
 def test_default_sdk_logger():
     ClientBuilder(Client) \
         .with_http_config(config) \
         .with_credentials(credentials) \
         .with_endpoint(endpoint) \
```

## tests/test_credential_provider.py

```diff
@@ -20,15 +20,15 @@
 
 import os
 import stat
 
 import pytest
 
 from huaweicloudsdkcore.auth import provider
-from huaweicloudsdkcore.utils import path_utils
+from huaweicloudsdkcore.utils import filepath_utils
 from huaweicloudsdkcore.auth.credentials import BasicCredentials, GlobalCredentials
 from huaweicloudsdkcore.exceptions.exceptions import ApiValueError
 
 AK = "ak"
 SK = "sk"
 SECURITY_TOKEN = "security_token"
 PROJECT_ID = "project_id"
@@ -55,15 +55,15 @@
 def _clear_envs():
     keys = (key for key in os.environ.keys() if key.startswith("HUAWEICLOUD_SDK"))
     for key in keys:
         os.environ.pop(key)
 
 
 def _get_credentials_file_dir():
-    home_path = path_utils.get_home_path()
+    home_path = filepath_utils.get_home_path()
     if home_path:
         return home_path
     return os.path.abspath(os.curdir)
 
 
 class TestEnvCredentialProvider:
     def teardown(self):
@@ -137,24 +137,25 @@
 
 
 class TestProfileCredentialProvider:
     CREDENTIALS_FILE_ENV_NAME = "HUAWEICLOUD_SDK_CREDENTIALS_FILE"
     CREDENTIALS_FILE_DIR = _get_credentials_file_dir()
     TEST_CREDENTIALS_FILE = os.path.join(CREDENTIALS_FILE_DIR, "test_credentials")
 
-    @staticmethod
-    def setup_class(self):
+    @classmethod
+    def setup_class(cls):
         flags = os.O_WRONLY | os.O_CREAT | os.O_EXCL
         modes = stat.S_IWUSR | stat.S_IRUSR
-        with os.fdopen(os.open(self.TEST_CREDENTIALS_FILE, flags, modes), 'w') as f:
+        with os.fdopen(os.open(cls.TEST_CREDENTIALS_FILE, flags, modes), 'w') as f:
             f.write(CONTENT)
 
-    def teardown_class(self):
-        if os.path.exists(self.TEST_CREDENTIALS_FILE):
-            os.remove(self.TEST_CREDENTIALS_FILE)
+    @classmethod
+    def teardown_class(cls):
+        if os.path.exists(cls.TEST_CREDENTIALS_FILE):
+            os.remove(cls.TEST_CREDENTIALS_FILE)
 
     def setup(self):
         os.environ[self.CREDENTIALS_FILE_ENV_NAME] = self.TEST_CREDENTIALS_FILE
 
     def teardown(self):
         if self.CREDENTIALS_FILE_ENV_NAME in os.environ:
             os.environ.pop(self.CREDENTIALS_FILE_ENV_NAME)
@@ -194,15 +195,16 @@
                and expected.domain_id == actual.domain_id \
                and expected.security_token == actual.security_token \
                and expected.iam_endpoint == actual.iam_endpoint
 
 
 class TestCredentialProviderChain:
 
-    def teardown_class(self):
+    @classmethod
+    def teardown_class(cls):
         _clear_envs()
 
     def test_custom_providers(self):
         providers = [
             provider.ProfileCredentialProvider.get_basic_credential_profile_provider(),
             provider.EnvCredentialProvider.get_basic_credential_env_provider()
         ]
```

## tests/test_endpoint_without_scheme.py

```diff
@@ -18,15 +18,15 @@
  under the LICENSE.
 """
 
 import pytest
 
 from huaweicloudsdkcore.auth.credentials import BasicCredentials
 from huaweicloudsdkcore.http.http_config import HttpConfig
-from tests.data.project_response_mocker import MOCK_ENDPOINT, MOCK_ENDPOINT_WITHOUT_SCHEME
+from tests.mocker.project_response_mocker import MOCK_ENDPOINT, MOCK_ENDPOINT_WITHOUT_SCHEME
 from tests.model.service.service_client import ServiceClient
 
 config = HttpConfig.get_default_config()
 config.ignore_ssl_verification = True
 
 credentials = BasicCredentials("ak", "sk", "project_id")
 
@@ -34,13 +34,13 @@
 def test_endpoint_without_scheme():
     client = ServiceClient.new_builder() \
         .with_http_config(config) \
         .with_credentials(credentials) \
         .with_endpoint(MOCK_ENDPOINT_WITHOUT_SCHEME) \
         .build()
 
-    assert hasattr(client, "_endpoint") is True
-    assert getattr(client, "_endpoint") == MOCK_ENDPOINT
+    assert hasattr(client, "_endpoints") is True
+    assert getattr(client, "_endpoints")[0] == MOCK_ENDPOINT
 
 
 if __name__ == "__main__":
     pytest.main()
```

## tests/test_region_provider.py

```diff
@@ -14,93 +14,85 @@
  software distributed under the LICENSE is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
-import stat
+import os
+
+import pytest
 
-from huaweicloudsdkcore.utils import path_utils
 from huaweicloudsdkcore.region.cache import EnvRegionCache, ProfileRegionCache
 from huaweicloudsdkcore.region.provider import EnvRegionProvider, ProfileRegionProvider, RegionProviderChain
-from huaweicloudsdkcore.region.region import Region
 
-import pytest
-import os
 
-SERVICE_NAME = "Service"
-REGION_ID = "region-id-1"
-ENDPOINT = "https://{}.{}.myhuaweicloud.com".format(SERVICE_NAME.lower(), REGION_ID)
-REGION_STR = """SERVICE:
-  - id: region-id-1
-    endpoint: 'https://service.region-id-1.myhuaweicloud.com'
-"""
+@pytest.fixture(scope="module")
+def set_region_file_env():
+    path = os.path.abspath("data/regions.yaml")
+    os.environ["HUAWEICLOUD_SDK_REGIONS_FILE"] = path
+
+    yield
+
+    os.unsetenv("HUAWEICLOUD_SDK_REGIONS_FILE")
 
 
 def test_env_region_provider():
     # test singleton
     assert EnvRegionCache() is EnvRegionCache()
     # test not found
-    provider = EnvRegionProvider(SERVICE_NAME)
-    assert provider.get_region(REGION_ID) is None
+    provider = EnvRegionProvider("Service1")
+    assert provider.get_region("not-exist-1") is None
     # test found
-    env_name = "HUAWEICLOUD_SDK_REGION_{}_{}".format(SERVICE_NAME.upper(), REGION_ID.replace("-", "_").upper())
-    os.environ[env_name] = ENDPOINT
-    actual_region = provider.get_region(REGION_ID)
+    env_name = "HUAWEICLOUD_SDK_REGION_SERVICE1_REGION_ID_1"
+    os.environ[env_name] = "https://service1.region-id-1.com"
+    actual_region = provider.get_region("region-id-1")
     assert actual_region
-    expected_region = Region(REGION_ID, ENDPOINT)
-    assert expected_region.id == actual_region.id
-    assert expected_region.endpoint == actual_region.endpoint
+    assert "region-id-1" == actual_region.id
+    assert ["https://service1.region-id-1.com"] == actual_region.endpoints
 
 
-def test_profile_region_provider():
-    home_path = path_utils.get_home_path()
-    if not home_path:
-        home_path = os.path.abspath(os.curdir)
-    filename = "test_regions.yaml"
-    path = os.path.join(home_path, filename)
-    os.environ["HUAWEICLOUD_SDK_REGIONS_FILE"] = path
+def test_env_region_provider2():
+    provider = EnvRegionProvider("Service2")
+    env_name = "HUAWEICLOUD_SDK_REGION_SERVICE2_REGION_ID_2"
+    os.environ[env_name] = "https://service2.region-id-2.com,https://service3.region-id-3.com"
+    actual_region = provider.get_region("region-id-2")
+    assert actual_region
+    assert "region-id-2" == actual_region.id
+    assert ["https://service2.region-id-2.com", "https://service3.region-id-3.com"] == actual_region.endpoints
 
-    flags = os.O_WRONLY | os.O_CREAT | os.O_EXCL
-    modes = stat.S_IWUSR | stat.S_IRUSR
-    with os.fdopen(os.open(path, flags, modes), 'w') as f:
-        f.write(REGION_STR)
 
+def test_profile_region_provider(set_region_file_env):
     # test singleton
     assert ProfileRegionCache() is ProfileRegionCache()
-    provider = ProfileRegionProvider(SERVICE_NAME)
-    try:
-        # test found
-        actual_region = provider.get_region(REGION_ID)
-        assert actual_region
-        expected_region = Region(REGION_ID, ENDPOINT)
-        assert expected_region.id == actual_region.id
-        assert expected_region.endpoint == actual_region.endpoint
-    except AssertionError:
-        assert False
-    finally:
-        if os.path.isfile(path):
-            os.remove(path)
+    provider = ProfileRegionProvider("Service1")
+    # test found
+    actual_region = provider.get_region("region-id-1")
+    assert actual_region
+    assert "region-id-1" == actual_region.id
+    assert ["https://service1.region-id-1.com"] == actual_region.endpoints
     # test not found
     region = provider.get_region("not-exist-1")
     assert region is None
 
 
-def test_region_provider_chain():
-    chain = RegionProviderChain.get_default_region_provider_chain(SERVICE_NAME)
+def test_profile_region_provider2(set_region_file_env):
+    provider = ProfileRegionProvider("Service2")
+    actual_region = provider.get_region("region-id-2")
+    assert actual_region
+    assert "region-id-2" == actual_region.id
+    assert ["https://service2.region-id-2.com", "https://service2.region-id-2.cn"] == actual_region.endpoints
+
+
+def test_region_provider_chain(set_region_file_env):
+    chain = RegionProviderChain.get_default_region_provider_chain("Service1")
     # test not found
-    assert chain.get_region("not-exist-2") is None
+    assert chain.get_region("not-exist-1") is None
     # test found
-    region_id = "test-region-2"
-    endpoint = "https://test.service.com"
-    env_name = "HUAWEICLOUD_SDK_REGION_{}_{}".format(SERVICE_NAME.upper(), region_id.replace("-", "_").upper())
-    os.environ[env_name] = endpoint
-    actual_region = chain.get_region(region_id)
+    actual_region = chain.get_region("region-id-1")
     assert actual_region
-    expected_region = Region(region_id, endpoint)
-    assert expected_region.id == actual_region.id
-    assert expected_region.endpoint == actual_region.endpoint
+    assert "region-id-1" == actual_region.id
+    assert ["https://service1.region-id-1.com"] == actual_region.endpoints
 
 
 if __name__ == '__main__':
     pytest.main()
```

## tests/test_region_with_project_id.py

```diff
@@ -19,15 +19,15 @@
 """
 
 import pytest
 
 from huaweicloudsdkcore.auth.credentials import BasicCredentials
 from huaweicloudsdkcore.http.http_config import HttpConfig
 from huaweicloudsdkcore.region.region import Region
-from tests.data.project_response_mocker import MOCK_ENDPOINT
+from tests.mocker.project_response_mocker import MOCK_ENDPOINT
 from tests.model.service.service_client import ServiceClient
 from tests.model.service.service_region import ServiceRegion
 
 OVERRIDE_ENDPOINT = "https://service.cn-north-x.myhuaweicloud.com"
 
 config = HttpConfig.get_default_config()
 config.ignore_ssl_verification = True
@@ -38,60 +38,60 @@
 def test_endpoint_with_region_1():
     client = ServiceClient.new_builder() \
         .with_http_config(config) \
         .with_credentials(credentials) \
         .with_region(ServiceRegion.CN_NORTH_7) \
         .build()
 
-    assert hasattr(client, "_endpoint") is True
-    assert getattr(client, "_endpoint") == MOCK_ENDPOINT
+    assert hasattr(client, "_endpoints") is True
+    assert getattr(client, "_endpoints")[0] == MOCK_ENDPOINT
 
 
 def test_endpoint_with_region_2():
     client = ServiceClient.new_builder() \
         .with_http_config(config) \
         .with_credentials(credentials) \
         .with_region(ServiceRegion.value_of("cn-north-7")) \
         .build()
 
-    assert hasattr(client, "_endpoint") is True
-    assert getattr(client, "_endpoint") == MOCK_ENDPOINT
+    assert hasattr(client, "_endpoints") is True
+    assert getattr(client, "_endpoints")[0] == MOCK_ENDPOINT
 
 
 def test_endpoint_with_region_3():
     client = ServiceClient.new_builder() \
         .with_http_config(config) \
         .with_credentials(credentials) \
-        .with_region(Region(id="cn-north-7", endpoint=MOCK_ENDPOINT)) \
+        .with_region(Region("cn-north-7", MOCK_ENDPOINT)) \
         .build()
 
-    assert hasattr(client, "_endpoint") is True
-    assert getattr(client, "_endpoint") == MOCK_ENDPOINT
+    assert hasattr(client, "_endpoints") is True
+    assert getattr(client, "_endpoints")[0] == MOCK_ENDPOINT
 
 
 def test_endpoint_with_region_override_1():
     client = ServiceClient.new_builder() \
         .with_http_config(config) \
         .with_credentials(credentials) \
         .with_region(ServiceRegion.CN_NORTH_7.with_endpoint_override(OVERRIDE_ENDPOINT)) \
         .build()
 
-    assert hasattr(client, "_endpoint") is True
-    assert getattr(client, "_endpoint") == OVERRIDE_ENDPOINT
+    assert hasattr(client, "_endpoints") is True
+    assert getattr(client, "_endpoints")[0] == OVERRIDE_ENDPOINT
 
 
 def test_endpoint_with_region_override_2():
     client = ServiceClient.new_builder() \
         .with_http_config(config) \
         .with_credentials(credentials) \
         .with_region(ServiceRegion.value_of("cn-north-7").with_endpoint_override(OVERRIDE_ENDPOINT)) \
         .build()
 
-    assert hasattr(client, "_endpoint") is True
-    assert getattr(client, "_endpoint") == OVERRIDE_ENDPOINT
+    assert hasattr(client, "_endpoints") is True
+    assert getattr(client, "_endpoints")[0] == OVERRIDE_ENDPOINT
 
 
 def test_region_value_of_empty():
     try:
         ServiceClient.new_builder() \
             .with_http_config(config) \
             .with_credentials(credentials) \
```

## tests/test_region_without_project_id.py

```diff
@@ -19,15 +19,15 @@
 """
 
 import pytest
 
 from huaweicloudsdkcore.auth.credentials import BasicCredentials
 from huaweicloudsdkcore.client import Client
 from huaweicloudsdkcore.http.http_config import HttpConfig
-from tests.data.project_response_mocker import MOCK_ENDPOINT, mock_keystone_list_projects
+from tests.mocker.project_response_mocker import MOCK_ENDPOINT, mock_keystone_list_projects
 from tests.test_region_with_project_id import ServiceRegion
 
 REGION_ID = "cn-north-7"
 
 
 def test_project_id_with_region(mocker):
     mock_credential = BasicCredentials("ak", "sk").with_iam_endpoint(MOCK_ENDPOINT)
```

## tests/test_request_and_exceptions.py

```diff
@@ -27,17 +27,17 @@
 from huaweicloudsdkcore.exceptions.exceptions import ClientRequestException, ServerResponseException
 from huaweicloudsdkcore.http.http_config import HttpConfig
 from tests.model.vpc import ListVpcsResponse
 
 
 @pytest.fixture()
 def client():
-    ak = "my ak"
-    sk = "my sk"
-    project_id = "my project_id"
+    ak = "AccessKey"
+    sk = "SecretKey"
+    project_id = "ProjectId"
     endpoint = "https://vpc.cn-north-x.myhuaweicloud.com"
 
     config = HttpConfig.get_default_config()
     config.ignore_ssl_verification = True
     credentials = BasicCredentials(ak, sk, project_id)
 
     client = ClientBuilder(Client) \
@@ -168,15 +168,15 @@
 
     assert e.value.request_id == "request-client-error-001"
     assert e.value.error_code == "ERR.CLIENT_ERR"
     assert e.value.error_msg == "request-client-error-001"
 
 
 def test_client_request_exception2(client, client_err_response_type2):
-    with pytest.raises(ServerResponseException) as e:
+    with pytest.raises(ClientRequestException) as e:
         client.get_http_client().response_error_hook_factory()(client_err_response_type2)
 
     assert e.value.error_msg == "request-client-error-002"
 
 
 def test_server_response_exception(client, server_err_response):
     with pytest.raises(ServerResponseException) as e:
@@ -194,15 +194,15 @@
     assert e.value.request_id == "request-server-error-002"
     assert e.value.error_code == "ERR.SERVER_ERR"
     assert e.value.error_msg == "request-server-error-002"
 
 
 def test_response_deserialization(client, list_vpc_response):
     client.model_package = importlib.import_module("tests.model.vpc")
-    response = client.sync_response_handler(list_vpc_response, "ListVpcsResponse", None)
+    response = client.sync_response_handler(list_vpc_response, "ListVpcsResponse", None, None)
 
     assert isinstance(response, ListVpcsResponse)
     assert len(response.vpcs) == 2
     assert response.vpcs[0].id == "0378f905-2ae8-4c75-a9fe-575ec11fddc9"
 
 
 if __name__ == "__main__":
```

## tests/test_signer.py

```diff
@@ -17,46 +17,159 @@
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
 import pytest
 
 from huaweicloudsdkcore.auth.credentials import BasicCredentials
+from huaweicloudsdkcore.exceptions.exceptions import SdkException
 from huaweicloudsdkcore.sdk_request import SdkRequest
-from huaweicloudsdkcore.signer.signer import Signer
+from huaweicloudsdkcore.signer.signer import Signer, DerivationAKSKSigner, SM3Signer, P256SHA256Signer, SM2SM3Signer
+from huaweicloudsdkcore.signer.utils import SM2SigningKey, P256SigningKey
 
 
 @pytest.fixture()
 def credentials():
-    ak = "my ak"
-    sk = "my sk"
-    project_id = "my project_id"
+    ak = "AccessKey"
+    sk = "SecretKey"
+    project_id = "ProjectId"
 
     credentials = BasicCredentials(ak, sk, project_id)
     yield credentials
 
 
 @pytest.fixture()
-def sdk_request():
+def sdk_request_get():
     sdk_request = SdkRequest(method="GET",
                              schema="https",
                              host="service.endpoint.myhuaweicloud.com",
                              resource_path="/resources",
                              query_params=[("size", "1")],
                              header_params={"X-Sdk-Date": "20200608T023900Z"},
                              body="")
     yield sdk_request
 
 
-def test_signer(credentials, sdk_request):
+@pytest.fixture()
+def sdk_request_post():
+    sdk_request = SdkRequest(method="POST",
+                             schema="https",
+                             host="service.endpoint.myhuaweicloud.com",
+                             resource_path="/resources",
+                             query_params=[("size", "1")],
+                             header_params={"X-Sdk-Date": "20200608T023900Z"},
+                             body='{"name":"test","id":1}')
+    yield sdk_request
+
+
+def test_signer1(credentials, sdk_request_get):
     signer = Signer(credentials)
-    signed_request = signer.sign(sdk_request)
-    print(signed_request)
+    signed_request = signer.sign(sdk_request_get)
+
+    assert 'SDK-HMAC-SHA256 Access=AccessKey, SignedHeaders=host;x-sdk-date, ' \
+           'Signature=cfb4171acec81de07d50e53d57eb77edd537414d66ddb1d7d780f128e12cd842' \
+           == signed_request.header_params.get("Authorization")
+
+
+def test_signer2(credentials, sdk_request_post):
+    signer = Signer(credentials)
+    signed_request = signer.sign(sdk_request_post)
+
+    assert 'SDK-HMAC-SHA256 Access=AccessKey, SignedHeaders=host;x-sdk-date, ' \
+           'Signature=436b1ac0a1ae03705934bb70ef2f2e09f7bfed2117d731a38235053199323a1f' \
+           == signed_request.header_params.get("Authorization")
+
+
+def test_sm3_signer1(credentials, sdk_request_get):
+    signer = SM3Signer(credentials)
+    try:
+        signed_request = signer.sign(sdk_request_get)
+
+        assert 'SDK-HMAC-SM3 Access=AccessKey, SignedHeaders=host;x-sdk-date, ' \
+               'Signature=f8ceb623f0be123dbccd7ad95a6211470f170d1d3c4fa9facbce716d82190e21' \
+               == signed_request.header_params.get("Authorization")
+    except SdkException as e:
+        assert "Signing algorithm SM3 is not supported in python2" == e.error_msg
+
+
+def test_sm3_signer2(credentials, sdk_request_post):
+    signer = SM3Signer(credentials)
+    try:
+        signed_request = signer.sign(sdk_request_post)
+
+        assert 'SDK-HMAC-SM3 Access=AccessKey, SignedHeaders=host;x-sdk-date, ' \
+               'Signature=6521b276625d7870e9836c041bafb2fa8d6a7ed0df045b06f1b137243c050ed8' \
+               == signed_request.header_params.get("Authorization")
+    except SdkException as e:
+        assert "Signing algorithm SM3 is not supported in python2" == e.error_msg
+
+
+def test_derived_signer1(credentials, sdk_request_get):
+    signer = DerivationAKSKSigner(credentials)
+    signed_request = signer.sign(sdk_request_get, derived_auth_service_name="demo", region_id="test-region-1")
+
+    assert 'V11-HMAC-SHA256 Credential=AccessKey/20200608/test-region-1/demo, ' \
+           'SignedHeaders=host;x-sdk-date, Signature=f7dfee056692e58dede80fc80cb89bbfabf45552dd7cd8d18a0a13484455b98e' \
+           == signed_request.header_params.get("Authorization")
+
+
+def test_derived_signer2(credentials, sdk_request_post):
+    signer = DerivationAKSKSigner(credentials)
+    signed_request = signer.sign(sdk_request_post, derived_auth_service_name="demo", region_id="test-region-1")
+
+    assert 'V11-HMAC-SHA256 Credential=AccessKey/20200608/test-region-1/demo, ' \
+           'SignedHeaders=host;x-sdk-date, Signature=8e2d91eaf9656ec5d6fab27812e2d898a35aaaa5e16ee0a0365c38527ccfb3cf' \
+           == signed_request.header_params.get("Authorization")
+
+
+def test_p256_signing_key(credentials):
+    signer = P256SHA256Signer(credentials)
+
+    signing_key = signer.get_signing_key()
+    assert isinstance(signing_key, P256SigningKey)
+
+    data = b'HelloWorld'
+    signature = signing_key.sign(data)
+    assert signing_key.verify(signature, data)
+
+
+def test_sm2_signing_key(credentials):
+    signer = SM2SM3Signer(credentials)
+
+    signing_key = signer.get_signing_key()
+    assert isinstance(signing_key, SM2SigningKey)
+
+    data = b'HelloWorld'
+    signature = signing_key.sign(data)
+    assert signing_key.verify(signature, data)
+
+
+def test_p256_sha256_signer1(credentials, sdk_request_get):
+    signer = P256SHA256Signer(credentials)
+    signed_request = signer.sign(sdk_request_get)
+
+    assert signed_request.header_params.get("Authorization").startswith("SDK-ECDSA-P256-SHA256")
+
+
+def test_p256_sha256_signer2(credentials, sdk_request_post):
+    signer = P256SHA256Signer(credentials)
+    signed_request = signer.sign(sdk_request_post)
+
+    assert signed_request.header_params.get("Authorization").startswith("SDK-ECDSA-P256-SHA256")
+
+
+def test_sm2_sm3_signer1(credentials, sdk_request_get):
+    signer = SM2SM3Signer(credentials)
+    signed_request = signer.sign(sdk_request_get)
+
+    assert signed_request.header_params.get("Authorization").startswith("SDK-SM2-SM3")
+
+
+def test_sm2_sm3_signer2(credentials, sdk_request_post):
+    signer = SM2SM3Signer(credentials)
+    signed_request = signer.sign(sdk_request_post)
 
-    assert signed_request.header_params.get("Authorization") == \
-           'SDK-HMAC-SHA256 Access=my ak, ' \
-           'SignedHeaders=host;x-sdk-date, ' \
-           'Signature=6d5bc610d3d4475346aae5cd7ed8d99585e60c0430a1d3d6e2f54e2bdd633701'
+    assert signed_request.header_params.get("Authorization").startswith("SDK-SM2-SM3")
 
 
 if __name__ == "__main__":
     pytest.main()
```

## tests/test_upload_download.py

```diff
@@ -15,31 +15,36 @@
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 
 import pytest
+from huaweicloudsdkcore.http.http_config import HttpConfig
 
 from huaweicloudsdkcore.auth.credentials import BasicCredentials
 from huaweicloudsdkcore.client import Client
 from huaweicloudsdkcore.sdk_stream_response import SdkStreamResponse
-from tests.data.file_response_mocker import mocked_file_response, mocked_file
+from tests.mocker.file_response_mocker import mocked_file_response, mocked_file
 
 
 def process_stream(stream):
     line_size = 0
     for line in stream.iter_lines(decode_unicode=True):
         if line:
             line_size += 1
     assert line_size == 2
 
 
 def test_upload_download(mocker):
-    client = Client().with_credentials(BasicCredentials("ak", "sk", "project_id")).with_endpoint("mock://test.com")
+    client = Client()\
+        .with_credentials(BasicCredentials("ak", "sk", "project_id"))\
+        .with_endpoints(["mock://test.com"])\
+        .with_config(HttpConfig.get_default_config())
+    client.init_http_client()
 
     mocker.patch.object(client, '_is_stream', return_value=True)
     mocker.patch.object(client, '_do_http_request_sync', return_value=mocked_file_response())
     mocker.patch.object(client, 'deserialize', return_value=SdkStreamResponse(mocked_file_response()))
 
     response = client.do_http_request(method="POST", resource_path="/",
                                       header_params={"Content-Type": "application/octet-stream"}, body=mocked_file(),
```

## tests/model/service/service_region.py

```diff
@@ -16,22 +16,22 @@
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
 import types
 
 from huaweicloudsdkcore.region.region import Region
-from tests.data.project_response_mocker import MOCK_ENDPOINT
+from tests.mocker.project_response_mocker import MOCK_ENDPOINT
 
 
 class ServiceRegion:
     def __init__(self):
         pass
 
-    CN_NORTH_7 = Region(id="cn-north-7", endpoint=MOCK_ENDPOINT)
+    CN_NORTH_7 = Region("cn-north-7", MOCK_ENDPOINT)
 
     static_fields = types.MappingProxyType({
         "cn-north-7": CN_NORTH_7,
     })
 
     @staticmethod
     def value_of(region_id, static_fields=static_fields):
```

## Comparing `huaweicloudsdkcore/utils/path_utils.py` & `huaweicloudsdkcore/signer/algorithm.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,9 +1,11 @@
-# coding: utf-8
+# coding= utf-8
 """
+ Copyright 2023 Huawei Technologies Co.,Ltd.
+
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache LICENSE, Version 2.0 (the
  "LICENSE"); you may not use this file except in compliance
  with the LICENSE.  You may obtain a copy of the LICENSE at
@@ -13,25 +15,25 @@
  Unless required by applicable law or agreed to in writing,
  software distributed under the LICENSE is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the LICENSE for the
  specific language governing permissions and limitations
  under the LICENSE.
 """
-import os
-from sys import platform
-
-
-def get_home_path():
-    home_path = None
-    if platform.startswith("win32"):
-        home_path = os.environ.get("USERPROFILE")
-    elif platform.startswith("linux") or platform.startswith("darwin"):
-        home_path = os.environ.get("HOME")
-
-    return home_path
 
+try:
+    from enum import Enum
 
-def is_path_exist(path):
-    if not path:
-        return False
-    return os.path.exists(path)
+    _ENUM_CLS = Enum
+except ImportError:
+    _ENUM_CLS = object
+
+
+class SigningAlgorithm(_ENUM_CLS):
+    HMAC_SHA256 = 1
+    HMAC_SM3 = 2
+    ECDSA_P256_SHA256 = 3
+    SM2_SM3 = 4
+
+    @classmethod
+    def get_default(cls):
+        return cls.HMAC_SHA256
```

## Comparing `huaweicloudsdkcore-3.1.9.dist-info/LICENSE` & `huaweicloudsdkcore-3.1.90.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `huaweicloudsdkcore-3.1.9.dist-info/METADATA` & `huaweicloudsdkcore-3.1.90.dist-info/METADATA`

 * *Files 17% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: huaweicloudsdkcore
-Version: 3.1.9
+Version: 3.1.90
 Summary: HuaweiCloud SDK Python Core
 Home-page: https://github.com/huaweicloud/huaweicloud-sdk-python-v3
 Author: HuaweiCloud SDK
 Author-email: hwcloudsdk@huawei.com
 License: Apache LICENSE 2.0
 Keywords: huaweicloud,sdk,core
 Platform: any
@@ -19,17 +19,19 @@
 Classifier: Programming Language :: Python :: 3.7
 Classifier: Programming Language :: Python :: 3.8
 Classifier: Programming Language :: Python :: 3.9
 Classifier: Topic :: Software Development
 Requires-Python: >=2.7,!=3.0.*,!=3.1.*,!=3.2.*
 Description-Content-Type: text/markdown
 License-File: LICENSE
-Requires-Dist: six (>=1.16.0)
-Requires-Dist: requests-futures
-Requires-Dist: simplejson (<=3.17.0)
-Requires-Dist: requests-toolbelt (==0.10.1)
-Requires-Dist: PyYAML (>=5.4.1)
+Requires-Dist: requests-toolbelt >=0.10.1
+Requires-Dist: six >=1.16.0
+Requires-Dist: simplejson >=3.18.0
+Requires-Dist: PyYAML >=5.4.1
+Requires-Dist: pyasn1 >=0.5.0
+Requires-Dist: typing-extensions
 Provides-Extra: python_version_2.7_
-Requires-Dist: futures (>=3.3.0) ; extra == 'python_version_2.7_'
-Requires-Dist: configparser (>=4.0.2) ; extra == 'python_version_2.7_'
+Requires-Dist: futures >=3.3.0 ; extra == 'python_version_2.7_'
+Requires-Dist: configparser >=4.0.2 ; extra == 'python_version_2.7_'
+Requires-Dist: certifi >=2022.12.7 ; extra == 'python_version_2.7_'
 
 See detailed information in [huaweicloud-sdk-python-v3](https://github.com/huaweicloud/huaweicloud-sdk-python-v3).
```

## Comparing `huaweicloudsdkcore-3.1.9.dist-info/RECORD` & `huaweicloudsdkcore-3.1.90.dist-info/RECORD`

 * *Files 20% similar despite different names*

```diff
@@ -1,55 +1,74 @@
 huaweicloudsdkcore/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-huaweicloudsdkcore/client.py,sha256=HWEH3QSgnR5D5FRMPBka2xp4oR40-X3jjuQnxtAMqTg,22007
-huaweicloudsdkcore/sdk_request.py,sha256=l5cflfRoRKnucVCJQCKEG-TajxRNw5NXD1HlV35c0mw,1283
-huaweicloudsdkcore/sdk_response.py,sha256=NSLIguoB42mPLtgnAyeYZH8aslw5a_ZWQVgLWXpcrlQ,2388
-huaweicloudsdkcore/sdk_stream_request.py,sha256=tyXBUlpk1CTztouPkDh22N9TDzBcPKubw1KjmQEVdV8,951
-huaweicloudsdkcore/sdk_stream_response.py,sha256=w0W4qjkSR6CZr9mSk5u4OfbRRx6ZBMHKK3ZKJVgL0LI,1142
+huaweicloudsdkcore/client.py,sha256=89mRnpH-DTTbfyM7QYW8To4Kx6NxLCdNv51oYckNdcc,29157
+huaweicloudsdkcore/sdk_request.py,sha256=xH8N6Z0wpISkNyGt8tfH8GUkM-ouy-nyd0aVp4_S7XQ,3221
+huaweicloudsdkcore/sdk_response.py,sha256=fHbXM7DumOjGSsvW-pvbNFOP5IZ49h39yoguYIXefTo,2225
+huaweicloudsdkcore/sdk_stream_request.py,sha256=ysrXHXzJ6HS2joEuSBgp63_tSsp4cV0GKuJGPOcS3Tk,997
+huaweicloudsdkcore/sdk_stream_response.py,sha256=OAtDUoQ_ymGMUkN5GnIb0ztSYdxTI-_xOGBKLN9I5jk,1188
 huaweicloudsdkcore/auth/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-huaweicloudsdkcore/auth/cache.py,sha256=XmIiSrkvSUI_F-ZRWGBZkMhMo1nLrlWrngTJkjfBKQ4,1070
-huaweicloudsdkcore/auth/credentials.py,sha256=X1nS5b-7ij_61sDTyPhRTVBa_jjy9hDPWBw52yllHWU,12950
-huaweicloudsdkcore/auth/internal.py,sha256=VhquDKYlR6KFaje-E96pezIIjCmFAWUo8cl3bjbNEzo,8173
-huaweicloudsdkcore/auth/provider.py,sha256=LMoxIq8SO1Oozcd-pQocD6XHrrVf7ZfI4h6VpQxsXq0,8955
+huaweicloudsdkcore/auth/cache.py,sha256=weioCGXjXpGbJjT9wYAx1bBTK4IG-Gn7e1kM0DdRxuE,1116
+huaweicloudsdkcore/auth/credentials.py,sha256=186Agp6vFoWGElD_IBQ749t8vFS25ZsbsmQjxobq-ek,14444
+huaweicloudsdkcore/auth/internal.py,sha256=l1vgh8PKqNbVDCNzzr-d7g-v4CsYr3On1UD_KoEnhTU,9104
+huaweicloudsdkcore/auth/provider.py,sha256=1TG-_bfyoIROAsQ3A2KMXI10OnxB8FyGz33xtlvnW4U,8993
 huaweicloudsdkcore/exceptions/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-huaweicloudsdkcore/exceptions/exceptions.py,sha256=5tX9Gnt9wPiEIPDXEp5UaAQIKofjlHGjN2H-TDdYeyI,7464
+huaweicloudsdkcore/exceptions/exception_handler.py,sha256=xkH5mwJ8nxR7akplRoAbJyB6wCuRsTGQqElNjZI9TzA,4581
+huaweicloudsdkcore/exceptions/exceptions.py,sha256=ri6MzJ3HL_W_DV0U2Qs453pOdUnhlvez1FQbAe1Kjmc,6398
 huaweicloudsdkcore/http/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-huaweicloudsdkcore/http/formdata.py,sha256=FGSxxN9mMbTPZY_zbkWaVaHLL0NyLF8rO9VLAxU8uQY,1825
-huaweicloudsdkcore/http/http_client.py,sha256=IXas96ePslx0RiYCZWZegRZPHFsH-LjJxl8tXL88VR4,8231
-huaweicloudsdkcore/http/http_config.py,sha256=mfZ9GNltkWocmcI-xjFU5wpeDg4HcmRImXsSxSFBZTw,4040
-huaweicloudsdkcore/http/http_handler.py,sha256=49dm9SX0EuLB_tZGXoquxeopo-PMLHVVLBQGOPfSsz4,1842
-huaweicloudsdkcore/http/primitive_types.py,sha256=o9NkRqCLpiRy1P1VF-lPsNYgeUtr7YOVW_NaKUSlZcY,1173
+huaweicloudsdkcore/http/formdata.py,sha256=jikOt3XgUokpluMk88Tq9qPHmQy4eMtyNIEU9foUL_8,2258
+huaweicloudsdkcore/http/future_session.py,sha256=0R5QBnHQHCPkiSzxIBsp1sq-g8CdUZ9ITcHFWUJ8cAo,1176
+huaweicloudsdkcore/http/http_client.py,sha256=avbsZbmmmEKUFU2R6_f7CgUHacHGgk5ZB7ftHKXdn4o,5021
+huaweicloudsdkcore/http/http_config.py,sha256=5W7PZQR7igU-NWDkJmTjrz2Kjv5xAGX3GoMC8WjWQuw,5048
+huaweicloudsdkcore/http/http_handler.py,sha256=ZSDFgd5y09RLDerGF029n-GSXO8JXRm0GstkmmUBFGE,2224
+huaweicloudsdkcore/http/primitive_types.py,sha256=aJ4J0EcqGChjLk3q4Dycz2sSXTXMec04d8kBsc1Ekdo,1218
+huaweicloudsdkcore/http/progress.py,sha256=0vp5NsJ5mqjp0osCcUyS3Rc7DBQMDW1HvFfgr3_dyLE,4009
+huaweicloudsdkcore/invoker/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+huaweicloudsdkcore/invoker/invoker.py,sha256=0VnSHeELytAP4LTteowl2N9sz7nCx3zajNXHQB1a9Tg,2625
 huaweicloudsdkcore/region/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-huaweicloudsdkcore/region/cache.py,sha256=DZa9mzNsVfD7UmXlWf4Tbtciv_Sg2jcpBfeDIgffuIE,2512
-huaweicloudsdkcore/region/provider.py,sha256=ArLrWNKEUgpKdbJZzPpMy5_B9YMsSjoFy8d4Ny2nEFo,2611
-huaweicloudsdkcore/region/region.py,sha256=hHhPrQG6oWz_05qUY5m3RatNSQ_AD8itKZEBMp20Og4,1423
+huaweicloudsdkcore/region/cache.py,sha256=UoMMo0yqR-YeVpBLh9fSD7FkOhV_5Tp9NyJmM8XQaYE,2778
+huaweicloudsdkcore/region/provider.py,sha256=as9mOPJyKmGV1PZdevbAMuwlLE-wwiv0rGv9BJetHLw,2699
+huaweicloudsdkcore/region/region.py,sha256=6e4wTTjTUEWXaGNxGL5iUu2qrEmi0X9mJEeAfOW318o,3149
 huaweicloudsdkcore/signer/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-huaweicloudsdkcore/signer/hkdf.py,sha256=-hcZjSQqttuwKmWFn2_XFIUJrTnztZkropJccNsgZp8,2722
-huaweicloudsdkcore/signer/signer.py,sha256=UJkfT8jmCxVfUZOBr7jrAe2JpCFRkWF8YiDZ9WQDUpY,9274
+huaweicloudsdkcore/signer/algorithm.py,sha256=tZxBZfiLGnvMQ2UM9mXmAjI3vQvOFvDIWp-sCWYSRdk,1129
+huaweicloudsdkcore/signer/hkdf.py,sha256=aFWQQ4oF89Jt7abzSNnzOF3IDGiFS6DDg-Z6zI7uX64,3757
+huaweicloudsdkcore/signer/signer.py,sha256=ZJz2IeeTL_UlcZC7W1jcORYgmE7pWBxi2L6tVgbUmWI,14108
+huaweicloudsdkcore/signer/utils.py,sha256=nyDVQ8_SQPRhGUzTW59kkM8APrYE3u5UjeyU-4bttlQ,14260
 huaweicloudsdkcore/utils/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-huaweicloudsdkcore/utils/core_utils.py,sha256=eFtEo0yIPcmiTpBDosNXfCiHXp-eZGzN0oZDZTfztc4,893
-huaweicloudsdkcore/utils/http_utils.py,sha256=08tRwjjqDrxZdtiUp5d8Z-vbRg-1Qdxfv_WpN9gbo_U,4329
-huaweicloudsdkcore/utils/path_utils.py,sha256=bFluZTfds63qsSCWKyrRbBL7jhWvG9__SQVPntzeLYM,1195
-huaweicloudsdkcore/utils/six_utils.py,sha256=E9HrQQugcdfmdBGDYQEeVOjSJZnR7fUggynPUKRs5bQ,1418
-huaweicloudsdkcore/utils/string_utils.py,sha256=7v53CyMHnMjn-pi51dTTe1P8gANhmzaR43Qjx_Epid4,1289
-huaweicloudsdkcore/utils/time_utils.py,sha256=0WjdYkwumqduGWnZxZ13QjUIiD4BOAb2B2-oVt5PM64,203
+huaweicloudsdkcore/utils/core_utils.py,sha256=2nqfxSa1biPa2_kQ_QWkN1P6YbYeVPAj4EDOa3CGGFw,939
+huaweicloudsdkcore/utils/filepath_utils.py,sha256=nk4qWvShhHo3_qW28Z2cmbo4Hbm7yJzibUTUEdCjzV0,1699
+huaweicloudsdkcore/utils/http_utils.py,sha256=60HggoS_sDaIkbP5LeGcdI9llDOf7Kad515XNEo7DIU,4405
+huaweicloudsdkcore/utils/six_utils.py,sha256=T9cOhuUihcp2hHMN2uLo3mnxoG2zPvmHnzf0KygQMLw,1596
+huaweicloudsdkcore/utils/string_utils.py,sha256=A7mYk6tFfbuybbutWeASuEBJ0g-XGAguqNdKBnfZfzg,1335
+huaweicloudsdkcore/utils/time_utils.py,sha256=Yitio1m25DvjyRMEDEqk13N9IrlbFPUkkHJjgwNHnhM,1046
+huaweicloudsdkcore/utils/xml_utils.py,sha256=KvqAnR1dBC_fqnFgiuqDsvhIvIHC86JQN04avp6uXAY,6407
 tests/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-tests/test_client_build.py,sha256=JF5YtqMzsNM1psfuCN8WCuY1c4Ys7TYCxipC_gro4O4,3499
-tests/test_credential_provider.py,sha256=BtRM3ARU4WJNmr5q5bxxQmJKTEikJFii0OCmb4Awhcc,9160
-tests/test_endpoint_without_scheme.py,sha256=dv9V3cs-7q6O9CaIMqXEdOyvnUAT-PNbu4B8eb--L1U,1608
+tests/test_client.py,sha256=iucwUNGOn1-Moo9sNvduJw9YM13qTfAjb_MVLX-cO7g,3612
+tests/test_client_build.py,sha256=NBowqGq48yXpf_k5syJY727WORsMpl1OGB72PlSbyzA,3528
+tests/test_credential_provider.py,sha256=uA9mwAJuclz015cSnuMW7__55zU2J05ykKGBnvMuuAY,9195
+tests/test_credentials.py,sha256=Ahue_NYSy1u1chyUupWNjl2opzQs1Au_qjh9if5jx20,2893
+tests/test_endpoint_without_scheme.py,sha256=HDpcUCr7F4Zy-mMNA8-c9Y6CFSuoa_SrNcpA1MY39ys,1615
+tests/test_extract_error_message.py,sha256=bdnefq-30Oif9m70kB6SGc0g4VgeltqfV--UYMHQw6s,4109
 tests/test_federal_credentials.py,sha256=gccvZQtgHu1biYioiu9wmhWcED6BmR7aF1qNij75WvI,3181
-tests/test_region_provider.py,sha256=I-kIQKPVhOp56mum5DEsD64vmwjey5Zu2X1O7EcxcaU,3798
-tests/test_region_with_project_id.py,sha256=9b-vh_S4DA5k8vxtQnHoYMvWxNfdWDdYhwNt05Ny-Xs,3909
-tests/test_region_without_project_id.py,sha256=vUIhfip9RnWabea6cBV5HfVrryxS7vNowJw49e5n-RQ,2355
-tests/test_request_and_exceptions.py,sha256=TVdD8OgQgUuSs2qy4r0QXCXIZh1uaE5RNJYDJ7LfvF0,7306
-tests/test_signer.py,sha256=sRkHc4Z4GUw_EOGIL5KGnmViBdj_Y2JBxADdSv10LRA,2065
-tests/test_upload_download.py,sha256=FDQFtaK8QaNtoI7uuxra6sj_i6GbtRvUwmgepNcF0Mw,2022
+tests/test_new_region.py,sha256=J_-h-2720w5xdqdT1vMQcJO0_SfZIedkhLWetZZ1d14,1446
+tests/test_parse_body.py,sha256=MuX9GnibjTMsJL__aEOjbRGVFUaOpnODZF6_KScSVvQ,2255
+tests/test_region_provider.py,sha256=Ui3mS3ldHPttE7OfyKVH8YzbXkn2VIeknu7uTE8B0sk,3571
+tests/test_region_with_project_id.py,sha256=TbKZJA27ZDCnA1xHsS5nSxRuFO0OX95AachSD4VSv68,3924
+tests/test_region_without_project_id.py,sha256=NhAC99BiZbVxsV8-ivNM9Qcoh33vcbPPJA2Uzi5fprs,2357
+tests/test_request_and_exceptions.py,sha256=kw4t5KKbLSZJ8O7n3rdF9YBy6T9X73w33yrHJkj5xKc,7315
+tests/test_signer.py,sha256=ncPWo0yUF1uOwN4f2wKguU7GoDQH2BGHkQ5RPAQRIRg,6652
+tests/test_upload_download.py,sha256=kaP3R9iok6JKG2HmK0-tNq3dJyOv0y7raAsR703nCX4,2191
+tests/test_xml_transfer.py,sha256=6HckC917TpyPdeK_ZX7cx8SjHfww4Lpn9rjoCEVSVX8,3575
+tests/mocker/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+tests/mocker/file_response_mocker.py,sha256=fvXCfPSJMpPYVpFCLOCVua1Nsj47i1mUCnsto4ZufDE,1241
+tests/mocker/project_response_mocker.py,sha256=EAZso0zNsq47q4yOkDDfFh-3hKyhzSzyfUeZLblS6LU,1446
 tests/model/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+tests/model/obs/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+tests/model/obs/model.py,sha256=DpbeL14bP0yj-nBJ8XMVcI28X2vX_u2GR7rAFKQXIUg,4790
 tests/model/service/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 tests/model/service/service_client.py,sha256=zRb-uY5M6Rn5T8EyTnStfKVHI-RhFg958QEFVyi6MA0,1449
-tests/model/service/service_region.py,sha256=SQMU4zTCMvitX_a2N-exuhbmQBIRYynoxSCNFqPiXDI,1486
+tests/model/service/service_region.py,sha256=BUp6DGTcpWdS8FakeWjT-7gInccEeWaGY-M8JooQYo8,1476
 tests/model/vpc/__init__.py,sha256=32y3Q_madKrB9Rx0xWoVeH-h74b2LTR3vj8aon99Tn0,76
 tests/model/vpc/list_vpcs_response.py,sha256=6QfL-UOCOS3qj0HPVnjASLzrBs8GBuZdE950Ypxqbyc,2388
-huaweicloudsdkcore-3.1.9.dist-info/LICENSE,sha256=4_VSTLuxcsybRG9N4Isktlj1rAIBBsfl0Tjc0gBTijo,604
-huaweicloudsdkcore-3.1.9.dist-info/METADATA,sha256=3jPwbrpkol0vUuj_mm_raWlFK22Qrk7rZl3PbabDlII,1478
-huaweicloudsdkcore-3.1.9.dist-info/WHEEL,sha256=80-DJ2LKJ1J1HZBp_8xaVylYn7Z7dOPLIAOHWs5d_ss,110
-huaweicloudsdkcore-3.1.9.dist-info/top_level.txt,sha256=G1uWwkgpMrek8SJY4DiKG_-hjF9ox9jpqSRnxq5VZX4,25
-huaweicloudsdkcore-3.1.9.dist-info/RECORD,,
+huaweicloudsdkcore-3.1.90.dist-info/LICENSE,sha256=4_VSTLuxcsybRG9N4Isktlj1rAIBBsfl0Tjc0gBTijo,604
+huaweicloudsdkcore-3.1.90.dist-info/METADATA,sha256=p0PChZvk8D8nCvi9FXN7q7p-KC5Tda6GTJw9kPPNiXA,1566
+huaweicloudsdkcore-3.1.90.dist-info/WHEEL,sha256=DZajD4pwLWue70CAfc7YaxT1wLUciNBvN_TTcvXpltE,110
+huaweicloudsdkcore-3.1.90.dist-info/top_level.txt,sha256=G1uWwkgpMrek8SJY4DiKG_-hjF9ox9jpqSRnxq5VZX4,25
+huaweicloudsdkcore-3.1.90.dist-info/RECORD,,
```

