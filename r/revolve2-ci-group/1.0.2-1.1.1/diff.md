# Comparing `tmp/revolve2_ci_group-1.0.2-cp311-cp311-win_amd64.whl.zip` & `tmp/revolve2_ci_group-1.1.1-cp310-cp310-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.zip`

## zipinfo {}

```diff
@@ -1,43 +1,56 @@
-Zip file size: 194263 bytes, number of entries: 41
--rw-r--r--  2.0 fat       97 b- defN 80-Jan-01 00:00 revolve2/ci_group/__init__.py
--rw-r--r--  2.0 fat      176 b- defN 80-Jan-01 00:00 revolve2/ci_group/ci_lab_utilities/__init__.py
--rw-r--r--  2.0 fat     3237 b- defN 80-Jan-01 00:00 revolve2/ci_group/ci_lab_utilities/_calibrate_camera.py
--rw-r--r--  2.0 fat     6393 b- defN 80-Jan-01 00:00 revolve2/ci_group/ci_lab_utilities/_ip_camera.py
--rw-r--r--  2.0 fat      744 b- defN 80-Jan-01 00:00 revolve2/ci_group/fitness_functions.py
--rw-r--r--  2.0 fat       46 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/__init__.py
--rw-r--r--  2.0 fat      106 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/__init__.py
--rw-r--r--  2.0 fat      838 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/_multineat_genotype_pickle_wrapper.py
--rw-r--r--  2.0 fat      373 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/_multineat_rng_from_random.py
--rw-r--r--  2.0 fat     1687 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/_random_multineat_genotype.py
--rw-r--r--  2.0 fat      332 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/__init__.py
--rw-r--r--  2.0 fat     2755 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_cpg_network_neighbor_v1.py
--rw-r--r--  2.0 fat     3865 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg.py
--rw-r--r--  2.0 fat     4343 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg_orm.py
--rw-r--r--  2.0 fat     1878 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/_multineat_params.py
--rw-r--r--  2.0 fat      197 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/__init__.py
--rw-r--r--  2.0 fat     4885 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_develop.py
--rw-r--r--  2.0 fat     4185 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_orm_v1.py
--rw-r--r--  2.0 fat     3701 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_v1.py
--rw-r--r--  2.0 fat      197 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/__init__.py
--rw-r--r--  2.0 fat     5209 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_develop.py
--rw-r--r--  2.0 fat     4185 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_orm_v2.py
--rw-r--r--  2.0 fat     3701 b- defN 80-Jan-01 00:00 revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_v2.py
--rw-r--r--  2.0 fat    29664 b- defN 80-Jan-01 00:00 revolve2/ci_group/modular_robots_v1.py
--rw-r--r--  2.0 fat     1795 b- defN 80-Jan-01 00:00 revolve2/ci_group/modular_robots_v2.py
--rw-r--r--  2.0 fat    20093 b- defN 80-Jan-01 00:00 revolve2/ci_group/morphological_measures.py
--rw-r--r--  2.0 fat      413 b- defN 80-Jan-01 00:00 revolve2/ci_group/morphological_novelty_metric/__init__.py
--rw-r--r--  2.0 fat     1515 b- defN 80-Jan-01 00:00 revolve2/ci_group/morphological_novelty_metric/_build_cmodule.py
--rw-r--r--  2.0 fat     2996 b- defN 80-Jan-01 00:00 revolve2/ci_group/morphological_novelty_metric/_calculate_novelty.pyx
--rw-r--r--  2.0 fat     4032 b- defN 80-Jan-01 00:00 revolve2/ci_group/morphological_novelty_metric/_coordinate_operations.py
--rw-r--r--  2.0 fat     5601 b- defN 80-Jan-01 00:00 revolve2/ci_group/morphological_novelty_metric/_morphological_novelty_metric.py
--rw-r--r--  2.0 fat   167424 b- defN 80-Jan-01 00:00 revolve2/ci_group/morphological_novelty_metric/calculate_novelty.cp310-win_amd64.pyd
--rw-r--r--  2.0 fat   163840 b- defN 80-Jan-01 00:00 revolve2/ci_group/morphological_novelty_metric/calculate_novelty.cp311-win_amd64.pyd
--rw-r--r--  2.0 fat      260 b- defN 80-Jan-01 00:00 revolve2/ci_group/morphological_novelty_metric/calculate_novelty.pyi
--rw-r--r--  2.0 fat     5944 b- defN 80-Jan-01 00:00 revolve2/ci_group/planar_robot_representation.py
--rw-r--r--  2.0 fat        0 b- defN 80-Jan-01 00:00 revolve2/ci_group/py.typed
--rw-r--r--  2.0 fat     1209 b- defN 80-Jan-01 00:00 revolve2/ci_group/simulation_parameters.py
--rw-r--r--  2.0 fat     4287 b- defN 80-Jan-01 00:00 revolve2/ci_group/terrains.py
--rw-r--r--  2.0 fat     3486 b- defN 80-Jan-01 00:00 revolve2_ci_group-1.0.2.dist-info/METADATA
--rw-r--r--  2.0 fat       98 b- defN 80-Jan-01 00:00 revolve2_ci_group-1.0.2.dist-info/WHEEL
-?rw-r--r--  2.0 fat     4666 b- defN 16-Jan-01 00:00 revolve2_ci_group-1.0.2.dist-info/RECORD
-41 files, 470453 bytes uncompressed, 186333 bytes compressed:  60.4%
+Zip file size: 502618 bytes, number of entries: 54
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2_ci_group.libs/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2_ci_group-1.1.1.dist-info/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2/
+-rw-r--r--  2.0 unx     3504 b- defN 24-Apr-03 11:18 revolve2_ci_group-1.1.1.dist-info/METADATA
+-rw-r--r--  2.0 unx      149 b- defN 24-Apr-03 11:18 revolve2_ci_group-1.1.1.dist-info/WHEEL
+-rw-r--r--  2.0 unx     4787 b- defN 24-Apr-03 11:18 revolve2_ci_group-1.1.1.dist-info/RECORD
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2/ci_group/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2/ci_group/morphological_novelty_metric/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2/ci_group/ci_lab_utilities/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2/ci_group/genotypes/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2/ci_group/interactive_objects/
+-rw-r--r--  2.0 unx    28859 b- defN 24-Apr-03 11:18 revolve2/ci_group/modular_robots_v1.py
+-rw-r--r--  2.0 unx    19483 b- defN 24-Apr-03 11:18 revolve2/ci_group/morphological_measures.py
+-rw-r--r--  2.0 unx      721 b- defN 24-Apr-03 11:18 revolve2/ci_group/fitness_functions.py
+-rw-r--r--  2.0 unx       96 b- defN 24-Apr-03 11:18 revolve2/ci_group/__init__.py
+-rw-r--r--  2.0 unx     5754 b- defN 24-Apr-03 11:18 revolve2/ci_group/planar_robot_representation.py
+-rw-r--r--  2.0 unx     6585 b- defN 24-Apr-03 11:18 revolve2/ci_group/modular_robots_v2.py
+-rw-r--r--  2.0 unx        0 b- defN 24-Apr-03 11:18 revolve2/ci_group/py.typed
+-rw-r--r--  2.0 unx     4188 b- defN 24-Apr-03 11:18 revolve2/ci_group/terrains.py
+-rw-r--r--  2.0 unx     1180 b- defN 24-Apr-03 11:18 revolve2/ci_group/simulation_parameters.py
+-rw-r--r--  2.0 unx     5468 b- defN 24-Apr-03 11:18 revolve2/ci_group/morphological_novelty_metric/_morphological_novelty_metric.py
+-rw-r--r--  2.0 unx      252 b- defN 24-Apr-03 11:18 revolve2/ci_group/morphological_novelty_metric/calculate_novelty.pyi
+-rw-r--r--  2.0 unx      401 b- defN 24-Apr-03 11:18 revolve2/ci_group/morphological_novelty_metric/__init__.py
+-rw-r--r--  2.0 unx     2915 b- defN 24-Apr-03 11:18 revolve2/ci_group/morphological_novelty_metric/_calculate_novelty.pyx
+-rw-r--r--  2.0 unx     1456 b- defN 24-Apr-03 11:18 revolve2/ci_group/morphological_novelty_metric/_build_cmodule.py
+-rw-r--r--  2.0 unx     3919 b- defN 24-Apr-03 11:18 revolve2/ci_group/morphological_novelty_metric/_coordinate_operations.py
+-rwxr-xr-x  2.0 unx  1517536 b- defN 24-Apr-03 11:18 revolve2/ci_group/morphological_novelty_metric/calculate_novelty.cpython-310-x86_64-linux-gnu.so
+-rw-r--r--  2.0 unx     6204 b- defN 24-Apr-03 11:18 revolve2/ci_group/ci_lab_utilities/_ip_camera.py
+-rw-r--r--  2.0 unx     3154 b- defN 24-Apr-03 11:18 revolve2/ci_group/ci_lab_utilities/_calibrate_camera.py
+-rw-r--r--  2.0 unx      172 b- defN 24-Apr-03 11:18 revolve2/ci_group/ci_lab_utilities/__init__.py
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/
+-rw-r--r--  2.0 unx       45 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/__init__.py
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/
+-rw-r--r--  2.0 unx     1728 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/_random_multineat_genotype.py
+-rw-r--r--  2.0 unx      809 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/_multineat_genotype_pickle_wrapper.py
+-rw-r--r--  2.0 unx      101 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/__init__.py
+-rw-r--r--  2.0 unx      359 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/_multineat_rng_from_random.py
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/
+drwxr-xr-x  2.0 unx        0 b- stor 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/
+-rw-r--r--  2.0 unx     2669 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_cpg_network_neighbor_v1.py
+-rw-r--r--  2.0 unx     1831 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/_multineat_params.py
+-rw-r--r--  2.0 unx     3744 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg.py
+-rw-r--r--  2.0 unx      321 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/__init__.py
+-rw-r--r--  2.0 unx     4208 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg_orm.py
+-rw-r--r--  2.0 unx      193 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/__init__.py
+-rw-r--r--  2.0 unx     4052 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_orm_v1.py
+-rw-r--r--  2.0 unx     4721 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_develop.py
+-rw-r--r--  2.0 unx     3583 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_v1.py
+-rw-r--r--  2.0 unx     4048 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_orm_v2.py
+-rw-r--r--  2.0 unx     3579 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_v2.py
+-rw-r--r--  2.0 unx      193 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/__init__.py
+-rw-r--r--  2.0 unx     5919 b- defN 24-Apr-03 11:18 revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_develop.py
+-rw-r--r--  2.0 unx      108 b- defN 24-Apr-03 11:18 revolve2/ci_group/interactive_objects/__init__.py
+-rw-r--r--  2.0 unx     1235 b- defN 24-Apr-03 11:18 revolve2/ci_group/interactive_objects/_ball.py
+54 files, 1660229 bytes uncompressed, 492806 bytes compressed:  70.3%
```

## zipnote {}

```diff
@@ -1,124 +1,163 @@
-Filename: revolve2/ci_group/__init__.py
+Filename: revolve2_ci_group.libs/
 Comment: 
 
-Filename: revolve2/ci_group/ci_lab_utilities/__init__.py
+Filename: revolve2_ci_group-1.1.1.dist-info/
 Comment: 
 
-Filename: revolve2/ci_group/ci_lab_utilities/_calibrate_camera.py
+Filename: revolve2/
 Comment: 
 
-Filename: revolve2/ci_group/ci_lab_utilities/_ip_camera.py
+Filename: revolve2_ci_group-1.1.1.dist-info/METADATA
+Comment: 
+
+Filename: revolve2_ci_group-1.1.1.dist-info/WHEEL
+Comment: 
+
+Filename: revolve2_ci_group-1.1.1.dist-info/RECORD
+Comment: 
+
+Filename: revolve2/ci_group/
+Comment: 
+
+Filename: revolve2/ci_group/morphological_novelty_metric/
+Comment: 
+
+Filename: revolve2/ci_group/ci_lab_utilities/
+Comment: 
+
+Filename: revolve2/ci_group/genotypes/
+Comment: 
+
+Filename: revolve2/ci_group/interactive_objects/
+Comment: 
+
+Filename: revolve2/ci_group/modular_robots_v1.py
+Comment: 
+
+Filename: revolve2/ci_group/morphological_measures.py
 Comment: 
 
 Filename: revolve2/ci_group/fitness_functions.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/__init__.py
+Filename: revolve2/ci_group/__init__.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/__init__.py
+Filename: revolve2/ci_group/planar_robot_representation.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/_multineat_genotype_pickle_wrapper.py
+Filename: revolve2/ci_group/modular_robots_v2.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/_multineat_rng_from_random.py
+Filename: revolve2/ci_group/py.typed
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/_random_multineat_genotype.py
+Filename: revolve2/ci_group/terrains.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/__init__.py
+Filename: revolve2/ci_group/simulation_parameters.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_cpg_network_neighbor_v1.py
+Filename: revolve2/ci_group/morphological_novelty_metric/_morphological_novelty_metric.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg.py
+Filename: revolve2/ci_group/morphological_novelty_metric/calculate_novelty.pyi
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg_orm.py
+Filename: revolve2/ci_group/morphological_novelty_metric/__init__.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/_multineat_params.py
+Filename: revolve2/ci_group/morphological_novelty_metric/_calculate_novelty.pyx
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/__init__.py
+Filename: revolve2/ci_group/morphological_novelty_metric/_build_cmodule.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_develop.py
+Filename: revolve2/ci_group/morphological_novelty_metric/_coordinate_operations.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_orm_v1.py
+Filename: revolve2/ci_group/morphological_novelty_metric/calculate_novelty.cpython-310-x86_64-linux-gnu.so
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_v1.py
+Filename: revolve2/ci_group/ci_lab_utilities/_ip_camera.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/__init__.py
+Filename: revolve2/ci_group/ci_lab_utilities/_calibrate_camera.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_develop.py
+Filename: revolve2/ci_group/ci_lab_utilities/__init__.py
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_orm_v2.py
+Filename: revolve2/ci_group/genotypes/cppnwin/
 Comment: 
 
-Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_v2.py
+Filename: revolve2/ci_group/genotypes/__init__.py
 Comment: 
 
-Filename: revolve2/ci_group/modular_robots_v1.py
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/
 Comment: 
 
-Filename: revolve2/ci_group/modular_robots_v2.py
+Filename: revolve2/ci_group/genotypes/cppnwin/_random_multineat_genotype.py
 Comment: 
 
-Filename: revolve2/ci_group/morphological_measures.py
+Filename: revolve2/ci_group/genotypes/cppnwin/_multineat_genotype_pickle_wrapper.py
 Comment: 
 
-Filename: revolve2/ci_group/morphological_novelty_metric/__init__.py
+Filename: revolve2/ci_group/genotypes/cppnwin/__init__.py
 Comment: 
 
-Filename: revolve2/ci_group/morphological_novelty_metric/_build_cmodule.py
+Filename: revolve2/ci_group/genotypes/cppnwin/_multineat_rng_from_random.py
 Comment: 
 
-Filename: revolve2/ci_group/morphological_novelty_metric/_calculate_novelty.pyx
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/
 Comment: 
 
-Filename: revolve2/ci_group/morphological_novelty_metric/_coordinate_operations.py
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/
 Comment: 
 
-Filename: revolve2/ci_group/morphological_novelty_metric/_morphological_novelty_metric.py
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_cpg_network_neighbor_v1.py
+Comment: 
+
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/_multineat_params.py
 Comment: 
 
-Filename: revolve2/ci_group/morphological_novelty_metric/calculate_novelty.cp310-win_amd64.pyd
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg.py
 Comment: 
 
-Filename: revolve2/ci_group/morphological_novelty_metric/calculate_novelty.cp311-win_amd64.pyd
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/__init__.py
 Comment: 
 
-Filename: revolve2/ci_group/morphological_novelty_metric/calculate_novelty.pyi
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg_orm.py
 Comment: 
 
-Filename: revolve2/ci_group/planar_robot_representation.py
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/__init__.py
 Comment: 
 
-Filename: revolve2/ci_group/py.typed
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_orm_v1.py
 Comment: 
 
-Filename: revolve2/ci_group/simulation_parameters.py
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_develop.py
 Comment: 
 
-Filename: revolve2/ci_group/terrains.py
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_v1.py
+Comment: 
+
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_orm_v2.py
+Comment: 
+
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_v2.py
+Comment: 
+
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/__init__.py
 Comment: 
 
-Filename: revolve2_ci_group-1.0.2.dist-info/METADATA
+Filename: revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_develop.py
 Comment: 
 
-Filename: revolve2_ci_group-1.0.2.dist-info/WHEEL
+Filename: revolve2/ci_group/interactive_objects/__init__.py
 Comment: 
 
-Filename: revolve2_ci_group-1.0.2.dist-info/RECORD
+Filename: revolve2/ci_group/interactive_objects/_ball.py
 Comment: 
 
 Zip file comment:
```

## filetype from file(1)

```diff
@@ -1 +1 @@
-Zip archive data, at least v2.0 to extract, compression method=deflate
+Zip archive data, at least v2.0 to extract, compression method=store
```

## revolve2/ci_group/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-"""Standard resources such as terrains and robots that can be used for testing and research."""
+"""Standard resources such as terrains and robots that can be used for testing and research."""
```

## revolve2/ci_group/ci_lab_utilities/__init__.py

```diff
@@ -1,5 +1,6 @@
-"""Utility functions for the CI-group lab."""
-from ._calibrate_camera import calibrate_camera
-from ._ip_camera import IPCamera
-
-__all__ = ["IPCamera", "calibrate_camera"]
+"""Utility functions for the CI-group lab."""
+
+from ._calibrate_camera import calibrate_camera
+from ._ip_camera import IPCamera
+
+__all__ = ["IPCamera", "calibrate_camera"]
```

## revolve2/ci_group/ci_lab_utilities/_calibrate_camera.py

 * *Ordering differences only*

```diff
@@ -1,83 +1,83 @@
-import cv2
-import numpy as np
-from numpy.typing import NDArray
-
-
-def calibrate_camera(
-    calibration_images_paths: list[str], checkerboard_size: tuple[int, int] = (9, 9)
-) -> tuple[tuple[int, ...], NDArray[np.float_], NDArray[np.float_]]:
-    """
-    Calibrate cameras for distortion and fisheye effects.
-
-    In order to use this function effectively please use at least 5 valid calibration images, with differently places checkerboards.
-    The checkerboard has to be fully visible with no occlusion, but it does mot have to lie flat on the ground.
-
-    :param calibration_images_paths: The calibration images.
-    :param checkerboard_size: The checkerboard size. Note if you have a 10 x 10 checkerboard the size should be (9, 9).
-    :return: The dimension of the calibration images, the camera matrix and the distortion coefficient.
-    """
-    subpix_criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.1)
-    calibration_flags = (
-        cv2.fisheye.CALIB_RECOMPUTE_EXTRINSIC
-        + cv2.fisheye.CALIB_CHECK_COND
-        + cv2.fisheye.CALIB_FIX_SKEW
-    )
-
-    object_point = np.zeros(
-        (1, checkerboard_size[0] * checkerboard_size[1], 3), np.float32
-    )
-    object_point[0, :, :2] = np.mgrid[
-        0 : checkerboard_size[0], 0 : checkerboard_size[1]
-    ].T.reshape(-1, 2)
-
-    _image_shape = None
-
-    object_points = []  # 3d point in real world space
-    image_points = []  # 2d points in image plane
-
-    for image_path in calibration_images_paths:
-        image = cv2.imread(image_path)
-        if _image_shape is None:
-            _image_shape = image.shape[:2]
-        else:
-            assert (
-                _image_shape == image.shape[:2]
-            ), "All images must share the same size."
-
-        # Detect checkerboard
-        returned, corners = cv2.findChessboardCorners(
-            image,
-            checkerboard_size,
-            None,
-            flags=cv2.CALIB_CB_ADAPTIVE_THRESH
-            + cv2.CALIB_CB_FAST_CHECK
-            + cv2.CALIB_CB_NORMALIZE_IMAGE,
-        )
-        if returned:
-            object_points.append(object_point)
-            cv2.cornerSubPix(image, corners, (3, 3), (-1, -1), subpix_criteria)
-            image_points.append(corners)
-
-    camera_matrix = np.zeros((3, 3))
-    distortion_coefficients = np.zeros((4, 1))
-    rotation_vectors = [
-        np.zeros((1, 1, 3), dtype=np.float64) for i in range(len(object_points))
-    ]
-    translation_vectors = [
-        np.zeros((1, 1, 3), dtype=np.float64) for i in range(len(object_points))
-    ]
-
-    # cv2 operations on numpy objects are in-place -> therefore we do not need to extract the return output.
-    _ = cv2.fisheye.calibrate(
-        object_points,
-        image_points,
-        image_size=image.shape[::-1],
-        K=camera_matrix,
-        D=distortion_coefficients,
-        rvecs=rotation_vectors,
-        tvecs=translation_vectors,
-        flags=calibration_flags,
-        criteria=(cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 1e-6),
-    )
-    print(f"Found {len(object_points)} valid images for calibration")
-    return image.shape[:2][::-1], camera_matrix, distortion_coefficients
+import cv2
+import numpy as np
+from numpy.typing import NDArray
+
+
+def calibrate_camera(
+    calibration_images_paths: list[str], checkerboard_size: tuple[int, int] = (9, 9)
+) -> tuple[tuple[int, ...], NDArray[np.float_], NDArray[np.float_]]:
+    """
+    Calibrate cameras for distortion and fisheye effects.
+
+    In order to use this function effectively please use at least 5 valid calibration images, with differently places checkerboards.
+    The checkerboard has to be fully visible with no occlusion, but it does mot have to lie flat on the ground.
+
+    :param calibration_images_paths: The calibration images.
+    :param checkerboard_size: The checkerboard size. Note if you have a 10 x 10 checkerboard the size should be (9, 9).
+    :return: The dimension of the calibration images, the camera matrix and the distortion coefficient.
+    """
+    subpix_criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.1)
+    calibration_flags = (
+        cv2.fisheye.CALIB_RECOMPUTE_EXTRINSIC
+        + cv2.fisheye.CALIB_CHECK_COND
+        + cv2.fisheye.CALIB_FIX_SKEW
+    )
+
+    object_point = np.zeros(
+        (1, checkerboard_size[0] * checkerboard_size[1], 3), np.float32
+    )
+    object_point[0, :, :2] = np.mgrid[
+        0 : checkerboard_size[0], 0 : checkerboard_size[1]
+    ].T.reshape(-1, 2)
+
+    _image_shape = None
+
+    object_points = []  # 3d point in real world space
+    image_points = []  # 2d points in image plane
+
+    for image_path in calibration_images_paths:
+        image = cv2.imread(image_path)
+        if _image_shape is None:
+            _image_shape = image.shape[:2]
+        else:
+            assert (
+                _image_shape == image.shape[:2]
+            ), "All images must share the same size."
+
+        # Detect checkerboard
+        returned, corners = cv2.findChessboardCorners(
+            image,
+            checkerboard_size,
+            None,
+            flags=cv2.CALIB_CB_ADAPTIVE_THRESH
+            + cv2.CALIB_CB_FAST_CHECK
+            + cv2.CALIB_CB_NORMALIZE_IMAGE,
+        )
+        if returned:
+            object_points.append(object_point)
+            cv2.cornerSubPix(image, corners, (3, 3), (-1, -1), subpix_criteria)
+            image_points.append(corners)
+
+    camera_matrix = np.zeros((3, 3))
+    distortion_coefficients = np.zeros((4, 1))
+    rotation_vectors = [
+        np.zeros((1, 1, 3), dtype=np.float64) for i in range(len(object_points))
+    ]
+    translation_vectors = [
+        np.zeros((1, 1, 3), dtype=np.float64) for i in range(len(object_points))
+    ]
+
+    # cv2 operations on numpy objects are in-place -> therefore we do not need to extract the return output.
+    _ = cv2.fisheye.calibrate(
+        object_points,
+        image_points,
+        image_size=image.shape[::-1],
+        K=camera_matrix,
+        D=distortion_coefficients,
+        rvecs=rotation_vectors,
+        tvecs=translation_vectors,
+        flags=calibration_flags,
+        criteria=(cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 1e-6),
+    )
+    print(f"Found {len(object_points)} valid images for calibration")
+    return image.shape[:2][::-1], camera_matrix, distortion_coefficients
```

## revolve2/ci_group/ci_lab_utilities/_ip_camera.py

 * *Ordering differences only*

```diff
@@ -1,189 +1,189 @@
-import queue
-import threading
-import time
-
-import cv2
-import numpy as np
-from numpy.typing import NDArray
-
-
-class IPCamera:
-    """
-    A general class to steam and record from IP cameras via opencv.
-
-    How to use:
-    >>> address = "rtsp://<user>:<password>@<ip>:<port (554)>/..."
-    >>> camera = IPCamera(camera_location=address, recording_path="<example_path>")
-    >>> camera.start(display=True, record=True)
-
-    If you are experiencing XDG_SESSION_TYPE error messages because of wayland use the following code before you start the recording:
-    >>> import os
-    >>> os.environ["XDG_SESSION_TYPE"] = "xcb"
-    >>> os.environ["OPENCV_FFMPEG_CAPTURE_OPTIONS"] = "rtsp_transport;udp"
-    """
-
-    _d_q: queue.Queue[cv2.typing.MatLike]  # Display queue
-    _r_q: queue.Queue[cv2.typing.MatLike]  # Record queue
-
-    """Threads for camera functionality."""
-    _recieve_thread: threading.Thread
-    _display_thread: threading.Thread
-    _record_thread: threading.Thread
-
-    _camera_location: str  # Location (address) of the camera
-    _is_running: bool  # Allows to break threads
-    _image_dimensions: tuple[int, int]
-    _fps: int
-
-    """Maps for undistorting the camera."""
-    _map1: cv2.typing.MatLike
-    _map2: cv2.typing.MatLike
-
-    def __init__(
-        self,
-        camera_location: str,
-        recording_path: str | None = None,
-        image_dimensions: tuple[int, int] = (1920, 1080),
-        distortion_coefficients: NDArray[np.float_] = np.array(
-            [
-                [-0.2976428547328032],
-                [3.2508343621538445],
-                [-17.38410840159056],
-                [30.01965021834286],
-            ]
-        ),
-        camera_matrix: NDArray[np.float_] = np.array(
-            [
-                [1490.4374643604199, 0.0, 990.6557248821284],
-                [0.0, 1490.6535480621505, 544.6243597123726],
-                [0.0, 0.0, 1.0],
-            ]
-        ),
-        fps: int = 30,
-    ) -> None:
-        """
-        Initialize the ip camera.
-
-        :param camera_location: The location of the camera.
-        :param recording_path: The path to store the recording.
-        :param image_dimensions: The dimensions of the image produced by the camera and used for calibration.
-        :param distortion_coefficients: The distortion coefficients for the camera.
-        :param camera_matrix: The camera matrix for calibration.
-        :param fps: The FPS of the camera.
-        """
-        self._camera_location = camera_location
-        self._recording_path = recording_path or f"{time.time()}_output.mp4"
-
-        self._d_q = queue.Queue()
-        self._r_q = queue.Queue()
-
-        self._image_dimensions = image_dimensions
-        self._fps = fps
-
-        self._map1, self._map2 = cv2.fisheye.initUndistortRectifyMap(
-            camera_matrix,
-            distortion_coefficients,
-            np.eye(3),
-            camera_matrix,
-            self._image_dimensions,
-            cv2.CV_16SC2,
-        )
-
-    def _receive(self) -> None:
-        """Recieve data from the camera."""
-        capture = cv2.VideoCapture(self._camera_location, cv2.CAP_FFMPEG)
-        capture.set(cv2.CAP_PROP_FRAME_WIDTH, self._image_dimensions[0])
-        capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self._image_dimensions[1])
-        ret, frame = capture.read()
-
-        frame = self._unfish(frame)
-        self._d_q.put(frame)
-        self._r_q.put(frame)
-        while ret and self._is_running:
-            ret, frame = capture.read()
-
-            frame = self._unfish(frame)
-            self._d_q.put(frame)
-            self._r_q.put(frame)
-        else:
-            capture.release()
-
-    def _display(self) -> None:
-        """Display the data from the camera."""
-        while self._is_running:
-            if not self._d_q.empty():
-                frame = self._d_q.get()
-                cv2.imshow("Camera View", frame)
-            key = cv2.waitKey(1)
-            if key == 27:  # Exit the viewer using ESC-button
-                self._is_running = False
-        else:
-            cv2.destroyAllWindows()
-
-    def _record(self) -> None:
-        """Record the data from the camera."""
-        out = cv2.VideoWriter(
-            self._recording_path,
-            cv2.VideoWriter.fourcc(*"mp4v"),
-            self._fps,
-            self._image_dimensions,
-        )
-        print("Recording in progress.")
-        while self._is_running:
-            if not self._r_q.empty():
-                out.write(self._r_q.get())
-        else:
-            print(f"Saving video to: {self._recording_path}")
-            out.release()
-
-    def _dump_record(self) -> None:
-        """Dump record queue if not used."""
-        while self._is_running:
-            if not self._r_q.empty():
-                self._r_q.get()
-
-    def _dump_display(self) -> None:
-        """Dump display queue if not used."""
-        while self._is_running:
-            if not self._d_q.empty():
-                self._d_q.get()
-
-    def _unfish(self, image: cv2.typing.MatLike) -> cv2.typing.MatLike:
-        """
-        Remove fisheye effect from the camera.
-
-        :param image: The image
-        :return: The undistorted image.
-        """
-        undistorted = cv2.remap(
-            image,
-            self._map1,
-            self._map2,
-            interpolation=cv2.INTER_LINEAR,
-            borderMode=cv2.BORDER_CONSTANT,
-        )
-        return undistorted
-
-    def start(self, record: bool = False, display: bool = True) -> None:
-        """
-        Start the camera.
-
-        :param record: Whether to record.
-        :param display: Whether to display the video stream.
-        """
-        assert (
-            record or display
-        ), "The camera is neither recording or displaying, are you sure you are using it?"
-        self._recieve_thread = threading.Thread(target=self._receive)
-        self._display_thread = threading.Thread(
-            target=self._display if display else self._dump_display
-        )
-        self._record_thread = threading.Thread(
-            target=self._record if record else self._dump_record
-        )
-
-        self._is_running = True
-
-        self._recieve_thread.start()
-        self._record_thread.start()
-        self._display_thread.start()
+import queue
+import threading
+import time
+
+import cv2
+import numpy as np
+from numpy.typing import NDArray
+
+
+class IPCamera:
+    """
+    A general class to steam and record from IP cameras via opencv.
+
+    How to use:
+    >>> address = "rtsp://<user>:<password>@<ip>:<port (554)>/..."
+    >>> camera = IPCamera(camera_location=address, recording_path="<example_path>")
+    >>> camera.start(display=True, record=True)
+
+    If you are experiencing XDG_SESSION_TYPE error messages because of wayland use the following code before you start the recording:
+    >>> import os
+    >>> os.environ["XDG_SESSION_TYPE"] = "xcb"
+    >>> os.environ["OPENCV_FFMPEG_CAPTURE_OPTIONS"] = "rtsp_transport;udp"
+    """
+
+    _d_q: queue.Queue[cv2.typing.MatLike]  # Display queue
+    _r_q: queue.Queue[cv2.typing.MatLike]  # Record queue
+
+    """Threads for camera functionality."""
+    _recieve_thread: threading.Thread
+    _display_thread: threading.Thread
+    _record_thread: threading.Thread
+
+    _camera_location: str  # Location (address) of the camera
+    _is_running: bool  # Allows to break threads
+    _image_dimensions: tuple[int, int]
+    _fps: int
+
+    """Maps for undistorting the camera."""
+    _map1: cv2.typing.MatLike
+    _map2: cv2.typing.MatLike
+
+    def __init__(
+        self,
+        camera_location: str,
+        recording_path: str | None = None,
+        image_dimensions: tuple[int, int] = (1920, 1080),
+        distortion_coefficients: NDArray[np.float_] = np.array(
+            [
+                [-0.2976428547328032],
+                [3.2508343621538445],
+                [-17.38410840159056],
+                [30.01965021834286],
+            ]
+        ),
+        camera_matrix: NDArray[np.float_] = np.array(
+            [
+                [1490.4374643604199, 0.0, 990.6557248821284],
+                [0.0, 1490.6535480621505, 544.6243597123726],
+                [0.0, 0.0, 1.0],
+            ]
+        ),
+        fps: int = 30,
+    ) -> None:
+        """
+        Initialize the ip camera.
+
+        :param camera_location: The location of the camera.
+        :param recording_path: The path to store the recording.
+        :param image_dimensions: The dimensions of the image produced by the camera and used for calibration.
+        :param distortion_coefficients: The distortion coefficients for the camera.
+        :param camera_matrix: The camera matrix for calibration.
+        :param fps: The FPS of the camera.
+        """
+        self._camera_location = camera_location
+        self._recording_path = recording_path or f"{time.time()}_output.mp4"
+
+        self._d_q = queue.Queue()
+        self._r_q = queue.Queue()
+
+        self._image_dimensions = image_dimensions
+        self._fps = fps
+
+        self._map1, self._map2 = cv2.fisheye.initUndistortRectifyMap(
+            camera_matrix,
+            distortion_coefficients,
+            np.eye(3),
+            camera_matrix,
+            self._image_dimensions,
+            cv2.CV_16SC2,
+        )
+
+    def _receive(self) -> None:
+        """Recieve data from the camera."""
+        capture = cv2.VideoCapture(self._camera_location, cv2.CAP_FFMPEG)
+        capture.set(cv2.CAP_PROP_FRAME_WIDTH, self._image_dimensions[0])
+        capture.set(cv2.CAP_PROP_FRAME_HEIGHT, self._image_dimensions[1])
+        ret, frame = capture.read()
+
+        frame = self._unfish(frame)
+        self._d_q.put(frame)
+        self._r_q.put(frame)
+        while ret and self._is_running:
+            ret, frame = capture.read()
+
+            frame = self._unfish(frame)
+            self._d_q.put(frame)
+            self._r_q.put(frame)
+        else:
+            capture.release()
+
+    def _display(self) -> None:
+        """Display the data from the camera."""
+        while self._is_running:
+            if not self._d_q.empty():
+                frame = self._d_q.get()
+                cv2.imshow("Camera View", frame)
+            key = cv2.waitKey(1)
+            if key == 27:  # Exit the viewer using ESC-button
+                self._is_running = False
+        else:
+            cv2.destroyAllWindows()
+
+    def _record(self) -> None:
+        """Record the data from the camera."""
+        out = cv2.VideoWriter(
+            self._recording_path,
+            cv2.VideoWriter.fourcc(*"mp4v"),
+            self._fps,
+            self._image_dimensions,
+        )
+        print("Recording in progress.")
+        while self._is_running:
+            if not self._r_q.empty():
+                out.write(self._r_q.get())
+        else:
+            print(f"Saving video to: {self._recording_path}")
+            out.release()
+
+    def _dump_record(self) -> None:
+        """Dump record queue if not used."""
+        while self._is_running:
+            if not self._r_q.empty():
+                self._r_q.get()
+
+    def _dump_display(self) -> None:
+        """Dump display queue if not used."""
+        while self._is_running:
+            if not self._d_q.empty():
+                self._d_q.get()
+
+    def _unfish(self, image: cv2.typing.MatLike) -> cv2.typing.MatLike:
+        """
+        Remove fisheye effect from the camera.
+
+        :param image: The image
+        :return: The undistorted image.
+        """
+        undistorted = cv2.remap(
+            image,
+            self._map1,
+            self._map2,
+            interpolation=cv2.INTER_LINEAR,
+            borderMode=cv2.BORDER_CONSTANT,
+        )
+        return undistorted
+
+    def start(self, record: bool = False, display: bool = True) -> None:
+        """
+        Start the camera.
+
+        :param record: Whether to record.
+        :param display: Whether to display the video stream.
+        """
+        assert (
+            record or display
+        ), "The camera is neither recording or displaying, are you sure you are using it?"
+        self._recieve_thread = threading.Thread(target=self._receive)
+        self._display_thread = threading.Thread(
+            target=self._display if display else self._dump_display
+        )
+        self._record_thread = threading.Thread(
+            target=self._record if record else self._dump_record
+        )
+
+        self._is_running = True
+
+        self._recieve_thread.start()
+        self._record_thread.start()
+        self._display_thread.start()
```

## revolve2/ci_group/fitness_functions.py

 * *Ordering differences only*

```diff
@@ -1,23 +1,23 @@
-"""Standard fitness functions for modular robots."""
-
-import math
-
-from revolve2.modular_robot_simulation import ModularRobotSimulationState
-
-
-def xy_displacement(
-    begin_state: ModularRobotSimulationState, end_state: ModularRobotSimulationState
-) -> float:
-    """
-    Calculate the distance traveled on the xy-plane by a single modular robot.
-
-    :param begin_state: Begin state of the robot.
-    :param end_state: End state of the robot.
-    :returns: The calculated fitness.
-    """
-    begin_position = begin_state.get_pose().position
-    end_position = end_state.get_pose().position
-    return math.sqrt(
-        (begin_position.x - end_position.x) ** 2
-        + (begin_position.y - end_position.y) ** 2
-    )
+"""Standard fitness functions for modular robots."""
+
+import math
+
+from revolve2.modular_robot_simulation import ModularRobotSimulationState
+
+
+def xy_displacement(
+    begin_state: ModularRobotSimulationState, end_state: ModularRobotSimulationState
+) -> float:
+    """
+    Calculate the distance traveled on the xy-plane by a single modular robot.
+
+    :param begin_state: Begin state of the robot.
+    :param end_state: End state of the robot.
+    :returns: The calculated fitness.
+    """
+    begin_position = begin_state.get_pose().position
+    end_position = end_state.get_pose().position
+    return math.sqrt(
+        (begin_position.x - end_position.x) ** 2
+        + (begin_position.y - end_position.y) ** 2
+    )
```

## revolve2/ci_group/genotypes/__init__.py

 * *Ordering differences only*

```diff
@@ -1 +1 @@
-"""Genotypes for evolutionary algorithms."""
+"""Genotypes for evolutionary algorithms."""
```

## revolve2/ci_group/genotypes/cppnwin/__init__.py

 * *Ordering differences only*

```diff
@@ -1,5 +1,5 @@
-"""
-CPPNWIN genotype.
-
-That is, Compositional Pattern-Producing Network With Innovation Numbers.
-"""
+"""
+CPPNWIN genotype.
+
+That is, Compositional Pattern-Producing Network With Innovation Numbers.
+"""
```

## revolve2/ci_group/genotypes/cppnwin/_multineat_genotype_pickle_wrapper.py

 * *Ordering differences only*

```diff
@@ -1,29 +1,29 @@
-from dataclasses import dataclass
-from typing import cast
-
-import multineat
-
-
-@dataclass
-class MultineatGenotypePickleWrapper:
-    """A wrapper about multineat.Genome that provides pickling."""
-
-    genotype: multineat.Genome
-
-    def __getstate__(self) -> str:
-        """
-        Convert the genotype to a string, serializing it.
-
-        :returns: The string.
-        """
-        return cast(str, self.genotype.Serialize()).replace(" ", "")
-
-    def __setstate__(self, serialized_genotype: str) -> None:
-        """
-        Convert a string obtained through __getstate__ to a genotype and set it as the genotype.
-
-        :param serialized_genotype: The string to convert.
-        """
-        genotype = multineat.Genome()
-        genotype.Deserialize(serialized_genotype)
-        self.genotype = genotype
+from dataclasses import dataclass
+from typing import cast
+
+import multineat
+
+
+@dataclass
+class MultineatGenotypePickleWrapper:
+    """A wrapper about multineat.Genome that provides pickling."""
+
+    genotype: multineat.Genome
+
+    def __getstate__(self) -> str:
+        """
+        Convert the genotype to a string, serializing it.
+
+        :returns: The string.
+        """
+        return cast(str, self.genotype.Serialize()).replace(" ", "")
+
+    def __setstate__(self, serialized_genotype: str) -> None:
+        """
+        Convert a string obtained through __getstate__ to a genotype and set it as the genotype.
+
+        :param serialized_genotype: The string to convert.
+        """
+        genotype = multineat.Genome()
+        genotype.Deserialize(serialized_genotype)
+        self.genotype = genotype
```

## revolve2/ci_group/genotypes/cppnwin/_multineat_rng_from_random.py

 * *Ordering differences only*

```diff
@@ -1,14 +1,14 @@
-import multineat
-import numpy as np
-
-
-def multineat_rng_from_random(rng: np.random.Generator) -> multineat.RNG:
-    """
-    Create a multineat rng object from a numpy rng state.
-
-    :param rng: The numpy rng.
-    :returns: The multineat rng.
-    """
-    multineat_rng = multineat.RNG()
-    multineat_rng.Seed(rng.integers(0, 2**31))
-    return multineat_rng
+import multineat
+import numpy as np
+
+
+def multineat_rng_from_random(rng: np.random.Generator) -> multineat.RNG:
+    """
+    Create a multineat rng object from a numpy rng state.
+
+    :param rng: The numpy rng.
+    :returns: The multineat rng.
+    """
+    multineat_rng = multineat.RNG()
+    multineat_rng.Seed(rng.integers(0, 2**31))
+    return multineat_rng
```

## revolve2/ci_group/genotypes/cppnwin/_random_multineat_genotype.py

```diff
@@ -1,50 +1,50 @@
-import multineat
-
-
-def random_multineat_genotype(
-    innov_db: multineat.InnovationDatabase,
-    rng: multineat.RNG,
-    multineat_params: multineat.Parameters,
-    output_activation_func: multineat.ActivationFunction,
-    num_inputs: int,
-    num_outputs: int,
-    num_initial_mutations: int,
-) -> multineat.Genome:
-    """
-    Create a random multineat genotype.
-
-    A CPPNWIN network starts empty.
-    A random network is created by mutating `num_initial_mutations` times.
-
-    :param innov_db: Multineat innovation database. See Multineat library.
-    :param rng: Random number generator.
-    :param multineat_params: Multineat parameters. See Multineat library.
-    :param output_activation_func: Activation function for the output layer. See Multineat library.
-    :param num_inputs: Number of input for the network.
-    :param num_outputs: Number fo outputs for the network.
-    :param num_initial_mutations: The number of times to mutate to create a random network.
-    :returns: The created genotype.
-    """
-    genotype = multineat.Genome(
-        0,  # ID
-        num_inputs,
-        0,  # n_hidden
-        num_outputs,
-        False,  # FS_NEAT
-        output_activation_func,  # output activation type
-        multineat.ActivationFunction.TANH,  # hidden activation type
-        0,  # seed_type
-        multineat_params,
-        0,  # number of hidden layers
-    )
-
-    for _ in range(num_initial_mutations):
-        genotype = genotype.MutateWithConstraints(
-            False,
-            multineat.SearchMode.BLENDED,
-            innov_db,
-            multineat_params,
-            rng,
-        )
-
-    return genotype
+import multineat
+
+
+def random_multineat_genotype(
+    innov_db: multineat.InnovationDatabase,
+    rng: multineat.RNG,
+    multineat_params: multineat.Parameters,
+    output_activation_func: multineat.ActivationFunction,
+    num_inputs: int,
+    num_outputs: int,
+    num_initial_mutations: int,
+) -> multineat.Genome:
+    """
+    Create a random multineat genotype.
+
+    A CPPNWIN network starts empty.
+    A random network is created by mutating `num_initial_mutations` times.
+
+    :param innov_db: Multineat innovation database. See Multineat library.
+    :param rng: Random number generator.
+    :param multineat_params: Multineat parameters. See Multineat library.
+    :param output_activation_func: Activation function for the output layer. See Multineat library.
+    :param num_inputs: Number of input for the network.
+    :param num_outputs: Number fo outputs for the network.
+    :param num_initial_mutations: The number of times to mutate to create a random network.
+    :returns: The created genotype.
+    """
+    genotype = multineat.Genome(
+        0,  # ID
+        num_inputs,
+        num_inputs,  # ignored for seed_type == 0, specifies number of hidden units if seed_type == 1
+        num_outputs,
+        False,  # FS_NEAT
+        output_activation_func,  # output activation type
+        multineat.ActivationFunction.UNSIGNED_SIGMOID,  # hidden activation type
+        1,  # seed_type
+        multineat_params,
+        1,  # number of hidden layers
+    )
+
+    for _ in range(num_initial_mutations):
+        genotype = genotype.MutateWithConstraints(
+            False,
+            multineat.SearchMode.BLENDED,
+            innov_db,
+            multineat_params,
+            rng,
+        )
+
+    return genotype
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/__init__.py

 * *Ordering differences only*

```diff
@@ -1,11 +1,11 @@
-"""CPPNWIN genotypes for modular robots."""
-
-from ._brain_cpg_network_neighbor_v1 import BrainCpgNetworkNeighborV1
-from ._brain_genotype_cpg import BrainGenotypeCpg
-from ._brain_genotype_cpg_orm import BrainGenotypeCpgOrm
-
-__all__ = [
-    "BrainCpgNetworkNeighborV1",
-    "BrainGenotypeCpg",
-    "BrainGenotypeCpgOrm",
-]
+"""CPPNWIN genotypes for modular robots."""
+
+from ._brain_cpg_network_neighbor_v1 import BrainCpgNetworkNeighborV1
+from ._brain_genotype_cpg import BrainGenotypeCpg
+from ._brain_genotype_cpg_orm import BrainGenotypeCpgOrm
+
+__all__ = [
+    "BrainCpgNetworkNeighborV1",
+    "BrainGenotypeCpg",
+    "BrainGenotypeCpgOrm",
+]
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_cpg_network_neighbor_v1.py

 * *Ordering differences only*

```diff
@@ -1,86 +1,86 @@
-from typing import cast
-
-import multineat
-
-from revolve2.modular_robot.body.base import ActiveHinge, Body
-from revolve2.modular_robot.brain.cpg import (
-    BrainCpgNetworkNeighbor as ModularRobotBrainCpgNetworkNeighbor,
-)
-
-
-class BrainCpgNetworkNeighborV1(ModularRobotBrainCpgNetworkNeighbor):
-    """
-    A CPG brain based on `ModularRobotBrainCpgNetworkNeighbor` that creates weights from a CPPNWIN network.
-
-    Weights are determined by querying the CPPN network with inputs:
-    (hinge1_posx, hinge1_posy, hinge1_posz, hinge2_posx, hinge2_posy, hinge3_posz)
-    If the weight in internal, hinge1 and hinge2 position will be the same.
-    """
-
-    _genotype: multineat.Genome
-
-    def __init__(self, genotype: multineat.Genome, body: Body):
-        """
-        Initialize this object.
-
-        :param genotype: A multineat genome used for determining weights.
-        :param body: The body of the robot.
-        """
-        self._genotype = genotype
-        super().__init__(body)
-
-    def _make_weights(
-        self,
-        active_hinges: list[ActiveHinge],
-        connections: list[tuple[ActiveHinge, ActiveHinge]],
-        body: Body,
-    ) -> tuple[list[float], list[float]]:
-        brain_net = multineat.NeuralNetwork()
-        self._genotype.BuildPhenotype(brain_net)
-
-        internal_weights = [
-            self._evaluate_network(
-                brain_net,
-                [
-                    1.0,
-                    float(pos.x),
-                    float(pos.y),
-                    float(pos.z),
-                    float(pos.x),
-                    float(pos.y),
-                    float(pos.z),
-                ],
-            )
-            for pos in [
-                body.grid_position(active_hinge) for active_hinge in active_hinges
-            ]
-        ]
-
-        external_weights = [
-            self._evaluate_network(
-                brain_net,
-                [
-                    1.0,
-                    float(pos1.x),
-                    float(pos1.y),
-                    float(pos1.z),
-                    float(pos2.x),
-                    float(pos2.y),
-                    float(pos2.z),
-                ],
-            )
-            for (pos1, pos2) in [
-                (body.grid_position(active_hinge1), body.grid_position(active_hinge2))
-                for (active_hinge1, active_hinge2) in connections
-            ]
-        ]
-
-        return (internal_weights, external_weights)
-
-    @staticmethod
-    def _evaluate_network(
-        network: multineat.NeuralNetwork, inputs: list[float]
-    ) -> float:
-        network.Input(inputs)
-        network.ActivateAllLayers()
-        return cast(float, network.Output()[0])
+from typing import cast
+
+import multineat
+
+from revolve2.modular_robot.body.base import ActiveHinge, Body
+from revolve2.modular_robot.brain.cpg import (
+    BrainCpgNetworkNeighbor as ModularRobotBrainCpgNetworkNeighbor,
+)
+
+
+class BrainCpgNetworkNeighborV1(ModularRobotBrainCpgNetworkNeighbor):
+    """
+    A CPG brain based on `ModularRobotBrainCpgNetworkNeighbor` that creates weights from a CPPNWIN network.
+
+    Weights are determined by querying the CPPN network with inputs:
+    (hinge1_posx, hinge1_posy, hinge1_posz, hinge2_posx, hinge2_posy, hinge3_posz)
+    If the weight in internal, hinge1 and hinge2 position will be the same.
+    """
+
+    _genotype: multineat.Genome
+
+    def __init__(self, genotype: multineat.Genome, body: Body):
+        """
+        Initialize this object.
+
+        :param genotype: A multineat genome used for determining weights.
+        :param body: The body of the robot.
+        """
+        self._genotype = genotype
+        super().__init__(body)
+
+    def _make_weights(
+        self,
+        active_hinges: list[ActiveHinge],
+        connections: list[tuple[ActiveHinge, ActiveHinge]],
+        body: Body,
+    ) -> tuple[list[float], list[float]]:
+        brain_net = multineat.NeuralNetwork()
+        self._genotype.BuildPhenotype(brain_net)
+
+        internal_weights = [
+            self._evaluate_network(
+                brain_net,
+                [
+                    1.0,
+                    float(pos.x),
+                    float(pos.y),
+                    float(pos.z),
+                    float(pos.x),
+                    float(pos.y),
+                    float(pos.z),
+                ],
+            )
+            for pos in [
+                body.grid_position(active_hinge) for active_hinge in active_hinges
+            ]
+        ]
+
+        external_weights = [
+            self._evaluate_network(
+                brain_net,
+                [
+                    1.0,
+                    float(pos1.x),
+                    float(pos1.y),
+                    float(pos1.z),
+                    float(pos2.x),
+                    float(pos2.y),
+                    float(pos2.z),
+                ],
+            )
+            for (pos1, pos2) in [
+                (body.grid_position(active_hinge1), body.grid_position(active_hinge2))
+                for (active_hinge1, active_hinge2) in connections
+            ]
+        ]
+
+        return (internal_weights, external_weights)
+
+    @staticmethod
+    def _evaluate_network(
+        network: multineat.NeuralNetwork, inputs: list[float]
+    ) -> float:
+        network.Input(inputs)
+        network.ActivateAllLayers()
+        return cast(float, network.Output()[0])
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg.py

 * *Ordering differences only*

```diff
@@ -1,121 +1,121 @@
-from __future__ import annotations
-
-from dataclasses import dataclass
-
-import multineat
-import numpy as np
-from typing_extensions import Self
-
-from revolve2.modular_robot.body.base import Body
-
-from .._multineat_genotype_pickle_wrapper import MultineatGenotypePickleWrapper
-from .._multineat_rng_from_random import multineat_rng_from_random
-from .._random_multineat_genotype import random_multineat_genotype
-from ._brain_cpg_network_neighbor_v1 import BrainCpgNetworkNeighborV1
-from ._multineat_params import get_multineat_params
-
-_MULTINEAT_PARAMS = get_multineat_params()
-
-
-@dataclass
-class BrainGenotypeCpg:
-    """An SQLAlchemy model for a CPPNWIN cpg brain genotype."""
-
-    _NUM_INITIAL_MUTATIONS = 5
-
-    brain: MultineatGenotypePickleWrapper
-
-    @classmethod
-    def random_brain(
-        cls,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BrainGenotypeCpg:
-        """
-        Create a random genotype.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: The created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        brain = MultineatGenotypePickleWrapper(
-            random_multineat_genotype(
-                innov_db=innov_db,
-                rng=multineat_rng,
-                multineat_params=_MULTINEAT_PARAMS,
-                output_activation_func=multineat.ActivationFunction.SIGNED_SINE,
-                num_inputs=7,  # bias(always 1), x1, y1, z1, x2, y2, z2
-                num_outputs=1,  # weight
-                num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
-            )
-        )
-
-        return BrainGenotypeCpg(brain)
-
-    def mutate_brain(
-        self,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BrainGenotypeCpg:
-        """
-        Mutate this genotype.
-
-        This genotype will not be changed; a mutated copy will be returned.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: A mutated copy of the provided genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BrainGenotypeCpg(
-            MultineatGenotypePickleWrapper(
-                self.brain.genotype.MutateWithConstraints(
-                    False,
-                    multineat.SearchMode.BLENDED,
-                    innov_db,
-                    _MULTINEAT_PARAMS,
-                    multineat_rng,
-                )
-            )
-        )
-
-    @classmethod
-    def crossover_brain(
-        cls,
-        parent1: Self,
-        parent2: Self,
-        rng: np.random.Generator,
-    ) -> BrainGenotypeCpg:
-        """
-        Perform crossover between two genotypes.
-
-        :param parent1: The first genotype.
-        :param parent2: The second genotype.
-        :param rng: Random number generator.
-        :returns: A newly created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BrainGenotypeCpg(
-            MultineatGenotypePickleWrapper(
-                parent1.brain.genotype.MateWithConstraints(
-                    parent2.brain.genotype,
-                    False,
-                    False,
-                    multineat_rng,
-                    _MULTINEAT_PARAMS,
-                )
-            )
-        )
-
-    def develop_brain(self, body: Body) -> BrainCpgNetworkNeighborV1:
-        """
-        Develop the genotype into a modular robot.
-
-        :param body: The body to develop the brain for.
-        :returns: The created robot.
-        """
-        return BrainCpgNetworkNeighborV1(genotype=self.brain.genotype, body=body)
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+import multineat
+import numpy as np
+from typing_extensions import Self
+
+from revolve2.modular_robot.body.base import Body
+
+from .._multineat_genotype_pickle_wrapper import MultineatGenotypePickleWrapper
+from .._multineat_rng_from_random import multineat_rng_from_random
+from .._random_multineat_genotype import random_multineat_genotype
+from ._brain_cpg_network_neighbor_v1 import BrainCpgNetworkNeighborV1
+from ._multineat_params import get_multineat_params
+
+_MULTINEAT_PARAMS = get_multineat_params()
+
+
+@dataclass
+class BrainGenotypeCpg:
+    """An SQLAlchemy model for a CPPNWIN cpg brain genotype."""
+
+    _NUM_INITIAL_MUTATIONS = 5
+
+    brain: MultineatGenotypePickleWrapper
+
+    @classmethod
+    def random_brain(
+        cls,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BrainGenotypeCpg:
+        """
+        Create a random genotype.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: The created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        brain = MultineatGenotypePickleWrapper(
+            random_multineat_genotype(
+                innov_db=innov_db,
+                rng=multineat_rng,
+                multineat_params=_MULTINEAT_PARAMS,
+                output_activation_func=multineat.ActivationFunction.SIGNED_SINE,
+                num_inputs=7,  # bias(always 1), x1, y1, z1, x2, y2, z2
+                num_outputs=1,  # weight
+                num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
+            )
+        )
+
+        return BrainGenotypeCpg(brain)
+
+    def mutate_brain(
+        self,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BrainGenotypeCpg:
+        """
+        Mutate this genotype.
+
+        This genotype will not be changed; a mutated copy will be returned.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: A mutated copy of the provided genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BrainGenotypeCpg(
+            MultineatGenotypePickleWrapper(
+                self.brain.genotype.MutateWithConstraints(
+                    False,
+                    multineat.SearchMode.BLENDED,
+                    innov_db,
+                    _MULTINEAT_PARAMS,
+                    multineat_rng,
+                )
+            )
+        )
+
+    @classmethod
+    def crossover_brain(
+        cls,
+        parent1: Self,
+        parent2: Self,
+        rng: np.random.Generator,
+    ) -> BrainGenotypeCpg:
+        """
+        Perform crossover between two genotypes.
+
+        :param parent1: The first genotype.
+        :param parent2: The second genotype.
+        :param rng: Random number generator.
+        :returns: A newly created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BrainGenotypeCpg(
+            MultineatGenotypePickleWrapper(
+                parent1.brain.genotype.MateWithConstraints(
+                    parent2.brain.genotype,
+                    False,
+                    False,
+                    multineat_rng,
+                    _MULTINEAT_PARAMS,
+                )
+            )
+        )
+
+    def develop_brain(self, body: Body) -> BrainCpgNetworkNeighborV1:
+        """
+        Develop the genotype into a modular robot.
+
+        :param body: The body to develop the brain for.
+        :returns: The created robot.
+        """
+        return BrainCpgNetworkNeighborV1(genotype=self.brain.genotype, body=body)
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg_orm.py

 * *Ordering differences only*

```diff
@@ -1,135 +1,135 @@
-from __future__ import annotations
-
-import multineat
-import numpy as np
-import sqlalchemy.orm as orm
-from sqlalchemy import event
-from sqlalchemy.engine import Connection
-from typing_extensions import Self
-
-from revolve2.modular_robot.body.base import Body
-
-from .._multineat_rng_from_random import multineat_rng_from_random
-from .._random_multineat_genotype import random_multineat_genotype
-from ._brain_cpg_network_neighbor_v1 import BrainCpgNetworkNeighborV1
-from ._multineat_params import get_multineat_params
-
-_MULTINEAT_PARAMS = get_multineat_params()
-
-
-class BrainGenotypeCpgOrm(orm.MappedAsDataclass, kw_only=True):
-    """An SQLAlchemy model for a CPPNWIN cpg brain genotype."""
-
-    _NUM_INITIAL_MUTATIONS = 5
-
-    brain: multineat.Genome
-
-    _serialized_brain: orm.Mapped[str] = orm.mapped_column(
-        "serialized_brain", init=False, nullable=False
-    )
-
-    @classmethod
-    def random_brain(
-        cls,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BrainGenotypeCpgOrm:
-        """
-        Create a random genotype.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: The created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        brain = random_multineat_genotype(
-            innov_db=innov_db,
-            rng=multineat_rng,
-            multineat_params=_MULTINEAT_PARAMS,
-            output_activation_func=multineat.ActivationFunction.SIGNED_SINE,
-            num_inputs=7,  # bias(always 1), x1, y1, z1, x2, y2, z2
-            num_outputs=1,  # weight
-            num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
-        )
-
-        return BrainGenotypeCpgOrm(brain=brain)
-
-    def mutate_brain(
-        self,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BrainGenotypeCpgOrm:
-        """
-        Mutate this genotype.
-
-        This genotype will not be changed; a mutated copy will be returned.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: A mutated copy of the provided genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BrainGenotypeCpgOrm(
-            brain=self.brain.MutateWithConstraints(
-                False,
-                multineat.SearchMode.BLENDED,
-                innov_db,
-                _MULTINEAT_PARAMS,
-                multineat_rng,
-            )
-        )
-
-    @classmethod
-    def crossover_brain(
-        cls,
-        parent1: Self,
-        parent2: Self,
-        rng: np.random.Generator,
-    ) -> BrainGenotypeCpgOrm:
-        """
-        Perform crossover between two genotypes.
-
-        :param parent1: The first genotype.
-        :param parent2: The second genotype.
-        :param rng: Random number generator.
-        :returns: A newly created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BrainGenotypeCpgOrm(
-            brain=parent1.brain.MateWithConstraints(
-                parent2.brain,
-                False,
-                False,
-                multineat_rng,
-                _MULTINEAT_PARAMS,
-            )
-        )
-
-    def develop_brain(self, body: Body) -> BrainCpgNetworkNeighborV1:
-        """
-        Develop the genotype into a modular robot.
-
-        :param body: The body to develop the brain for.
-        :returns: The created robot.
-        """
-        return BrainCpgNetworkNeighborV1(genotype=self.brain, body=body)
-
-
-@event.listens_for(BrainGenotypeCpgOrm, "before_update", propagate=True)
-@event.listens_for(BrainGenotypeCpgOrm, "before_insert", propagate=True)
-def _serialize_brain(
-    mapper: orm.Mapper[BrainGenotypeCpgOrm],
-    connection: Connection,
-    target: BrainGenotypeCpgOrm,
-) -> None:
-    target._serialized_brain = target.brain.Serialize()
-
-
-@event.listens_for(BrainGenotypeCpgOrm, "load", propagate=True)
-def _deserialize_brain(target: BrainGenotypeCpgOrm, context: orm.QueryContext) -> None:
-    brain = multineat.Genome()
-    brain.Deserialize(target._serialized_brain)
-    target.brain = brain
+from __future__ import annotations
+
+import multineat
+import numpy as np
+import sqlalchemy.orm as orm
+from sqlalchemy import event
+from sqlalchemy.engine import Connection
+from typing_extensions import Self
+
+from revolve2.modular_robot.body.base import Body
+
+from .._multineat_rng_from_random import multineat_rng_from_random
+from .._random_multineat_genotype import random_multineat_genotype
+from ._brain_cpg_network_neighbor_v1 import BrainCpgNetworkNeighborV1
+from ._multineat_params import get_multineat_params
+
+_MULTINEAT_PARAMS = get_multineat_params()
+
+
+class BrainGenotypeCpgOrm(orm.MappedAsDataclass, kw_only=True):
+    """An SQLAlchemy model for a CPPNWIN cpg brain genotype."""
+
+    _NUM_INITIAL_MUTATIONS = 5
+
+    brain: multineat.Genome
+
+    _serialized_brain: orm.Mapped[str] = orm.mapped_column(
+        "serialized_brain", init=False, nullable=False
+    )
+
+    @classmethod
+    def random_brain(
+        cls,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BrainGenotypeCpgOrm:
+        """
+        Create a random genotype.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: The created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        brain = random_multineat_genotype(
+            innov_db=innov_db,
+            rng=multineat_rng,
+            multineat_params=_MULTINEAT_PARAMS,
+            output_activation_func=multineat.ActivationFunction.SIGNED_SINE,
+            num_inputs=7,  # bias(always 1), x1, y1, z1, x2, y2, z2
+            num_outputs=1,  # weight
+            num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
+        )
+
+        return BrainGenotypeCpgOrm(brain=brain)
+
+    def mutate_brain(
+        self,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BrainGenotypeCpgOrm:
+        """
+        Mutate this genotype.
+
+        This genotype will not be changed; a mutated copy will be returned.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: A mutated copy of the provided genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BrainGenotypeCpgOrm(
+            brain=self.brain.MutateWithConstraints(
+                False,
+                multineat.SearchMode.BLENDED,
+                innov_db,
+                _MULTINEAT_PARAMS,
+                multineat_rng,
+            )
+        )
+
+    @classmethod
+    def crossover_brain(
+        cls,
+        parent1: Self,
+        parent2: Self,
+        rng: np.random.Generator,
+    ) -> BrainGenotypeCpgOrm:
+        """
+        Perform crossover between two genotypes.
+
+        :param parent1: The first genotype.
+        :param parent2: The second genotype.
+        :param rng: Random number generator.
+        :returns: A newly created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BrainGenotypeCpgOrm(
+            brain=parent1.brain.MateWithConstraints(
+                parent2.brain,
+                False,
+                False,
+                multineat_rng,
+                _MULTINEAT_PARAMS,
+            )
+        )
+
+    def develop_brain(self, body: Body) -> BrainCpgNetworkNeighborV1:
+        """
+        Develop the genotype into a modular robot.
+
+        :param body: The body to develop the brain for.
+        :returns: The created robot.
+        """
+        return BrainCpgNetworkNeighborV1(genotype=self.brain, body=body)
+
+
+@event.listens_for(BrainGenotypeCpgOrm, "before_update", propagate=True)
+@event.listens_for(BrainGenotypeCpgOrm, "before_insert", propagate=True)
+def _serialize_brain(
+    mapper: orm.Mapper[BrainGenotypeCpgOrm],
+    connection: Connection,
+    target: BrainGenotypeCpgOrm,
+) -> None:
+    target._serialized_brain = target.brain.Serialize()
+
+
+@event.listens_for(BrainGenotypeCpgOrm, "load", propagate=True)
+def _deserialize_brain(target: BrainGenotypeCpgOrm, context: orm.QueryContext) -> None:
+    brain = multineat.Genome()
+    brain.Deserialize(target._serialized_brain)
+    target.brain = brain
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/_multineat_params.py

 * *Ordering differences only*

```diff
@@ -1,47 +1,47 @@
-import multineat
-
-
-def get_multineat_params() -> multineat.Parameters:
-    """
-    Get Multineat Parameters.
-
-    :returns: The parameters.
-    """
-    multineat_params = multineat.Parameters()
-
-    multineat_params.MutateRemLinkProb = 0.02
-    multineat_params.RecurrentProb = 0.0
-    multineat_params.OverallMutationRate = 0.15
-    multineat_params.MutateAddLinkProb = 0.08
-    multineat_params.MutateAddNeuronProb = 0.01
-    multineat_params.MutateWeightsProb = 0.90
-    multineat_params.MaxWeight = 8.0
-    multineat_params.WeightMutationMaxPower = 0.2
-    multineat_params.WeightReplacementMaxPower = 1.0
-    multineat_params.MutateActivationAProb = 0.0
-    multineat_params.ActivationAMutationMaxPower = 0.5
-    multineat_params.MinActivationA = 0.05
-    multineat_params.MaxActivationA = 6.0
-
-    multineat_params.MutateNeuronActivationTypeProb = 0.03
-
-    multineat_params.MutateOutputActivationFunction = False
-
-    multineat_params.ActivationFunction_SignedSigmoid_Prob = 0.0
-    multineat_params.ActivationFunction_UnsignedSigmoid_Prob = 0.0
-    multineat_params.ActivationFunction_Tanh_Prob = 1.0
-    multineat_params.ActivationFunction_TanhCubic_Prob = 0.0
-    multineat_params.ActivationFunction_SignedStep_Prob = 1.0
-    multineat_params.ActivationFunction_UnsignedStep_Prob = 0.0
-    multineat_params.ActivationFunction_SignedGauss_Prob = 1.0
-    multineat_params.ActivationFunction_UnsignedGauss_Prob = 0.0
-    multineat_params.ActivationFunction_Abs_Prob = 0.0
-    multineat_params.ActivationFunction_SignedSine_Prob = 1.0
-    multineat_params.ActivationFunction_UnsignedSine_Prob = 0.0
-    multineat_params.ActivationFunction_Linear_Prob = 1.0
-
-    multineat_params.MutateNeuronTraitsProb = 0.0
-    multineat_params.MutateLinkTraitsProb = 0.0
-
-    multineat_params.AllowLoops = False
-    return multineat_params
+import multineat
+
+
+def get_multineat_params() -> multineat.Parameters:
+    """
+    Get Multineat Parameters.
+
+    :returns: The parameters.
+    """
+    multineat_params = multineat.Parameters()
+
+    multineat_params.MutateRemLinkProb = 0.02
+    multineat_params.RecurrentProb = 0.0
+    multineat_params.OverallMutationRate = 0.15
+    multineat_params.MutateAddLinkProb = 0.08
+    multineat_params.MutateAddNeuronProb = 0.01
+    multineat_params.MutateWeightsProb = 0.90
+    multineat_params.MaxWeight = 8.0
+    multineat_params.WeightMutationMaxPower = 0.2
+    multineat_params.WeightReplacementMaxPower = 1.0
+    multineat_params.MutateActivationAProb = 0.0
+    multineat_params.ActivationAMutationMaxPower = 0.5
+    multineat_params.MinActivationA = 0.05
+    multineat_params.MaxActivationA = 6.0
+
+    multineat_params.MutateNeuronActivationTypeProb = 0.03
+
+    multineat_params.MutateOutputActivationFunction = False
+
+    multineat_params.ActivationFunction_SignedSigmoid_Prob = 0.0
+    multineat_params.ActivationFunction_UnsignedSigmoid_Prob = 0.0
+    multineat_params.ActivationFunction_Tanh_Prob = 1.0
+    multineat_params.ActivationFunction_TanhCubic_Prob = 0.0
+    multineat_params.ActivationFunction_SignedStep_Prob = 1.0
+    multineat_params.ActivationFunction_UnsignedStep_Prob = 0.0
+    multineat_params.ActivationFunction_SignedGauss_Prob = 1.0
+    multineat_params.ActivationFunction_UnsignedGauss_Prob = 0.0
+    multineat_params.ActivationFunction_Abs_Prob = 0.0
+    multineat_params.ActivationFunction_SignedSine_Prob = 1.0
+    multineat_params.ActivationFunction_UnsignedSine_Prob = 0.0
+    multineat_params.ActivationFunction_Linear_Prob = 1.0
+
+    multineat_params.MutateNeuronTraitsProb = 0.0
+    multineat_params.MutateLinkTraitsProb = 0.0
+
+    multineat_params.AllowLoops = False
+    return multineat_params
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/__init__.py

```diff
@@ -1,5 +1,6 @@
-"""Body Genotype Mapping for V1 Robot."""
-from ._body_genotype_orm_v1 import BodyGenotypeOrmV1
-from ._body_genotype_v1 import BodyGenotypeV1
-
-__all__ = ["BodyGenotypeOrmV1", "BodyGenotypeV1"]
+"""Body Genotype Mapping for V1 Robot."""
+
+from ._body_genotype_orm_v1 import BodyGenotypeOrmV1
+from ._body_genotype_v1 import BodyGenotypeV1
+
+__all__ = ["BodyGenotypeOrmV1", "BodyGenotypeV1"]
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_develop.py

 * *Ordering differences only*

```diff
@@ -1,164 +1,164 @@
-from dataclasses import dataclass
-from queue import Queue
-from typing import Any
-
-import multineat
-import numpy as np
-from numpy.typing import NDArray
-from pyrr import Quaternion, Vector3
-
-from revolve2.modular_robot.body import AttachmentPoint, Module
-from revolve2.modular_robot.body.v1 import ActiveHingeV1, BodyV1, BrickV1
-
-
-@dataclass
-class __Module:
-    position: Vector3[np.int_]
-    forward: Vector3[np.int_]
-    up: Vector3[np.int_]
-    chain_length: int
-    module_reference: Module
-
-
-def develop(
-    genotype: multineat.Genome,
-) -> BodyV1:
-    """
-    Develop a CPPNWIN genotype into a modular robot body.
-
-    It is important that the genotype was created using a compatible function.
-
-    :param genotype: The genotype to create the body from.
-    :returns: The created body.
-    """
-    max_parts = 10
-
-    body_net = multineat.NeuralNetwork()
-    genotype.BuildPhenotype(body_net)
-
-    to_explore: Queue[__Module] = Queue()
-    grid = np.zeros(
-        shape=(max_parts * 2 + 1, max_parts * 2 + 1, max_parts * 2 + 1), dtype=np.uint8
-    )
-
-    body = BodyV1()
-
-    core_position = Vector3(
-        [max_parts + 1, max_parts + 1, max_parts + 1], dtype=np.int_
-    )
-    to_explore.put(
-        __Module(
-            core_position,
-            Vector3([0, -1, 0], dtype=np.int_),
-            Vector3([0, 0, 1], dtype=np.int_),
-            0,
-            body.core,
-        )
-    )
-    grid[tuple(core_position)] = 1
-    part_count = 1
-
-    while not to_explore.empty():
-        module = to_explore.get()
-
-        for attachment_point_tuple in module.module_reference.attachment_points.items():
-            if part_count < max_parts:
-                child = __add_child(body_net, module, attachment_point_tuple, grid)
-                if child is not None:
-                    to_explore.put(child)
-                    part_count += 1
-    return body
-
-
-def __evaluate_cppn(
-    body_net: multineat.NeuralNetwork,
-    position: Vector3[np.int_],
-    chain_length: int,
-) -> tuple[Any, int]:
-    """
-    Get module type and orientation from a multineat CPPN network.
-
-    :param body_net: The CPPN network.
-    :param position: Position of the module.
-    :param chain_length: Tree distance of the module from the core.
-    :returns: (module type, rotation_index)
-    """
-    x, y, z = position
-    assert isinstance(
-        x, np.int_
-    ), f"Error: The position is not of type int. Type: {type(x)}."
-    body_net.Input([1.0, x, y, z, chain_length])  # 1.0 is the bias input
-    body_net.ActivateAllLayers()
-    outputs = body_net.Output()
-
-    # get module type from output probabilities
-    type_probs = list(outputs[:3])
-    types = [None, BrickV1, ActiveHingeV1]
-    module_type = types[type_probs.index(min(type_probs))]
-
-    # get rotation from output probabilities
-    rotation_probs = list(outputs[3:5])
-    rotation_index = rotation_probs.index(min(rotation_probs))
-
-    return module_type, rotation_index
-
-
-def __add_child(
-    body_net: multineat.NeuralNetwork,
-    module: __Module,
-    attachment_point_tuple: tuple[int, AttachmentPoint],
-    grid: NDArray[np.uint8],
-) -> __Module | None:
-    attachment_index, attachment_point = attachment_point_tuple
-
-    forward = __rotate(module.forward, module.up, attachment_point.orientation)
-    position = __vec3_int(module.position + forward)
-    chain_length = module.chain_length + 1
-
-    # if grid cell is occupied, don't make a child
-    if grid[tuple(position)] > 0:
-        return None
-    grid[tuple(position)] += 1
-
-    child_type, child_rotation = __evaluate_cppn(body_net, position, chain_length)
-    if child_type is None:
-        return None
-    angle = child_rotation * (np.pi / 2.0)
-    up = __rotate(module.up, forward, Quaternion.from_eulers([angle, 0, 0]))
-    child = child_type(angle)
-    module.module_reference.set_child(child, attachment_index)
-
-    return __Module(
-        position,
-        forward,
-        up,
-        chain_length,
-        child,
-    )
-
-
-def __rotate(a: Vector3, b: Vector3, rotation: Quaternion) -> Vector3:
-    """
-    Rotates vector a a given angle around b.
-
-    :param a: Vector a.
-    :param b: Vector b.
-    :param rotation: The quaternion for rotation.
-    :returns: A copy of a, rotated.
-    """
-    cosangle: int = int(round(np.cos(rotation.angle)))
-    sinangle: int = int(round(np.sin(rotation.angle)))
-
-    vec: Vector3 = a * cosangle + sinangle * b.cross(a) + (1 - cosangle) * b.dot(a) * b
-    return vec
-
-
-def __vec3_int(vector: Vector3) -> Vector3[np.int_]:
-    """
-    Cast a Vector3 object to an integer only Vector3.
-
-    :param vector: The vector.
-    :return: The integer vector.
-    """
-    x, y, z = map(lambda v: int(round(v)), vector)
-    return Vector3([x, y, z], dtype=np.int64)
+from dataclasses import dataclass
+from queue import Queue
+from typing import Any
+
+import multineat
+import numpy as np
+from numpy.typing import NDArray
+from pyrr import Quaternion, Vector3
+
+from revolve2.modular_robot.body import AttachmentPoint, Module
+from revolve2.modular_robot.body.v1 import ActiveHingeV1, BodyV1, BrickV1
+
+
+@dataclass
+class __Module:
+    position: Vector3[np.int_]
+    forward: Vector3[np.int_]
+    up: Vector3[np.int_]
+    chain_length: int
+    module_reference: Module
+
+
+def develop(
+    genotype: multineat.Genome,
+) -> BodyV1:
+    """
+    Develop a CPPNWIN genotype into a modular robot body.
+
+    It is important that the genotype was created using a compatible function.
+
+    :param genotype: The genotype to create the body from.
+    :returns: The created body.
+    """
+    max_parts = 10
+
+    body_net = multineat.NeuralNetwork()
+    genotype.BuildPhenotype(body_net)
+
+    to_explore: Queue[__Module] = Queue()
+    grid = np.zeros(
+        shape=(max_parts * 2 + 1, max_parts * 2 + 1, max_parts * 2 + 1), dtype=np.uint8
+    )
+
+    body = BodyV1()
+
+    core_position = Vector3(
+        [max_parts + 1, max_parts + 1, max_parts + 1], dtype=np.int_
+    )
+    to_explore.put(
+        __Module(
+            core_position,
+            Vector3([0, -1, 0], dtype=np.int_),
+            Vector3([0, 0, 1], dtype=np.int_),
+            0,
+            body.core,
+        )
+    )
+    grid[tuple(core_position)] = 1
+    part_count = 1
+
+    while not to_explore.empty():
+        module = to_explore.get()
+
+        for attachment_point_tuple in module.module_reference.attachment_points.items():
+            if part_count < max_parts:
+                child = __add_child(body_net, module, attachment_point_tuple, grid)
+                if child is not None:
+                    to_explore.put(child)
+                    part_count += 1
+    return body
+
+
+def __evaluate_cppn(
+    body_net: multineat.NeuralNetwork,
+    position: Vector3[np.int_],
+    chain_length: int,
+) -> tuple[Any, int]:
+    """
+    Get module type and orientation from a multineat CPPN network.
+
+    :param body_net: The CPPN network.
+    :param position: Position of the module.
+    :param chain_length: Tree distance of the module from the core.
+    :returns: (module type, rotation_index)
+    """
+    x, y, z = position
+    assert isinstance(
+        x, np.int_
+    ), f"Error: The position is not of type int. Type: {type(x)}."
+    body_net.Input([1.0, x, y, z, chain_length])  # 1.0 is the bias input
+    body_net.ActivateAllLayers()
+    outputs = body_net.Output()
+
+    # get module type from output probabilities
+    type_probs = list(outputs[:3])
+    types = [None, BrickV1, ActiveHingeV1]
+    module_type = types[type_probs.index(min(type_probs))]
+
+    # get rotation from output probabilities
+    rotation_probs = list(outputs[3:5])
+    rotation_index = rotation_probs.index(min(rotation_probs))
+
+    return module_type, rotation_index
+
+
+def __add_child(
+    body_net: multineat.NeuralNetwork,
+    module: __Module,
+    attachment_point_tuple: tuple[int, AttachmentPoint],
+    grid: NDArray[np.uint8],
+) -> __Module | None:
+    attachment_index, attachment_point = attachment_point_tuple
+
+    forward = __rotate(module.forward, module.up, attachment_point.orientation)
+    position = __vec3_int(module.position + forward)
+    chain_length = module.chain_length + 1
+
+    # if grid cell is occupied, don't make a child
+    if grid[tuple(position)] > 0:
+        return None
+    grid[tuple(position)] += 1
+
+    child_type, child_rotation = __evaluate_cppn(body_net, position, chain_length)
+    if child_type is None:
+        return None
+    angle = child_rotation * (np.pi / 2.0)
+    up = __rotate(module.up, forward, Quaternion.from_eulers([angle, 0, 0]))
+    child = child_type(angle)
+    module.module_reference.set_child(child, attachment_index)
+
+    return __Module(
+        position,
+        forward,
+        up,
+        chain_length,
+        child,
+    )
+
+
+def __rotate(a: Vector3, b: Vector3, rotation: Quaternion) -> Vector3:
+    """
+    Rotates vector a a given angle around b.
+
+    :param a: Vector a.
+    :param b: Vector b.
+    :param rotation: The quaternion for rotation.
+    :returns: A copy of a, rotated.
+    """
+    cosangle: int = int(round(np.cos(rotation.angle)))
+    sinangle: int = int(round(np.sin(rotation.angle)))
+
+    vec: Vector3 = a * cosangle + sinangle * b.cross(a) + (1 - cosangle) * b.dot(a) * b
+    return vec
+
+
+def __vec3_int(vector: Vector3) -> Vector3[np.int_]:
+    """
+    Cast a Vector3 object to an integer only Vector3.
+
+    :param vector: The vector.
+    :return: The integer vector.
+    """
+    x, y, z = map(lambda v: int(round(v)), vector)
+    return Vector3([x, y, z], dtype=np.int64)
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_orm_v1.py

 * *Ordering differences only*

```diff
@@ -1,133 +1,133 @@
-from __future__ import annotations
-
-import multineat
-import numpy as np
-import sqlalchemy.orm as orm
-from sqlalchemy import event
-from sqlalchemy.engine import Connection
-from typing_extensions import Self
-
-from revolve2.modular_robot.body.v1 import BodyV1
-
-from ..._multineat_rng_from_random import multineat_rng_from_random
-from ..._random_multineat_genotype import random_multineat_genotype
-from .._multineat_params import get_multineat_params
-from ._body_develop import develop
-
-
-class BodyGenotypeOrmV1(orm.MappedAsDataclass, kw_only=True):
-    """SQLAlchemy model for a CPPNWIN body genotype."""
-
-    _NUM_INITIAL_MUTATIONS = 5
-    _MULTINEAT_PARAMS = get_multineat_params()
-
-    body: multineat.Genome
-
-    _serialized_body: orm.Mapped[str] = orm.mapped_column(
-        "serialized_body", init=False, nullable=False
-    )
-
-    @classmethod
-    def random_body(
-        cls,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeOrmV1:
-        """
-        Create a random genotype.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: The created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        body = random_multineat_genotype(
-            innov_db=innov_db,
-            rng=multineat_rng,
-            multineat_params=cls._MULTINEAT_PARAMS,
-            output_activation_func=multineat.ActivationFunction.TANH,
-            num_inputs=5,  # bias(always 1), pos_x, pos_y, pos_z, chain_length
-            num_outputs=5,  # empty, brick, activehinge, rot0, rot90
-            num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
-        )
-
-        return BodyGenotypeOrmV1(body=body)
-
-    def mutate_body(
-        self,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeOrmV1:
-        """
-        Mutate this genotype.
-
-        This genotype will not be changed; a mutated copy will be returned.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: A mutated copy of the provided genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BodyGenotypeOrmV1(
-            body=self.body.MutateWithConstraints(
-                False,
-                multineat.SearchMode.BLENDED,
-                innov_db,
-                self._MULTINEAT_PARAMS,
-                multineat_rng,
-            )
-        )
-
-    @classmethod
-    def crossover_body(
-        cls,
-        parent1: Self,
-        parent2: Self,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeOrmV1:
-        """
-        Perform crossover between two genotypes.
-
-        :param parent1: The first genotype.
-        :param parent2: The second genotype.
-        :param rng: Random number generator.
-        :returns: A newly created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BodyGenotypeOrmV1(
-            body=parent1.body.MateWithConstraints(
-                parent2.body,
-                False,
-                False,
-                multineat_rng,
-                cls._MULTINEAT_PARAMS,
-            )
-        )
-
-    def develop_body(self) -> BodyV1:
-        """
-        Develop the genotype into a modular robot.
-
-        :returns: The created robot.
-        """
-        return develop(self.body)
-
-
-@event.listens_for(BodyGenotypeOrmV1, "before_update", propagate=True)
-@event.listens_for(BodyGenotypeOrmV1, "before_insert", propagate=True)
-def _update_serialized_body(
-    mapper: orm.Mapper[BodyGenotypeOrmV1],
-    connection: Connection,
-    target: BodyGenotypeOrmV1,
-) -> None:
-    target._serialized_body = target.body.Serialize()
-
-
-@event.listens_for(BodyGenotypeOrmV1, "load", propagate=True)
-def _deserialize_body(target: BodyGenotypeOrmV1, context: orm.QueryContext) -> None:
-    body = multineat.Genome()
-    body.Deserialize(target._serialized_body)
-    target.body = body
+from __future__ import annotations
+
+import multineat
+import numpy as np
+import sqlalchemy.orm as orm
+from sqlalchemy import event
+from sqlalchemy.engine import Connection
+from typing_extensions import Self
+
+from revolve2.modular_robot.body.v1 import BodyV1
+
+from ..._multineat_rng_from_random import multineat_rng_from_random
+from ..._random_multineat_genotype import random_multineat_genotype
+from .._multineat_params import get_multineat_params
+from ._body_develop import develop
+
+
+class BodyGenotypeOrmV1(orm.MappedAsDataclass, kw_only=True):
+    """SQLAlchemy model for a CPPNWIN body genotype."""
+
+    _NUM_INITIAL_MUTATIONS = 5
+    _MULTINEAT_PARAMS = get_multineat_params()
+
+    body: multineat.Genome
+
+    _serialized_body: orm.Mapped[str] = orm.mapped_column(
+        "serialized_body", init=False, nullable=False
+    )
+
+    @classmethod
+    def random_body(
+        cls,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeOrmV1:
+        """
+        Create a random genotype.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: The created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        body = random_multineat_genotype(
+            innov_db=innov_db,
+            rng=multineat_rng,
+            multineat_params=cls._MULTINEAT_PARAMS,
+            output_activation_func=multineat.ActivationFunction.TANH,
+            num_inputs=5,  # bias(always 1), pos_x, pos_y, pos_z, chain_length
+            num_outputs=5,  # empty, brick, activehinge, rot0, rot90
+            num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
+        )
+
+        return BodyGenotypeOrmV1(body=body)
+
+    def mutate_body(
+        self,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeOrmV1:
+        """
+        Mutate this genotype.
+
+        This genotype will not be changed; a mutated copy will be returned.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: A mutated copy of the provided genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BodyGenotypeOrmV1(
+            body=self.body.MutateWithConstraints(
+                False,
+                multineat.SearchMode.BLENDED,
+                innov_db,
+                self._MULTINEAT_PARAMS,
+                multineat_rng,
+            )
+        )
+
+    @classmethod
+    def crossover_body(
+        cls,
+        parent1: Self,
+        parent2: Self,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeOrmV1:
+        """
+        Perform crossover between two genotypes.
+
+        :param parent1: The first genotype.
+        :param parent2: The second genotype.
+        :param rng: Random number generator.
+        :returns: A newly created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BodyGenotypeOrmV1(
+            body=parent1.body.MateWithConstraints(
+                parent2.body,
+                False,
+                False,
+                multineat_rng,
+                cls._MULTINEAT_PARAMS,
+            )
+        )
+
+    def develop_body(self) -> BodyV1:
+        """
+        Develop the genotype into a modular robot.
+
+        :returns: The created robot.
+        """
+        return develop(self.body)
+
+
+@event.listens_for(BodyGenotypeOrmV1, "before_update", propagate=True)
+@event.listens_for(BodyGenotypeOrmV1, "before_insert", propagate=True)
+def _update_serialized_body(
+    mapper: orm.Mapper[BodyGenotypeOrmV1],
+    connection: Connection,
+    target: BodyGenotypeOrmV1,
+) -> None:
+    target._serialized_body = target.body.Serialize()
+
+
+@event.listens_for(BodyGenotypeOrmV1, "load", propagate=True)
+def _deserialize_body(target: BodyGenotypeOrmV1, context: orm.QueryContext) -> None:
+    body = multineat.Genome()
+    body.Deserialize(target._serialized_body)
+    target.body = body
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_v1.py

 * *Ordering differences only*

```diff
@@ -1,118 +1,118 @@
-from __future__ import annotations
-
-from dataclasses import dataclass
-
-import multineat
-import numpy as np
-from typing_extensions import Self
-
-from revolve2.modular_robot.body.v1 import BodyV1
-
-from ..._multineat_genotype_pickle_wrapper import MultineatGenotypePickleWrapper
-from ..._multineat_rng_from_random import multineat_rng_from_random
-from ..._random_multineat_genotype import random_multineat_genotype
-from .._multineat_params import get_multineat_params
-from ._body_develop import develop
-
-
-@dataclass
-class BodyGenotypeV1:
-    """CPPNWIN body genotype."""
-
-    _NUM_INITIAL_MUTATIONS = 5
-    _MULTINEAT_PARAMS = get_multineat_params()
-    body: MultineatGenotypePickleWrapper
-
-    @classmethod
-    def random_body(
-        cls,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeV1:
-        """
-        Create a random genotype.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: The created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        body = MultineatGenotypePickleWrapper(
-            random_multineat_genotype(
-                innov_db=innov_db,
-                rng=multineat_rng,
-                multineat_params=cls._MULTINEAT_PARAMS,
-                output_activation_func=multineat.ActivationFunction.TANH,
-                num_inputs=5,  # bias(always 1), pos_x, pos_y, pos_z, chain_length
-                num_outputs=5,  # empty, brick, activehinge, rot0, rot90
-                num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
-            )
-        )
-
-        return BodyGenotypeV1(body)
-
-    def mutate_body(
-        self,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeV1:
-        """
-        Mutate this genotype.
-
-        This genotype will not be changed; a mutated copy will be returned.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: A mutated copy of the provided genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BodyGenotypeV1(
-            MultineatGenotypePickleWrapper(
-                self.body.genotype.MutateWithConstraints(
-                    False,
-                    multineat.SearchMode.BLENDED,
-                    innov_db,
-                    self._MULTINEAT_PARAMS,
-                    multineat_rng,
-                )
-            )
-        )
-
-    @classmethod
-    def crossover_body(
-        cls,
-        parent1: Self,
-        parent2: Self,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeV1:
-        """
-        Perform crossover between two genotypes.
-
-        :param parent1: The first genotype.
-        :param parent2: The second genotype.
-        :param rng: Random number generator.
-        :returns: A newly created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BodyGenotypeV1(
-            MultineatGenotypePickleWrapper(
-                parent1.body.genotype.MateWithConstraints(
-                    parent2.body.genotype,
-                    False,
-                    False,
-                    multineat_rng,
-                    cls._MULTINEAT_PARAMS,
-                )
-            )
-        )
-
-    def develop_body(self) -> BodyV1:
-        """
-        Develop the genotype into a modular robot.
-
-        :returns: The created robot.
-        """
-        return develop(self.body.genotype)
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+import multineat
+import numpy as np
+from typing_extensions import Self
+
+from revolve2.modular_robot.body.v1 import BodyV1
+
+from ..._multineat_genotype_pickle_wrapper import MultineatGenotypePickleWrapper
+from ..._multineat_rng_from_random import multineat_rng_from_random
+from ..._random_multineat_genotype import random_multineat_genotype
+from .._multineat_params import get_multineat_params
+from ._body_develop import develop
+
+
+@dataclass
+class BodyGenotypeV1:
+    """CPPNWIN body genotype."""
+
+    _NUM_INITIAL_MUTATIONS = 5
+    _MULTINEAT_PARAMS = get_multineat_params()
+    body: MultineatGenotypePickleWrapper
+
+    @classmethod
+    def random_body(
+        cls,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeV1:
+        """
+        Create a random genotype.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: The created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        body = MultineatGenotypePickleWrapper(
+            random_multineat_genotype(
+                innov_db=innov_db,
+                rng=multineat_rng,
+                multineat_params=cls._MULTINEAT_PARAMS,
+                output_activation_func=multineat.ActivationFunction.TANH,
+                num_inputs=5,  # bias(always 1), pos_x, pos_y, pos_z, chain_length
+                num_outputs=5,  # empty, brick, activehinge, rot0, rot90
+                num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
+            )
+        )
+
+        return BodyGenotypeV1(body)
+
+    def mutate_body(
+        self,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeV1:
+        """
+        Mutate this genotype.
+
+        This genotype will not be changed; a mutated copy will be returned.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: A mutated copy of the provided genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BodyGenotypeV1(
+            MultineatGenotypePickleWrapper(
+                self.body.genotype.MutateWithConstraints(
+                    False,
+                    multineat.SearchMode.BLENDED,
+                    innov_db,
+                    self._MULTINEAT_PARAMS,
+                    multineat_rng,
+                )
+            )
+        )
+
+    @classmethod
+    def crossover_body(
+        cls,
+        parent1: Self,
+        parent2: Self,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeV1:
+        """
+        Perform crossover between two genotypes.
+
+        :param parent1: The first genotype.
+        :param parent2: The second genotype.
+        :param rng: Random number generator.
+        :returns: A newly created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BodyGenotypeV1(
+            MultineatGenotypePickleWrapper(
+                parent1.body.genotype.MateWithConstraints(
+                    parent2.body.genotype,
+                    False,
+                    False,
+                    multineat_rng,
+                    cls._MULTINEAT_PARAMS,
+                )
+            )
+        )
+
+    def develop_body(self) -> BodyV1:
+        """
+        Develop the genotype into a modular robot.
+
+        :returns: The created robot.
+        """
+        return develop(self.body.genotype)
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/__init__.py

```diff
@@ -1,5 +1,6 @@
-"""Body Genotype Mapping for V1 Robot."""
-from ._body_genotype_orm_v2 import BodyGenotypeOrmV2
-from ._body_genotype_v2 import BodyGenotypeV2
-
-__all__ = ["BodyGenotypeOrmV2", "BodyGenotypeV2"]
+"""Body Genotype Mapping for V1 Robot."""
+
+from ._body_genotype_orm_v2 import BodyGenotypeOrmV2
+from ._body_genotype_v2 import BodyGenotypeV2
+
+__all__ = ["BodyGenotypeOrmV2", "BodyGenotypeV2"]
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_develop.py

```diff
@@ -1,173 +1,180 @@
-from dataclasses import dataclass
-from queue import Queue
-from typing import Any
-
-import multineat
-import numpy as np
-from numpy.typing import NDArray
-from pyrr import Quaternion, Vector3
-
-from revolve2.modular_robot.body import AttachmentPoint, Module
-from revolve2.modular_robot.body.v2 import ActiveHingeV2, BodyV2, BrickV2
-
-
-@dataclass
-class __Module:
-    position: Vector3[np.int_]
-    forward: Vector3[np.int_]
-    up: Vector3[np.int_]
-    chain_length: int
-    module_reference: Module
-
-
-def develop(
-    genotype: multineat.Genome,
-) -> BodyV2:
-    """
-    Develop a CPPNWIN genotype into a modular robot body.
-
-    It is important that the genotype was created using a compatible function.
-
-    :param genotype: The genotype to create the body from.
-    :returns: The create body.
-    """
-    max_parts = 20
-
-    body_net = multineat.NeuralNetwork()
-    genotype.BuildPhenotype(body_net)
-
-    to_explore: Queue[__Module] = Queue()
-    grid = np.zeros(
-        shape=(max_parts * 2 + 1, max_parts * 2 + 1, max_parts * 2 + 1), dtype=np.uint8
-    )
-
-    body = BodyV2()
-
-    v2_core = body.core_v2
-    core_position = Vector3(
-        [max_parts + 1, max_parts + 1, max_parts + 1], dtype=np.int_
-    )
-    grid[tuple(core_position)] = 1
-    part_count = 1
-
-    for attachment_face in v2_core.attachment_faces.values():
-        to_explore.put(
-            __Module(
-                core_position,
-                Vector3([0, -1, 0]),
-                Vector3([0, 0, 1]),
-                0,
-                attachment_face,
-            )
-        )
-
-    while not to_explore.empty():
-        module = to_explore.get()
-
-        for attachment_point_tuple in module.module_reference.attachment_points.items():
-            if part_count < max_parts:
-                child = __add_child(body_net, module, attachment_point_tuple, grid)
-                if child is not None:
-                    to_explore.put(child)
-                    part_count += 1
-    return body
-
-
-def __evaluate_cppn(
-    body_net: multineat.NeuralNetwork,
-    position: Vector3[np.int_],
-    chain_length: int,
-) -> tuple[Any, int]:
-    """
-    Get module type and orientation from a multineat CPPN network.
-
-    :param body_net: The CPPN network.
-    :param position: Position of the module.
-    :param chain_length: Tree distance of the module from the core.
-    :returns: (module type, rotation_index)
-    """
-    x, y, z = position
-    assert isinstance(
-        x, np.int_
-    ), f"Error: The position is not of type int. Type: {type(x)}."
-    body_net.Input([1.0, x, y, z, chain_length])  # 1.0 is the bias input
-    body_net.ActivateAllLayers()
-    outputs = body_net.Output()
-
-    # get module type from output probabilities
-    type_probs = list(outputs[:3])
-    types = [None, BrickV2, ActiveHingeV2]
-    module_type = types[type_probs.index(min(type_probs))]
-
-    # get rotation from output probabilities
-    rotation_probs = list(outputs[3:5])
-    rotation_index = rotation_probs.index(min(rotation_probs))
-
-    return module_type, rotation_index
-
-
-def __add_child(
-    body_net: multineat.NeuralNetwork,
-    module: __Module,
-    attachment_point_tuple: tuple[int, AttachmentPoint],
-    grid: NDArray[np.uint8],
-) -> __Module | None:
-    attachment_index, attachment_point = attachment_point_tuple
-
-    forward = __rotate(module.forward, module.up, attachment_point.orientation)
-    position = __vec3_int(module.position + forward)
-    chain_length = module.chain_length + 1
-
-    # if grid cell is occupied, don't make a child
-    # else, set cell as occupied
-    if grid[tuple(position)] > 0:
-        return None
-    grid[tuple(position)] += 1
-
-    new_pos = np.array(np.round(position + attachment_point.offset), dtype=np.int64)
-    child_type, child_rotation = __evaluate_cppn(body_net, new_pos, chain_length)
-    angle = child_rotation * (np.pi / 2.0)
-    if child_type is None or not module.module_reference.can_set_child(
-        child := child_type(angle), attachment_index
-    ):
-        return None
-
-    up = __rotate(module.up, forward, Quaternion.from_eulers([angle, 0, 0]))
-    module.module_reference.set_child(child, attachment_index)
-
-    return __Module(
-        position,
-        forward,
-        up,
-        chain_length,
-        child,
-    )
-
-
-def __rotate(a: Vector3, b: Vector3, rotation: Quaternion) -> Vector3:
-    """
-    Rotates vector a a given angle around b.
-
-    :param a: Vector a.
-    :param b: Vector b.
-    :param rotation: The quaternion for rotation.
-    :returns: A copy of a, rotated.
-    """
-    cos_angle: int = int(round(np.cos(rotation.angle)))
-    sin_angle: int = int(round(np.sin(rotation.angle)))
-
-    vec: Vector3 = (
-        a * cos_angle + sin_angle * b.cross(a) + (1 - cos_angle) * b.dot(a) * b
-    )
-    return vec
-
-
-def __vec3_int(vector: Vector3) -> Vector3[np.int_]:
-    """
-    Cast a Vector3 object to an integer only Vector3.
-
-    :param vector: The vector.
-    :return: The integer vector.
-    """
-    x, y, z = map(lambda v: int(round(v)), vector)
-    return Vector3([x, y, z], dtype=np.int64)
+from dataclasses import dataclass
+from queue import Queue
+from typing import Any
+
+import multineat
+import numpy as np
+from numpy.typing import NDArray
+from pyrr import Quaternion, Vector3
+
+from revolve2.modular_robot.body import AttachmentPoint, Module
+from revolve2.modular_robot.body.v2 import ActiveHingeV2, BodyV2, BrickV2
+
+
+@dataclass
+class __Module:
+    position: Vector3[np.int_]
+    forward: Vector3[np.int_]
+    up: Vector3[np.int_]
+    chain_length: int
+    module_reference: Module
+
+
+def develop(
+    genotype: multineat.Genome,
+) -> BodyV2:
+    """
+    Develop a CPPNWIN genotype into a modular robot body.
+
+    It is important that the genotype was created using a compatible function.
+
+    :param genotype: The genotype to create the body from.
+    :returns: The create body.
+    """
+    max_parts = 20  # Determine the maximum parts available for a robots body.
+    body_net = (
+        multineat.NeuralNetwork()
+    )  # Instantiate the CPPN network for body construction.
+    genotype.BuildPhenotype(body_net)  # Build the CPPN from the genotype of the robot.
+
+    to_explore: Queue[__Module] = (
+        Queue()
+    )  # Here we have a queue that is used to build our robot.
+    grid = np.zeros(
+        shape=(max_parts * 2 + 1, max_parts * 2 + 1, max_parts * 2 + 1), dtype=np.uint8
+    )
+
+    body = BodyV2()
+
+    core_position = Vector3(
+        [max_parts + 1, max_parts + 1, max_parts + 1], dtype=np.int_
+    )
+    grid[tuple(core_position)] = 1
+    part_count = 1
+
+    for attachment_face in body.core_v2.attachment_faces.values():
+        to_explore.put(
+            __Module(
+                core_position,
+                Vector3([0, -1, 0]),
+                Vector3([0, 0, 1]),
+                0,
+                attachment_face,
+            )
+        )
+
+    while not to_explore.empty():
+        module = to_explore.get()
+
+        for attachment_point_tuple in module.module_reference.attachment_points.items():
+            if part_count < max_parts:
+                child = __add_child(body_net, module, attachment_point_tuple, grid)
+                if child is not None:
+                    to_explore.put(child)
+                    part_count += 1
+    return body
+
+
+def __evaluate_cppn(
+    body_net: multineat.NeuralNetwork,
+    position: Vector3[np.int_],
+    chain_length: int,
+) -> tuple[Any, float]:
+    """
+    Get module type and orientation from a multineat CPPN network.
+
+    :param body_net: The CPPN network.
+    :param position: Position of the module.
+    :param chain_length: Tree distance of the module from the core.
+    :returns: (module type, angle)
+    """
+    x, y, z = position
+    assert isinstance(
+        x, np.int_
+    ), f"Error: The position is not of type int. Type: {type(x)}."
+    body_net.Input([1.0, x, y, z, chain_length])  # 1.0 is the bias input
+    body_net.ActivateAllLayers()
+    outputs = body_net.Output()
+
+    """We select the module type for the current position using the first output of the CPPN network."""
+    types = [None, BrickV2, ActiveHingeV2]
+    target_idx = max(0, int(outputs[0] * len(types) - 1e-6))
+    module_type = types[target_idx]
+
+    """
+    Here we get the rotation of the module from the second output of the CPPN network.
+    
+    The output ranges between [0,1] and we have 4 rotations available (0, 90, 180, 270).
+    """
+    angle = max(0, int(outputs[0] * 4 - 1e-6)) * (np.pi / 2.0)
+
+    return module_type, angle
+
+
+def __add_child(
+    body_net: multineat.NeuralNetwork,
+    module: __Module,
+    attachment_point_tuple: tuple[int, AttachmentPoint],
+    grid: NDArray[np.uint8],
+) -> __Module | None:
+    attachment_index, attachment_point = attachment_point_tuple
+
+    """Here we adjust the forward facing direction, and the position for the new potential module."""
+    forward = __rotate(module.forward, module.up, attachment_point.orientation)
+    position = __vec3_int(module.position + forward)
+    chain_length = module.chain_length + 1
+
+    """If grid cell is occupied, we don't make a child."""
+    if grid[tuple(position)] > 0:
+        return None
+
+    """Now we anjust the position for the potential new module to fit the attachment point of the parent, additionally we query the CPPN for child type and angle of the child."""
+    new_pos = np.array(np.round(position + attachment_point.offset), dtype=np.int64)
+    child_type, angle = __evaluate_cppn(body_net, new_pos, chain_length)
+
+    """Here we check whether the CPPN evaluated to place a module and if the module can be set on the parent."""
+    can_set = module.module_reference.can_set_child(attachment_index)
+    if (child_type is None) or (not can_set):
+        return None  # No module will be placed.
+
+    """Now we know we want a child on the parent and we instantiate it, add the position to the grid and adjust the up direction for the new module."""
+    child = child_type(angle)
+    grid[tuple(position)] += 1
+    up = __rotate(module.up, forward, Quaternion.from_eulers([angle, 0, 0]))
+    module.module_reference.set_child(child, attachment_index)
+
+    return __Module(
+        position,
+        forward,
+        up,
+        chain_length,
+        child,
+    )
+
+
+def __rotate(a: Vector3, b: Vector3, rotation: Quaternion) -> Vector3:
+    """
+    Rotates vector a, a given angle around b.
+
+    :param a: Vector a.
+    :param b: Vector b.
+    :param rotation: The quaternion for rotation.
+    :returns: A copy of a, rotated.
+    """
+    cos_angle: int = int(round(np.cos(rotation.angle)))
+    sin_angle: int = int(round(np.sin(rotation.angle)))
+
+    vec: Vector3 = (
+        a * cos_angle + sin_angle * b.cross(a) + (1 - cos_angle) * b.dot(a) * b
+    )
+    return vec
+
+
+def __vec3_int(vector: Vector3) -> Vector3[np.int_]:
+    """
+    Cast a Vector3 object to an integer only Vector3.
+
+    :param vector: The vector.
+    :return: The integer vector.
+    """
+    return Vector3(list(map(lambda v: int(round(v)), vector)), dtype=np.int64)
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_orm_v2.py

```diff
@@ -1,133 +1,133 @@
-from __future__ import annotations
-
-import multineat
-import numpy as np
-import sqlalchemy.orm as orm
-from sqlalchemy import event
-from sqlalchemy.engine import Connection
-from typing_extensions import Self
-
-from revolve2.modular_robot.body.v2 import BodyV2
-
-from ..._multineat_rng_from_random import multineat_rng_from_random
-from ..._random_multineat_genotype import random_multineat_genotype
-from .._multineat_params import get_multineat_params
-from ._body_develop import develop
-
-
-class BodyGenotypeOrmV2(orm.MappedAsDataclass, kw_only=True):
-    """SQLAlchemy model for a CPPNWIN body genotype."""
-
-    _NUM_INITIAL_MUTATIONS = 5
-    _MULTINEAT_PARAMS = get_multineat_params()
-
-    body: multineat.Genome
-
-    _serialized_body: orm.Mapped[str] = orm.mapped_column(
-        "serialized_body", init=False, nullable=False
-    )
-
-    @classmethod
-    def random_body(
-        cls,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeOrmV2:
-        """
-        Create a random genotype.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: The created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        body = random_multineat_genotype(
-            innov_db=innov_db,
-            rng=multineat_rng,
-            multineat_params=cls._MULTINEAT_PARAMS,
-            output_activation_func=multineat.ActivationFunction.TANH,
-            num_inputs=5,  # bias(always 1), pos_x, pos_y, pos_z, chain_length
-            num_outputs=5,  # empty, brick, activehinge, rot0, rot90
-            num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
-        )
-
-        return BodyGenotypeOrmV2(body=body)
-
-    def mutate_body(
-        self,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeOrmV2:
-        """
-        Mutate this genotype.
-
-        This genotype will not be changed; a mutated copy will be returned.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: A mutated copy of the provided genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BodyGenotypeOrmV2(
-            body=self.body.MutateWithConstraints(
-                False,
-                multineat.SearchMode.BLENDED,
-                innov_db,
-                self._MULTINEAT_PARAMS,
-                multineat_rng,
-            )
-        )
-
-    @classmethod
-    def crossover_body(
-        cls,
-        parent1: Self,
-        parent2: Self,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeOrmV2:
-        """
-        Perform crossover between two genotypes.
-
-        :param parent1: The first genotype.
-        :param parent2: The second genotype.
-        :param rng: Random number generator.
-        :returns: A newly created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BodyGenotypeOrmV2(
-            body=parent1.body.MateWithConstraints(
-                parent2.body,
-                False,
-                False,
-                multineat_rng,
-                cls._MULTINEAT_PARAMS,
-            )
-        )
-
-    def develop_body(self) -> BodyV2:
-        """
-        Develop the genotype into a modular robot.
-
-        :returns: The created robot.
-        """
-        return develop(self.body)
-
-
-@event.listens_for(BodyGenotypeOrmV2, "before_update", propagate=True)
-@event.listens_for(BodyGenotypeOrmV2, "before_insert", propagate=True)
-def _update_serialized_body(
-    mapper: orm.Mapper[BodyGenotypeOrmV2],
-    connection: Connection,
-    target: BodyGenotypeOrmV2,
-) -> None:
-    target._serialized_body = target.body.Serialize()
-
-
-@event.listens_for(BodyGenotypeOrmV2, "load", propagate=True)
-def _deserialize_body(target: BodyGenotypeOrmV2, context: orm.QueryContext) -> None:
-    body = multineat.Genome()
-    body.Deserialize(target._serialized_body)
-    target.body = body
+from __future__ import annotations
+
+import multineat
+import numpy as np
+import sqlalchemy.orm as orm
+from sqlalchemy import event
+from sqlalchemy.engine import Connection
+from typing_extensions import Self
+
+from revolve2.modular_robot.body.v2 import BodyV2
+
+from ..._multineat_rng_from_random import multineat_rng_from_random
+from ..._random_multineat_genotype import random_multineat_genotype
+from .._multineat_params import get_multineat_params
+from ._body_develop import develop
+
+
+class BodyGenotypeOrmV2(orm.MappedAsDataclass, kw_only=True):
+    """SQLAlchemy model for a CPPNWIN body genotype."""
+
+    _NUM_INITIAL_MUTATIONS = 5
+    _MULTINEAT_PARAMS = get_multineat_params()
+
+    body: multineat.Genome
+
+    _serialized_body: orm.Mapped[str] = orm.mapped_column(
+        "serialized_body", init=False, nullable=False
+    )
+
+    @classmethod
+    def random_body(
+        cls,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeOrmV2:
+        """
+        Create a random genotype.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: The created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        body = random_multineat_genotype(
+            innov_db=innov_db,
+            rng=multineat_rng,
+            multineat_params=cls._MULTINEAT_PARAMS,
+            output_activation_func=multineat.ActivationFunction.UNSIGNED_SINE,
+            num_inputs=5,  # bias(always 1), pos_x, pos_y, pos_z, chain_length
+            num_outputs=2,  # block_type, rotation_type
+            num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
+        )
+
+        return BodyGenotypeOrmV2(body=body)
+
+    def mutate_body(
+        self,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeOrmV2:
+        """
+        Mutate this genotype.
+
+        This genotype will not be changed; a mutated copy will be returned.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: A mutated copy of the provided genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BodyGenotypeOrmV2(
+            body=self.body.MutateWithConstraints(
+                False,
+                multineat.SearchMode.BLENDED,
+                innov_db,
+                self._MULTINEAT_PARAMS,
+                multineat_rng,
+            )
+        )
+
+    @classmethod
+    def crossover_body(
+        cls,
+        parent1: Self,
+        parent2: Self,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeOrmV2:
+        """
+        Perform crossover between two genotypes.
+
+        :param parent1: The first genotype.
+        :param parent2: The second genotype.
+        :param rng: Random number generator.
+        :returns: A newly created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BodyGenotypeOrmV2(
+            body=parent1.body.MateWithConstraints(
+                parent2.body,
+                False,
+                False,
+                multineat_rng,
+                cls._MULTINEAT_PARAMS,
+            )
+        )
+
+    def develop_body(self) -> BodyV2:
+        """
+        Develop the genotype into a modular robot.
+
+        :returns: The created robot.
+        """
+        return develop(self.body)
+
+
+@event.listens_for(BodyGenotypeOrmV2, "before_update", propagate=True)
+@event.listens_for(BodyGenotypeOrmV2, "before_insert", propagate=True)
+def _update_serialized_body(
+    mapper: orm.Mapper[BodyGenotypeOrmV2],
+    connection: Connection,
+    target: BodyGenotypeOrmV2,
+) -> None:
+    target._serialized_body = target.body.Serialize()
+
+
+@event.listens_for(BodyGenotypeOrmV2, "load", propagate=True)
+def _deserialize_body(target: BodyGenotypeOrmV2, context: orm.QueryContext) -> None:
+    body = multineat.Genome()
+    body.Deserialize(target._serialized_body)
+    target.body = body
```

## revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_v2.py

```diff
@@ -1,118 +1,118 @@
-from __future__ import annotations
-
-from dataclasses import dataclass
-
-import multineat
-import numpy as np
-from typing_extensions import Self
-
-from revolve2.modular_robot.body.v2 import BodyV2
-
-from ..._multineat_genotype_pickle_wrapper import MultineatGenotypePickleWrapper
-from ..._multineat_rng_from_random import multineat_rng_from_random
-from ..._random_multineat_genotype import random_multineat_genotype
-from .._multineat_params import get_multineat_params
-from ._body_develop import develop
-
-
-@dataclass
-class BodyGenotypeV2:
-    """CPPNWIN body genotype."""
-
-    _NUM_INITIAL_MUTATIONS = 5
-    _MULTINEAT_PARAMS = get_multineat_params()
-    body: MultineatGenotypePickleWrapper
-
-    @classmethod
-    def random_body(
-        cls,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeV2:
-        """
-        Create a random genotype.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: The created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        body = MultineatGenotypePickleWrapper(
-            random_multineat_genotype(
-                innov_db=innov_db,
-                rng=multineat_rng,
-                multineat_params=cls._MULTINEAT_PARAMS,
-                output_activation_func=multineat.ActivationFunction.TANH,
-                num_inputs=5,  # bias(always 1), pos_x, pos_y, pos_z, chain_length
-                num_outputs=5,  # empty, brick, activehinge, rot0, rot90
-                num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
-            )
-        )
-
-        return BodyGenotypeV2(body)
-
-    def mutate_body(
-        self,
-        innov_db: multineat.InnovationDatabase,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeV2:
-        """
-        Mutate this genotype.
-
-        This genotype will not be changed; a mutated copy will be returned.
-
-        :param innov_db: Multineat innovation database. See Multineat library.
-        :param rng: Random number generator.
-        :returns: A mutated copy of the provided genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BodyGenotypeV2(
-            MultineatGenotypePickleWrapper(
-                self.body.genotype.MutateWithConstraints(
-                    False,
-                    multineat.SearchMode.BLENDED,
-                    innov_db,
-                    self._MULTINEAT_PARAMS,
-                    multineat_rng,
-                )
-            )
-        )
-
-    @classmethod
-    def crossover_body(
-        cls,
-        parent1: Self,
-        parent2: Self,
-        rng: np.random.Generator,
-    ) -> BodyGenotypeV2:
-        """
-        Perform crossover between two genotypes.
-
-        :param parent1: The first genotype.
-        :param parent2: The second genotype.
-        :param rng: Random number generator.
-        :returns: A newly created genotype.
-        """
-        multineat_rng = multineat_rng_from_random(rng)
-
-        return BodyGenotypeV2(
-            MultineatGenotypePickleWrapper(
-                parent1.body.genotype.MateWithConstraints(
-                    parent2.body.genotype,
-                    False,
-                    False,
-                    multineat_rng,
-                    cls._MULTINEAT_PARAMS,
-                )
-            )
-        )
-
-    def develop_body(self) -> BodyV2:
-        """
-        Develop the genotype into a modular robot.
-
-        :returns: The created robot.
-        """
-        return develop(self.body.genotype)
+from __future__ import annotations
+
+from dataclasses import dataclass
+
+import multineat
+import numpy as np
+from typing_extensions import Self
+
+from revolve2.modular_robot.body.v2 import BodyV2
+
+from ..._multineat_genotype_pickle_wrapper import MultineatGenotypePickleWrapper
+from ..._multineat_rng_from_random import multineat_rng_from_random
+from ..._random_multineat_genotype import random_multineat_genotype
+from .._multineat_params import get_multineat_params
+from ._body_develop import develop
+
+
+@dataclass
+class BodyGenotypeV2:
+    """CPPNWIN body genotype."""
+
+    _NUM_INITIAL_MUTATIONS = 5
+    _MULTINEAT_PARAMS = get_multineat_params()
+    body: MultineatGenotypePickleWrapper
+
+    @classmethod
+    def random_body(
+        cls,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeV2:
+        """
+        Create a random genotype.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: The created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        body = MultineatGenotypePickleWrapper(
+            random_multineat_genotype(
+                innov_db=innov_db,
+                rng=multineat_rng,
+                multineat_params=cls._MULTINEAT_PARAMS,
+                output_activation_func=multineat.ActivationFunction.UNSIGNED_SINE,
+                num_inputs=5,  # bias(always 1), pos_x, pos_y, pos_z, chain_length
+                num_outputs=2,  # block_type, rotation_type
+                num_initial_mutations=cls._NUM_INITIAL_MUTATIONS,
+            )
+        )
+
+        return BodyGenotypeV2(body)
+
+    def mutate_body(
+        self,
+        innov_db: multineat.InnovationDatabase,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeV2:
+        """
+        Mutate this genotype.
+
+        This genotype will not be changed; a mutated copy will be returned.
+
+        :param innov_db: Multineat innovation database. See Multineat library.
+        :param rng: Random number generator.
+        :returns: A mutated copy of the provided genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BodyGenotypeV2(
+            MultineatGenotypePickleWrapper(
+                self.body.genotype.MutateWithConstraints(
+                    False,
+                    multineat.SearchMode.BLENDED,
+                    innov_db,
+                    self._MULTINEAT_PARAMS,
+                    multineat_rng,
+                )
+            )
+        )
+
+    @classmethod
+    def crossover_body(
+        cls,
+        parent1: Self,
+        parent2: Self,
+        rng: np.random.Generator,
+    ) -> BodyGenotypeV2:
+        """
+        Perform crossover between two genotypes.
+
+        :param parent1: The first genotype.
+        :param parent2: The second genotype.
+        :param rng: Random number generator.
+        :returns: A newly created genotype.
+        """
+        multineat_rng = multineat_rng_from_random(rng)
+
+        return BodyGenotypeV2(
+            MultineatGenotypePickleWrapper(
+                parent1.body.genotype.MateWithConstraints(
+                    parent2.body.genotype,
+                    False,
+                    False,
+                    multineat_rng,
+                    cls._MULTINEAT_PARAMS,
+                )
+            )
+        )
+
+    def develop_body(self) -> BodyV2:
+        """
+        Develop the genotype into a modular robot.
+
+        :returns: The created robot.
+        """
+        return develop(self.body.genotype)
```

## revolve2/ci_group/modular_robots_v1.py

```diff
@@ -1,806 +1,807 @@
-"""Standard modular robots."""
-import numpy as np
-
-from revolve2.modular_robot.body.v1 import ActiveHingeV1, BodyV1, BrickV1
-
-
-def all() -> list[BodyV1]:
-    """
-    Get a list of all standard module robots.
-
-    :returns: The list of robots.
-    """
-    return [
-        babya_v1(),
-        babyb_v1(),
-        blokky_v1(),
-        garrix_v1(),
-        gecko_v1(),
-        insect_v1(),
-        linkin_v1(),
-        longleg_v1(),
-        penguin_v1(),
-        pentapod_v1(),
-        queen_v1(),
-        salamander_v1(),
-        squarish_v1(),
-        snake_v1(),
-        spider_v1(),
-        stingray_v1(),
-        tinlicker_v1(),
-        turtle_v1(),
-        ww_v1(),
-        zappa_v1(),
-        ant_v1(),
-        park_v1(),
-    ]
-
-
-def spider_v1() -> BodyV1:
-    """
-    Get the spider modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.left.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.left.attachment.front = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment.front.attachment = BrickV1(0.0)
-
-    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.front = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.front.attachment = BrickV1(0.0)
-
-    body.core_v1.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.front.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.front.attachment.front = ActiveHingeV1(0.0)
-    body.core_v1.front.attachment.front.attachment = BrickV1(0.0)
-
-    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.front = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front.attachment = BrickV1(0.0)
-
-    return body
-
-
-def gecko_v1() -> BodyV1:
-    """
-    Get the gecko modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.left = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment = BrickV1(0.0)
-
-    body.core_v1.right = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment = BrickV1(0.0)
-
-    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment.front.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.front.attachment.left = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front.attachment.left.attachment = BrickV1(0.0)
-    body.core_v1.back.attachment.front.attachment.right = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front.attachment.right.attachment = BrickV1(0.0)
-
-    return body
-
-
-def babya_v1() -> BodyV1:
-    """
-    Get the babya modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.left = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment = BrickV1(0.0)
-
-    body.core_v1.right = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.front = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.front.attachment = BrickV1(0.0)
-
-    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment.front.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.front.attachment.left = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front.attachment.left.attachment = BrickV1(0.0)
-    body.core_v1.back.attachment.front.attachment.right = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front.attachment.right.attachment = BrickV1(0.0)
-
-    return body
-
-
-def ant_v1() -> BodyV1:
-    """
-    Get the ant modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.left = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment = BrickV1(0.0)
-
-    body.core_v1.right = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment = BrickV1(0.0)
-
-    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.left = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.left.attachment = BrickV1(0.0)
-    body.core_v1.back.attachment.right = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.right.attachment = BrickV1(0.0)
-
-    body.core_v1.back.attachment.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment.front.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.front.attachment.left = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front.attachment.left.attachment = BrickV1(0.0)
-    body.core_v1.back.attachment.front.attachment.right = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front.attachment.right.attachment = BrickV1(0.0)
-
-    return body
-
-
-def salamander_v1() -> BodyV1:
-    """
-    Get the salamander modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.left.attachment = ActiveHingeV1(-np.pi / 2.0)
-
-    body.core_v1.right = ActiveHingeV1(0.0)
-
-    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.left = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front = BrickV1(0.0)
-    body.core_v1.back.attachment.front.left = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment.front.front.attachment = BrickV1(-np.pi / 2.0)
-
-    body.core_v1.back.attachment.front.front.attachment.left = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front.front.attachment.left.attachment = BrickV1(0.0)
-    body.core_v1.back.attachment.front.front.attachment.left.attachment.left = BrickV1(
-        0.0
-    )
-    body.core_v1.back.attachment.front.front.attachment.left.attachment.front = (
-        ActiveHingeV1(np.pi / 2.0)
-    )
-    body.core_v1.back.attachment.front.front.attachment.left.attachment.front.attachment = ActiveHingeV1(
-        -np.pi / 2.0
-    )
-
-    body.core_v1.back.attachment.front.front.attachment.front = BrickV1(0.0)
-    body.core_v1.back.attachment.front.front.attachment.front.left = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.front.front.attachment.front.front = BrickV1(0.0)
-    body.core_v1.back.attachment.front.front.attachment.front.front.left = (
-        ActiveHingeV1(0.0)
-    )
-    body.core_v1.back.attachment.front.front.attachment.front.front.front = BrickV1(0.0)
-    body.core_v1.back.attachment.front.front.attachment.front.front.front.front = (
-        ActiveHingeV1(np.pi / 2.0)
-    )
-    body.core_v1.back.attachment.front.front.attachment.front.front.front.front.attachment = BrickV1(
-        -np.pi / 2.0
-    )
-    body.core_v1.back.attachment.front.front.attachment.front.front.front.front.attachment.left = BrickV1(
-        0.0
-    )
-    body.core_v1.back.attachment.front.front.attachment.front.front.front.front.attachment.front = ActiveHingeV1(
-        np.pi / 2.0
-    )
-
-    return body
-
-
-def blokky_v1() -> BodyV1:
-    """
-    Get the blokky modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back = BrickV1(0.0)
-    body.core_v1.back.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.front.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.back.front.attachment.attachment = BrickV1(0.0)
-    body.core_v1.back.front.attachment.attachment.front = BrickV1(0.0)
-    body.core_v1.back.front.attachment.attachment.front.right = BrickV1(0.0)
-    body.core_v1.back.front.attachment.attachment.front.right.left = BrickV1(0.0)
-    body.core_v1.back.front.attachment.attachment.front.right.front = BrickV1(0.0)
-    body.core_v1.back.front.attachment.attachment.right = BrickV1(0.0)
-    body.core_v1.back.front.attachment.attachment.right.front = BrickV1(0.0)
-    body.core_v1.back.front.attachment.attachment.right.front.right = BrickV1(0.0)
-    body.core_v1.back.front.attachment.attachment.right.front.front = ActiveHingeV1(0.0)
-
-    return body
-
-
-def park_v1() -> BodyV1:
-    """
-    Get the park modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.attachment = BrickV1(0.0)
-    body.core_v1.back.attachment.attachment.right = BrickV1(0.0)
-    body.core_v1.back.attachment.attachment.left = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.attachment.front = BrickV1(0.0)
-    body.core_v1.back.attachment.attachment.front.right = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.attachment.front.front = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.attachment.front.left = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.attachment.front.left.attachment = BrickV1(0.0)
-    body.core_v1.back.attachment.attachment.front.left.attachment.right = ActiveHingeV1(
-        -np.pi / 2.0
-    )
-    body.core_v1.back.attachment.attachment.front.left.attachment.left = BrickV1(0.0)
-    body.core_v1.back.attachment.attachment.front.left.attachment.front = ActiveHingeV1(
-        0.0
-    )
-    body.core_v1.back.attachment.attachment.front.left.attachment.front.attachment = (
-        BrickV1(0.0)
-    )
-
-    return body
-
-
-def babyb_v1() -> BodyV1:
-    """
-    Get the babyb modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.left.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.left.attachment.front = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment.front.attachment = BrickV1(0.0)
-    body.core_v1.left.attachment.front.attachment.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.left.attachment.front.attachment.front.attachment = BrickV1(0.0)
-
-    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.front = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.front.attachment = BrickV1(0.0)
-    body.core_v1.right.attachment.front.attachment.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment.front.attachment.front.attachment = BrickV1(0.0)
-
-    body.core_v1.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.front.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.front.attachment.front = ActiveHingeV1(0.0)
-    body.core_v1.front.attachment.front.attachment = BrickV1(0.0)
-    body.core_v1.front.attachment.front.attachment.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.front.attachment.front.attachment.front.attachment = BrickV1(0.0)
-
-    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
-
-    return body
-
-
-def garrix_v1() -> BodyV1:
-    """
-    Get the garrix modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.front = ActiveHingeV1(np.pi / 2.0)
-
-    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.left.attachment = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.left.attachment.attachment.attachment = BrickV1(0.0)
-    body.core_v1.left.attachment.attachment.attachment.front = BrickV1(0.0)
-    body.core_v1.left.attachment.attachment.attachment.left = ActiveHingeV1(0.0)
-
-    part2 = BrickV1(0.0)
-    part2.right = ActiveHingeV1(np.pi / 2.0)
-    part2.front = ActiveHingeV1(np.pi / 2.0)
-    part2.left = ActiveHingeV1(0.0)
-    part2.left.attachment = ActiveHingeV1(np.pi / 2.0)
-    part2.left.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
-    part2.left.attachment.attachment.attachment = BrickV1(0.0)
-
-    body.core_v1.left.attachment.attachment.attachment.left.attachment = part2
-
-    return body
-
-
-def insect_v1() -> BodyV1:
-    """
-    Get the insect modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.attachment = BrickV1(0.0)
-    body.core_v1.right.attachment.attachment.right = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.left.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.left.attachment.front = ActiveHingeV1(
-        np.pi / 2.0
-    )
-    body.core_v1.right.attachment.attachment.left.attachment.right = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.left.attachment.right.attachment = (
-        ActiveHingeV1(0.0)
-    )
-    body.core_v1.right.attachment.attachment.left.attachment.right.attachment.attachment = ActiveHingeV1(
-        np.pi / 2.0
-    )
-
-    return body
-
-
-def linkin_v1() -> BodyV1:
-    """
-    Get the linkin modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.back = ActiveHingeV1(0.0)
-
-    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.attachment.attachment = BrickV1(0.0)
-
-    part2 = body.core_v1.right.attachment.attachment.attachment.attachment
-    part2.front = BrickV1(0.0)
-
-    part2.left = ActiveHingeV1(0.0)
-    part2.left.attachment = ActiveHingeV1(0.0)
-
-    part2.right = ActiveHingeV1(np.pi / 2.0)
-    part2.right.attachment = ActiveHingeV1(-np.pi / 2.0)
-    part2.right.attachment.attachment = ActiveHingeV1(0.0)
-    part2.right.attachment.attachment.attachment = ActiveHingeV1(np.pi / 2.0)
-    part2.right.attachment.attachment.attachment.attachment = ActiveHingeV1(0.0)
-
-    return body
-
-
-def longleg_v1() -> BodyV1:
-    """
-    Get the longleg modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.left.attachment = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment.attachment = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.left.attachment.attachment.attachment.attachment = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment.attachment.attachment.attachment.attachment = BrickV1(
-        0.0
-    )
-
-    part2 = body.core_v1.left.attachment.attachment.attachment.attachment.attachment
-    part2.right = ActiveHingeV1(0.0)
-    part2.front = ActiveHingeV1(0.0)
-    part2.left = ActiveHingeV1(np.pi / 2.0)
-    part2.left.attachment = ActiveHingeV1(-np.pi / 2.0)
-    part2.left.attachment.attachment = BrickV1(0.0)
-    part2.left.attachment.attachment.right = ActiveHingeV1(np.pi / 2.0)
-    part2.left.attachment.attachment.left = ActiveHingeV1(np.pi / 2.0)
-    part2.left.attachment.attachment.left.attachment = ActiveHingeV1(0.0)
-
-    return body
-
-
-def penguin_v1() -> BodyV1:
-    """
-    Get the penguin modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.right = BrickV1(0.0)
-    body.core_v1.right.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.left.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.right.left.attachment.attachment = BrickV1(0.0)
-    body.core_v1.right.left.attachment.attachment.right = ActiveHingeV1(0.0)
-    body.core_v1.right.left.attachment.attachment.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.left.attachment.attachment.left.attachment = ActiveHingeV1(
-        -np.pi / 2.0
-    )
-    body.core_v1.right.left.attachment.attachment.left.attachment.attachment = (
-        ActiveHingeV1(np.pi / 2.0)
-    )
-    body.core_v1.right.left.attachment.attachment.left.attachment.attachment.attachment = BrickV1(
-        -np.pi / 2.0
-    )
-
-    part2 = (
-        body.core_v1.right.left.attachment.attachment.left.attachment.attachment.attachment
-    )
-
-    part2.front = ActiveHingeV1(np.pi / 2.0)
-    part2.front.attachment = BrickV1(-np.pi / 2.0)
-
-    part2.right = ActiveHingeV1(0.0)
-    part2.right.attachment = ActiveHingeV1(0.0)
-    part2.right.attachment.attachment = ActiveHingeV1(np.pi / 2.0)
-    part2.right.attachment.attachment.attachment = BrickV1(-np.pi / 2.0)
-
-    part2.right.attachment.attachment.attachment.left = ActiveHingeV1(np.pi / 2.0)
-
-    part2.right.attachment.attachment.attachment.right = BrickV1(0.0)
-    part2.right.attachment.attachment.attachment.right.front = ActiveHingeV1(
-        np.pi / 2.0
-    )
-
-    return body
-
-
-def pentapod_v1() -> BodyV1:
-    """
-    Get the pentapod modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.attachment.attachment = BrickV1(0.0)
-    part2 = body.core_v1.right.attachment.attachment.attachment.attachment
-
-    part2.left = ActiveHingeV1(0.0)
-    part2.front = ActiveHingeV1(np.pi / 2.0)
-    part2.front.attachment = BrickV1(-np.pi / 2.0)
-    part2.front.attachment.left = BrickV1(0.0)
-    part2.front.attachment.right = ActiveHingeV1(0.0)
-    part2.front.attachment.front = ActiveHingeV1(np.pi / 2.0)
-    part2.front.attachment.front.attachment = BrickV1(-np.pi / 2.0)
-    part2.front.attachment.front.attachment.left = ActiveHingeV1(0.0)
-    part2.front.attachment.front.attachment.right = ActiveHingeV1(0.0)
-
-    return body
-
-
-def queen_v1() -> BodyV1:
-    """
-    Get the queen modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.attachment = BrickV1(0.0)
-    part2 = body.core_v1.right.attachment.attachment.attachment
-
-    part2.left = ActiveHingeV1(0.0)
-    part2.right = BrickV1(0.0)
-    part2.right.front = BrickV1(0.0)
-    part2.right.front.left = ActiveHingeV1(0.0)
-    part2.right.front.right = ActiveHingeV1(0.0)
-
-    part2.right.right = BrickV1(0.0)
-    part2.right.right.front = ActiveHingeV1(np.pi / 2.0)
-    part2.right.right.front.attachment = ActiveHingeV1(0.0)
-
-    return body
-
-
-def squarish_v1() -> BodyV1:
-    """
-    Get the squarish modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.back = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment = BrickV1(0.0)
-    body.core_v1.back.attachment.front = ActiveHingeV1(0.0)
-    body.core_v1.back.attachment.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.back.attachment.left.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.back.attachment.left.attachment.left = BrickV1(0.0)
-    part2 = body.core_v1.back.attachment.left.attachment.left
-
-    part2.left = ActiveHingeV1(np.pi / 2.0)
-    part2.front = ActiveHingeV1(0.0)
-    part2.right = ActiveHingeV1(np.pi / 2.0)
-    part2.right.attachment = BrickV1(-np.pi / 2.0)
-    part2.right.attachment.left = BrickV1(0.0)
-    part2.right.attachment.left.left = BrickV1(0.0)
-
-    return body
-
-
-def snake_v1() -> BodyV1:
-    """
-    Get the snake modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.left = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment = BrickV1(0.0)
-    body.core_v1.left.attachment.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.left.attachment.front.attachment = BrickV1(-np.pi / 2.0)
-    body.core_v1.left.attachment.front.attachment.front = ActiveHingeV1(0.0)
-    body.core_v1.left.attachment.front.attachment.front.attachment = BrickV1(0.0)
-    body.core_v1.left.attachment.front.attachment.front.attachment.front = (
-        ActiveHingeV1(np.pi / 2.0)
-    )
-    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment = (
-        BrickV1(-np.pi / 2.0)
-    )
-    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV1(
-        0.0
-    )
-    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment = BrickV1(
-        0.0
-    )
-    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV1(
-        np.pi / 2.0
-    )
-    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment = BrickV1(
-        -np.pi / 2.0
-    )
-    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV1(
-        0.0
-    )
-    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment = BrickV1(
-        0.0
-    )
-    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV1(
-        np.pi / 2.0
-    )
-
-    return body
-
-
-def stingray_v1() -> BodyV1:
-    """
-    Get the stingray modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.attachment = BrickV1(0.0)
-    body.core_v1.right.attachment.attachment.right = BrickV1(0.0)
-    body.core_v1.right.attachment.attachment.left = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.front = BrickV1(0.0)
-    body.core_v1.right.attachment.attachment.front.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.front.front = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.front.left = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.front.left.attachment = BrickV1(0.0)
-    body.core_v1.right.attachment.attachment.front.left.attachment.right = (
-        ActiveHingeV1(np.pi / 2.0)
-    )
-    body.core_v1.right.attachment.attachment.front.left.attachment.front = (
-        ActiveHingeV1(0.0)
-    )
-    body.core_v1.right.attachment.attachment.front.left.attachment.front.attachment = (
-        BrickV1(0.0)
-    )
-
-    return body
-
-
-def tinlicker_v1() -> BodyV1:
-    """
-    Get the tinlicker modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.attachment.attachment = BrickV1(0.0)
-    part2 = body.core_v1.right.attachment.attachment.attachment.attachment
-
-    part2.left = BrickV1(0.0)
-    part2.left.front = ActiveHingeV1(np.pi / 2.0)
-    part2.left.right = BrickV1(0.0)
-    part2.left.right.left = BrickV1(0.0)
-    part2.left.right.front = ActiveHingeV1(0.0)
-    part2.left.right.front.attachment = BrickV1(0.0)
-    part2.left.right.front.attachment.front = ActiveHingeV1(np.pi / 2.0)
-    part2.left.right.front.attachment.right = BrickV1(0.0)
-    part2.left.right.front.attachment.right.right = ActiveHingeV1(np.pi / 2.0)
-
-    return body
-
-
-def turtle_v1() -> BodyV1:
-    """
-    Get the turtle modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.left = BrickV1(0.0)
-    body.core_v1.left.right = ActiveHingeV1(0.0)
-    body.core_v1.left.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.left.left.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.left.left.attachment.attachment = BrickV1(0.0)
-
-    body.core_v1.left.left.attachment.attachment.front = BrickV1(0.0)
-    body.core_v1.left.left.attachment.attachment.left = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.left.left.attachment.attachment.right = ActiveHingeV1(0.0)
-    body.core_v1.left.left.attachment.attachment.right.attachment = BrickV1(0.0)
-    part2 = body.core_v1.left.left.attachment.attachment.right.attachment
-
-    part2.left = ActiveHingeV1(np.pi / 2.0)
-    part2.left.attachment = ActiveHingeV1(-np.pi / 2.0)
-    part2.front = BrickV1(0.0)
-    part2.right = ActiveHingeV1(0.0)
-    part2.right.attachment = BrickV1(0.0)
-    part2.right.attachment.right = ActiveHingeV1(0.0)
-    part2.right.attachment.left = ActiveHingeV1(np.pi / 2.0)
-    part2.right.attachment.left.attachment = ActiveHingeV1(-np.pi / 2.0)
-    part2.right.attachment.left.attachment.attachment = ActiveHingeV1(0.0)
-    part2.right.attachment.left.attachment.attachment.attachment = ActiveHingeV1(0.0)
-
-    return body
-
-
-def ww_v1() -> BodyV1:
-    """
-    Get the ww modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.back = ActiveHingeV1(0.0)
-    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.attachment = BrickV1(0.0)
-    body.core_v1.right.attachment.attachment.attachment.left = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.attachment.left.attachment = BrickV1(0.0)
-    part2 = body.core_v1.right.attachment.attachment.attachment.left.attachment
-
-    part2.left = ActiveHingeV1(0.0)
-    part2.front = BrickV1(0.0)
-    part2.front.right = ActiveHingeV1(np.pi / 2.0)
-    part2.front.right.attachment = BrickV1(-np.pi / 2.0)
-    part2.front.right.attachment.left = ActiveHingeV1(np.pi / 2.0)
-    part2.front.right.attachment.left.attachment = ActiveHingeV1(0.0)
-    part2.front.right.attachment.left.attachment.attachment = ActiveHingeV1(
-        -np.pi / 2.0
-    )
-
-    return body
-
-
-def zappa_v1() -> BodyV1:
-    """
-    Get the zappa modular robot.
-
-    :returns: the robot.
-    """
-    body = BodyV1()
-
-    body.core_v1.back = ActiveHingeV1(0.0)
-    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
-    body.core_v1.right.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
-    body.core_v1.right.attachment.attachment.attachment.attachment = ActiveHingeV1(0.0)
-    body.core_v1.right.attachment.attachment.attachment.attachment.attachment = BrickV1(
-        0.0
-    )
-    part2 = body.core_v1.right.attachment.attachment.attachment.attachment.attachment
-
-    part2.front = ActiveHingeV1(0.0)
-    part2.front.attachment = ActiveHingeV1(0.0)
-    part2.left = ActiveHingeV1(np.pi / 2.0)
-    part2.left.attachment = BrickV1(-np.pi / 2.0)
-    part2.left.attachment.left = ActiveHingeV1(0.0)
-    part2.left.attachment.left.attachment = BrickV1(0.0)
-    part2.left.attachment.front = ActiveHingeV1(0.0)
-
-    return body
-
-
-def get(name: str) -> BodyV1:
-    """
-    Get a robot by name.
-
-    :param name: The name of the robot to get.
-    :returns: The robot with that name.
-    :raises ValueError: When a robot with that name does not exist.
-    """
-    match name:
-        case "gecko":
-            return gecko_v1()
-        case "spider":
-            return spider_v1()
-        case "babya":
-            return babya_v1()
-        case "ant":
-            return ant_v1()
-        case "salamander":
-            return salamander_v1()
-        case "blokky":
-            return blokky_v1()
-        case "park":
-            return park_v1()
-        case "babyb":
-            return babyb_v1()
-        case "garrix":
-            return garrix_v1()
-        case "insect":
-            return insect_v1()
-        case "linkin":
-            return linkin_v1()
-        case "longleg":
-            return longleg_v1()
-        case "penguin":
-            return penguin_v1()
-        case "pentapod":
-            return pentapod_v1()
-        case "queen":
-            return queen_v1()
-        case "squarish":
-            return squarish_v1()
-        case "snake":
-            return snake_v1()
-        case "stingray":
-            return stingray_v1()
-        case "tinlicker":
-            return tinlicker_v1()
-        case "turtle":
-            return turtle_v1()
-        case "ww":
-            return ww_v1()
-        case "zappa":
-            return zappa_v1()
-        case _:
-            raise ValueError(f"Robot does not exist: {name}")
+"""Standard modular robots."""
+
+import numpy as np
+
+from revolve2.modular_robot.body.v1 import ActiveHingeV1, BodyV1, BrickV1
+
+
+def all() -> list[BodyV1]:
+    """
+    Get a list of all standard module robots.
+
+    :returns: The list of robots.
+    """
+    return [
+        babya_v1(),
+        babyb_v1(),
+        blokky_v1(),
+        garrix_v1(),
+        gecko_v1(),
+        insect_v1(),
+        linkin_v1(),
+        longleg_v1(),
+        penguin_v1(),
+        pentapod_v1(),
+        queen_v1(),
+        salamander_v1(),
+        squarish_v1(),
+        snake_v1(),
+        spider_v1(),
+        stingray_v1(),
+        tinlicker_v1(),
+        turtle_v1(),
+        ww_v1(),
+        zappa_v1(),
+        ant_v1(),
+        park_v1(),
+    ]
+
+
+def spider_v1() -> BodyV1:
+    """
+    Get the spider modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.left.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.left.attachment.front = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment.front.attachment = BrickV1(0.0)
+
+    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.front = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.front.attachment = BrickV1(0.0)
+
+    body.core_v1.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.front.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.front.attachment.front = ActiveHingeV1(0.0)
+    body.core_v1.front.attachment.front.attachment = BrickV1(0.0)
+
+    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.front = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front.attachment = BrickV1(0.0)
+
+    return body
+
+
+def gecko_v1() -> BodyV1:
+    """
+    Get the gecko modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.left = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment = BrickV1(0.0)
+
+    body.core_v1.right = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment = BrickV1(0.0)
+
+    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment.front.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.front.attachment.left = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front.attachment.left.attachment = BrickV1(0.0)
+    body.core_v1.back.attachment.front.attachment.right = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front.attachment.right.attachment = BrickV1(0.0)
+
+    return body
+
+
+def babya_v1() -> BodyV1:
+    """
+    Get the babya modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.left = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment = BrickV1(0.0)
+
+    body.core_v1.right = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.front = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.front.attachment = BrickV1(0.0)
+
+    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment.front.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.front.attachment.left = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front.attachment.left.attachment = BrickV1(0.0)
+    body.core_v1.back.attachment.front.attachment.right = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front.attachment.right.attachment = BrickV1(0.0)
+
+    return body
+
+
+def ant_v1() -> BodyV1:
+    """
+    Get the ant modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.left = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment = BrickV1(0.0)
+
+    body.core_v1.right = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment = BrickV1(0.0)
+
+    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.left = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.left.attachment = BrickV1(0.0)
+    body.core_v1.back.attachment.right = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.right.attachment = BrickV1(0.0)
+
+    body.core_v1.back.attachment.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment.front.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.front.attachment.left = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front.attachment.left.attachment = BrickV1(0.0)
+    body.core_v1.back.attachment.front.attachment.right = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front.attachment.right.attachment = BrickV1(0.0)
+
+    return body
+
+
+def salamander_v1() -> BodyV1:
+    """
+    Get the salamander modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.left.attachment = ActiveHingeV1(-np.pi / 2.0)
+
+    body.core_v1.right = ActiveHingeV1(0.0)
+
+    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.left = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front = BrickV1(0.0)
+    body.core_v1.back.attachment.front.left = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment.front.front.attachment = BrickV1(-np.pi / 2.0)
+
+    body.core_v1.back.attachment.front.front.attachment.left = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front.front.attachment.left.attachment = BrickV1(0.0)
+    body.core_v1.back.attachment.front.front.attachment.left.attachment.left = BrickV1(
+        0.0
+    )
+    body.core_v1.back.attachment.front.front.attachment.left.attachment.front = (
+        ActiveHingeV1(np.pi / 2.0)
+    )
+    body.core_v1.back.attachment.front.front.attachment.left.attachment.front.attachment = ActiveHingeV1(
+        -np.pi / 2.0
+    )
+
+    body.core_v1.back.attachment.front.front.attachment.front = BrickV1(0.0)
+    body.core_v1.back.attachment.front.front.attachment.front.left = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.front.front.attachment.front.front = BrickV1(0.0)
+    body.core_v1.back.attachment.front.front.attachment.front.front.left = (
+        ActiveHingeV1(0.0)
+    )
+    body.core_v1.back.attachment.front.front.attachment.front.front.front = BrickV1(0.0)
+    body.core_v1.back.attachment.front.front.attachment.front.front.front.front = (
+        ActiveHingeV1(np.pi / 2.0)
+    )
+    body.core_v1.back.attachment.front.front.attachment.front.front.front.front.attachment = BrickV1(
+        -np.pi / 2.0
+    )
+    body.core_v1.back.attachment.front.front.attachment.front.front.front.front.attachment.left = BrickV1(
+        0.0
+    )
+    body.core_v1.back.attachment.front.front.attachment.front.front.front.front.attachment.front = ActiveHingeV1(
+        np.pi / 2.0
+    )
+
+    return body
+
+
+def blokky_v1() -> BodyV1:
+    """
+    Get the blokky modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back = BrickV1(0.0)
+    body.core_v1.back.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.front.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.back.front.attachment.attachment = BrickV1(0.0)
+    body.core_v1.back.front.attachment.attachment.front = BrickV1(0.0)
+    body.core_v1.back.front.attachment.attachment.front.right = BrickV1(0.0)
+    body.core_v1.back.front.attachment.attachment.front.right.left = BrickV1(0.0)
+    body.core_v1.back.front.attachment.attachment.front.right.front = BrickV1(0.0)
+    body.core_v1.back.front.attachment.attachment.right = BrickV1(0.0)
+    body.core_v1.back.front.attachment.attachment.right.front = BrickV1(0.0)
+    body.core_v1.back.front.attachment.attachment.right.front.right = BrickV1(0.0)
+    body.core_v1.back.front.attachment.attachment.right.front.front = ActiveHingeV1(0.0)
+
+    return body
+
+
+def park_v1() -> BodyV1:
+    """
+    Get the park modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.attachment = BrickV1(0.0)
+    body.core_v1.back.attachment.attachment.right = BrickV1(0.0)
+    body.core_v1.back.attachment.attachment.left = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.attachment.front = BrickV1(0.0)
+    body.core_v1.back.attachment.attachment.front.right = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.attachment.front.front = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.attachment.front.left = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.attachment.front.left.attachment = BrickV1(0.0)
+    body.core_v1.back.attachment.attachment.front.left.attachment.right = ActiveHingeV1(
+        -np.pi / 2.0
+    )
+    body.core_v1.back.attachment.attachment.front.left.attachment.left = BrickV1(0.0)
+    body.core_v1.back.attachment.attachment.front.left.attachment.front = ActiveHingeV1(
+        0.0
+    )
+    body.core_v1.back.attachment.attachment.front.left.attachment.front.attachment = (
+        BrickV1(0.0)
+    )
+
+    return body
+
+
+def babyb_v1() -> BodyV1:
+    """
+    Get the babyb modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.left.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.left.attachment.front = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment.front.attachment = BrickV1(0.0)
+    body.core_v1.left.attachment.front.attachment.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.left.attachment.front.attachment.front.attachment = BrickV1(0.0)
+
+    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.front = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.front.attachment = BrickV1(0.0)
+    body.core_v1.right.attachment.front.attachment.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment.front.attachment.front.attachment = BrickV1(0.0)
+
+    body.core_v1.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.front.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.front.attachment.front = ActiveHingeV1(0.0)
+    body.core_v1.front.attachment.front.attachment = BrickV1(0.0)
+    body.core_v1.front.attachment.front.attachment.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.front.attachment.front.attachment.front.attachment = BrickV1(0.0)
+
+    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment = BrickV1(-np.pi / 2.0)
+
+    return body
+
+
+def garrix_v1() -> BodyV1:
+    """
+    Get the garrix modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.front = ActiveHingeV1(np.pi / 2.0)
+
+    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.left.attachment = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.left.attachment.attachment.attachment = BrickV1(0.0)
+    body.core_v1.left.attachment.attachment.attachment.front = BrickV1(0.0)
+    body.core_v1.left.attachment.attachment.attachment.left = ActiveHingeV1(0.0)
+
+    part2 = BrickV1(0.0)
+    part2.right = ActiveHingeV1(np.pi / 2.0)
+    part2.front = ActiveHingeV1(np.pi / 2.0)
+    part2.left = ActiveHingeV1(0.0)
+    part2.left.attachment = ActiveHingeV1(np.pi / 2.0)
+    part2.left.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
+    part2.left.attachment.attachment.attachment = BrickV1(0.0)
+
+    body.core_v1.left.attachment.attachment.attachment.left.attachment = part2
+
+    return body
+
+
+def insect_v1() -> BodyV1:
+    """
+    Get the insect modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.attachment = BrickV1(0.0)
+    body.core_v1.right.attachment.attachment.right = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.left.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.left.attachment.front = ActiveHingeV1(
+        np.pi / 2.0
+    )
+    body.core_v1.right.attachment.attachment.left.attachment.right = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.left.attachment.right.attachment = (
+        ActiveHingeV1(0.0)
+    )
+    body.core_v1.right.attachment.attachment.left.attachment.right.attachment.attachment = ActiveHingeV1(
+        np.pi / 2.0
+    )
+
+    return body
+
+
+def linkin_v1() -> BodyV1:
+    """
+    Get the linkin modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.back = ActiveHingeV1(0.0)
+
+    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.attachment.attachment = BrickV1(0.0)
+
+    part2 = body.core_v1.right.attachment.attachment.attachment.attachment
+    part2.front = BrickV1(0.0)
+
+    part2.left = ActiveHingeV1(0.0)
+    part2.left.attachment = ActiveHingeV1(0.0)
+
+    part2.right = ActiveHingeV1(np.pi / 2.0)
+    part2.right.attachment = ActiveHingeV1(-np.pi / 2.0)
+    part2.right.attachment.attachment = ActiveHingeV1(0.0)
+    part2.right.attachment.attachment.attachment = ActiveHingeV1(np.pi / 2.0)
+    part2.right.attachment.attachment.attachment.attachment = ActiveHingeV1(0.0)
+
+    return body
+
+
+def longleg_v1() -> BodyV1:
+    """
+    Get the longleg modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.left.attachment = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment.attachment = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.left.attachment.attachment.attachment.attachment = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment.attachment.attachment.attachment.attachment = BrickV1(
+        0.0
+    )
+
+    part2 = body.core_v1.left.attachment.attachment.attachment.attachment.attachment
+    part2.right = ActiveHingeV1(0.0)
+    part2.front = ActiveHingeV1(0.0)
+    part2.left = ActiveHingeV1(np.pi / 2.0)
+    part2.left.attachment = ActiveHingeV1(-np.pi / 2.0)
+    part2.left.attachment.attachment = BrickV1(0.0)
+    part2.left.attachment.attachment.right = ActiveHingeV1(np.pi / 2.0)
+    part2.left.attachment.attachment.left = ActiveHingeV1(np.pi / 2.0)
+    part2.left.attachment.attachment.left.attachment = ActiveHingeV1(0.0)
+
+    return body
+
+
+def penguin_v1() -> BodyV1:
+    """
+    Get the penguin modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.right = BrickV1(0.0)
+    body.core_v1.right.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.left.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.right.left.attachment.attachment = BrickV1(0.0)
+    body.core_v1.right.left.attachment.attachment.right = ActiveHingeV1(0.0)
+    body.core_v1.right.left.attachment.attachment.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.left.attachment.attachment.left.attachment = ActiveHingeV1(
+        -np.pi / 2.0
+    )
+    body.core_v1.right.left.attachment.attachment.left.attachment.attachment = (
+        ActiveHingeV1(np.pi / 2.0)
+    )
+    body.core_v1.right.left.attachment.attachment.left.attachment.attachment.attachment = BrickV1(
+        -np.pi / 2.0
+    )
+
+    part2 = (
+        body.core_v1.right.left.attachment.attachment.left.attachment.attachment.attachment
+    )
+
+    part2.front = ActiveHingeV1(np.pi / 2.0)
+    part2.front.attachment = BrickV1(-np.pi / 2.0)
+
+    part2.right = ActiveHingeV1(0.0)
+    part2.right.attachment = ActiveHingeV1(0.0)
+    part2.right.attachment.attachment = ActiveHingeV1(np.pi / 2.0)
+    part2.right.attachment.attachment.attachment = BrickV1(-np.pi / 2.0)
+
+    part2.right.attachment.attachment.attachment.left = ActiveHingeV1(np.pi / 2.0)
+
+    part2.right.attachment.attachment.attachment.right = BrickV1(0.0)
+    part2.right.attachment.attachment.attachment.right.front = ActiveHingeV1(
+        np.pi / 2.0
+    )
+
+    return body
+
+
+def pentapod_v1() -> BodyV1:
+    """
+    Get the pentapod modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.attachment.attachment = BrickV1(0.0)
+    part2 = body.core_v1.right.attachment.attachment.attachment.attachment
+
+    part2.left = ActiveHingeV1(0.0)
+    part2.front = ActiveHingeV1(np.pi / 2.0)
+    part2.front.attachment = BrickV1(-np.pi / 2.0)
+    part2.front.attachment.left = BrickV1(0.0)
+    part2.front.attachment.right = ActiveHingeV1(0.0)
+    part2.front.attachment.front = ActiveHingeV1(np.pi / 2.0)
+    part2.front.attachment.front.attachment = BrickV1(-np.pi / 2.0)
+    part2.front.attachment.front.attachment.left = ActiveHingeV1(0.0)
+    part2.front.attachment.front.attachment.right = ActiveHingeV1(0.0)
+
+    return body
+
+
+def queen_v1() -> BodyV1:
+    """
+    Get the queen modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.attachment = BrickV1(0.0)
+    part2 = body.core_v1.right.attachment.attachment.attachment
+
+    part2.left = ActiveHingeV1(0.0)
+    part2.right = BrickV1(0.0)
+    part2.right.front = BrickV1(0.0)
+    part2.right.front.left = ActiveHingeV1(0.0)
+    part2.right.front.right = ActiveHingeV1(0.0)
+
+    part2.right.right = BrickV1(0.0)
+    part2.right.right.front = ActiveHingeV1(np.pi / 2.0)
+    part2.right.right.front.attachment = ActiveHingeV1(0.0)
+
+    return body
+
+
+def squarish_v1() -> BodyV1:
+    """
+    Get the squarish modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.back = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment = BrickV1(0.0)
+    body.core_v1.back.attachment.front = ActiveHingeV1(0.0)
+    body.core_v1.back.attachment.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.back.attachment.left.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.back.attachment.left.attachment.left = BrickV1(0.0)
+    part2 = body.core_v1.back.attachment.left.attachment.left
+
+    part2.left = ActiveHingeV1(np.pi / 2.0)
+    part2.front = ActiveHingeV1(0.0)
+    part2.right = ActiveHingeV1(np.pi / 2.0)
+    part2.right.attachment = BrickV1(-np.pi / 2.0)
+    part2.right.attachment.left = BrickV1(0.0)
+    part2.right.attachment.left.left = BrickV1(0.0)
+
+    return body
+
+
+def snake_v1() -> BodyV1:
+    """
+    Get the snake modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.left = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment = BrickV1(0.0)
+    body.core_v1.left.attachment.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.left.attachment.front.attachment = BrickV1(-np.pi / 2.0)
+    body.core_v1.left.attachment.front.attachment.front = ActiveHingeV1(0.0)
+    body.core_v1.left.attachment.front.attachment.front.attachment = BrickV1(0.0)
+    body.core_v1.left.attachment.front.attachment.front.attachment.front = (
+        ActiveHingeV1(np.pi / 2.0)
+    )
+    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment = (
+        BrickV1(-np.pi / 2.0)
+    )
+    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV1(
+        0.0
+    )
+    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment = BrickV1(
+        0.0
+    )
+    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV1(
+        np.pi / 2.0
+    )
+    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment = BrickV1(
+        -np.pi / 2.0
+    )
+    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV1(
+        0.0
+    )
+    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment = BrickV1(
+        0.0
+    )
+    body.core_v1.left.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV1(
+        np.pi / 2.0
+    )
+
+    return body
+
+
+def stingray_v1() -> BodyV1:
+    """
+    Get the stingray modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.back = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.attachment = BrickV1(0.0)
+    body.core_v1.right.attachment.attachment.right = BrickV1(0.0)
+    body.core_v1.right.attachment.attachment.left = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.front = BrickV1(0.0)
+    body.core_v1.right.attachment.attachment.front.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.front.front = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.front.left = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.front.left.attachment = BrickV1(0.0)
+    body.core_v1.right.attachment.attachment.front.left.attachment.right = (
+        ActiveHingeV1(np.pi / 2.0)
+    )
+    body.core_v1.right.attachment.attachment.front.left.attachment.front = (
+        ActiveHingeV1(0.0)
+    )
+    body.core_v1.right.attachment.attachment.front.left.attachment.front.attachment = (
+        BrickV1(0.0)
+    )
+
+    return body
+
+
+def tinlicker_v1() -> BodyV1:
+    """
+    Get the tinlicker modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.attachment.attachment = BrickV1(0.0)
+    part2 = body.core_v1.right.attachment.attachment.attachment.attachment
+
+    part2.left = BrickV1(0.0)
+    part2.left.front = ActiveHingeV1(np.pi / 2.0)
+    part2.left.right = BrickV1(0.0)
+    part2.left.right.left = BrickV1(0.0)
+    part2.left.right.front = ActiveHingeV1(0.0)
+    part2.left.right.front.attachment = BrickV1(0.0)
+    part2.left.right.front.attachment.front = ActiveHingeV1(np.pi / 2.0)
+    part2.left.right.front.attachment.right = BrickV1(0.0)
+    part2.left.right.front.attachment.right.right = ActiveHingeV1(np.pi / 2.0)
+
+    return body
+
+
+def turtle_v1() -> BodyV1:
+    """
+    Get the turtle modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.left = BrickV1(0.0)
+    body.core_v1.left.right = ActiveHingeV1(0.0)
+    body.core_v1.left.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.left.left.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.left.left.attachment.attachment = BrickV1(0.0)
+
+    body.core_v1.left.left.attachment.attachment.front = BrickV1(0.0)
+    body.core_v1.left.left.attachment.attachment.left = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.left.left.attachment.attachment.right = ActiveHingeV1(0.0)
+    body.core_v1.left.left.attachment.attachment.right.attachment = BrickV1(0.0)
+    part2 = body.core_v1.left.left.attachment.attachment.right.attachment
+
+    part2.left = ActiveHingeV1(np.pi / 2.0)
+    part2.left.attachment = ActiveHingeV1(-np.pi / 2.0)
+    part2.front = BrickV1(0.0)
+    part2.right = ActiveHingeV1(0.0)
+    part2.right.attachment = BrickV1(0.0)
+    part2.right.attachment.right = ActiveHingeV1(0.0)
+    part2.right.attachment.left = ActiveHingeV1(np.pi / 2.0)
+    part2.right.attachment.left.attachment = ActiveHingeV1(-np.pi / 2.0)
+    part2.right.attachment.left.attachment.attachment = ActiveHingeV1(0.0)
+    part2.right.attachment.left.attachment.attachment.attachment = ActiveHingeV1(0.0)
+
+    return body
+
+
+def ww_v1() -> BodyV1:
+    """
+    Get the ww modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.back = ActiveHingeV1(0.0)
+    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.attachment = BrickV1(0.0)
+    body.core_v1.right.attachment.attachment.attachment.left = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.attachment.left.attachment = BrickV1(0.0)
+    part2 = body.core_v1.right.attachment.attachment.attachment.left.attachment
+
+    part2.left = ActiveHingeV1(0.0)
+    part2.front = BrickV1(0.0)
+    part2.front.right = ActiveHingeV1(np.pi / 2.0)
+    part2.front.right.attachment = BrickV1(-np.pi / 2.0)
+    part2.front.right.attachment.left = ActiveHingeV1(np.pi / 2.0)
+    part2.front.right.attachment.left.attachment = ActiveHingeV1(0.0)
+    part2.front.right.attachment.left.attachment.attachment = ActiveHingeV1(
+        -np.pi / 2.0
+    )
+
+    return body
+
+
+def zappa_v1() -> BodyV1:
+    """
+    Get the zappa modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV1()
+
+    body.core_v1.back = ActiveHingeV1(0.0)
+    body.core_v1.right = ActiveHingeV1(np.pi / 2.0)
+    body.core_v1.right.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.attachment = ActiveHingeV1(-np.pi / 2.0)
+    body.core_v1.right.attachment.attachment.attachment.attachment = ActiveHingeV1(0.0)
+    body.core_v1.right.attachment.attachment.attachment.attachment.attachment = BrickV1(
+        0.0
+    )
+    part2 = body.core_v1.right.attachment.attachment.attachment.attachment.attachment
+
+    part2.front = ActiveHingeV1(0.0)
+    part2.front.attachment = ActiveHingeV1(0.0)
+    part2.left = ActiveHingeV1(np.pi / 2.0)
+    part2.left.attachment = BrickV1(-np.pi / 2.0)
+    part2.left.attachment.left = ActiveHingeV1(0.0)
+    part2.left.attachment.left.attachment = BrickV1(0.0)
+    part2.left.attachment.front = ActiveHingeV1(0.0)
+
+    return body
+
+
+def get(name: str) -> BodyV1:
+    """
+    Get a robot by name.
+
+    :param name: The name of the robot to get.
+    :returns: The robot with that name.
+    :raises ValueError: When a robot with that name does not exist.
+    """
+    match name:
+        case "gecko":
+            return gecko_v1()
+        case "spider":
+            return spider_v1()
+        case "babya":
+            return babya_v1()
+        case "ant":
+            return ant_v1()
+        case "salamander":
+            return salamander_v1()
+        case "blokky":
+            return blokky_v1()
+        case "park":
+            return park_v1()
+        case "babyb":
+            return babyb_v1()
+        case "garrix":
+            return garrix_v1()
+        case "insect":
+            return insect_v1()
+        case "linkin":
+            return linkin_v1()
+        case "longleg":
+            return longleg_v1()
+        case "penguin":
+            return penguin_v1()
+        case "pentapod":
+            return pentapod_v1()
+        case "queen":
+            return queen_v1()
+        case "squarish":
+            return squarish_v1()
+        case "snake":
+            return snake_v1()
+        case "stingray":
+            return stingray_v1()
+        case "tinlicker":
+            return tinlicker_v1()
+        case "turtle":
+            return turtle_v1()
+        case "ww":
+            return ww_v1()
+        case "zappa":
+            return zappa_v1()
+        case _:
+            raise ValueError(f"Robot does not exist: {name}")
```

## revolve2/ci_group/modular_robots_v2.py

```diff
@@ -1,60 +1,178 @@
-"""Standard modular robots."""
-import numpy as np
-
-from revolve2.modular_robot.body.v2 import ActiveHingeV2, BodyV2, BrickV2
-
-
-def all() -> list[BodyV2]:
-    """
-    Get a list of all standard module robots.
-
-    :returns: The list of robots.
-    """
-    return [
-        gecko_v2(),
-    ]
-
-
-def get(name: str) -> BodyV2:
-    """
-    Get a robot by name.
-
-    :param name: The name of the robot to get.
-    :returns: The robot with that name.
-    :raises ValueError: When a robot with that name does not exist.
-    """
-    match name:
-        case "gecko":
-            return gecko_v2()
-        case _:
-            raise ValueError(f"Robot does not exist: {name}")
-
-
-def gecko_v2() -> BodyV2:
-    """
-    Sample robot with new HW config.
-
-    :returns: the robot
-    """
-    body = BodyV2()
-
-    body.core_v2.right_face.bottom = ActiveHingeV2(0.0)
-    body.core_v2.right_face.bottom.attachment = BrickV2(0.0)
-
-    body.core_v2.left_face.bottom = ActiveHingeV2(0.0)
-    body.core_v2.left_face.bottom.attachment = BrickV2(0.0)
-
-    body.core_v2.back_face.bottom = ActiveHingeV2(np.pi / 2.0)
-    body.core_v2.back_face.bottom.attachment = BrickV2(-np.pi / 2.0)
-    body.core_v2.back_face.bottom.attachment.front = ActiveHingeV2(np.pi / 2.0)
-    body.core_v2.back_face.bottom.attachment.front.attachment = BrickV2(-np.pi / 2.0)
-    body.core_v2.back_face.bottom.attachment.front.attachment.left = ActiveHingeV2(0.0)
-    body.core_v2.back_face.bottom.attachment.front.attachment.right = ActiveHingeV2(0.0)
-    body.core_v2.back_face.bottom.attachment.front.attachment.left.attachment = BrickV2(
-        0.0
-    )
-    body.core_v2.back_face.bottom.attachment.front.attachment.right.attachment = (
-        BrickV2(0.0)
-    )
-
-    return body
+"""Standard modular robots."""
+
+import numpy as np
+
+from revolve2.modular_robot.body.v2 import ActiveHingeV2, BodyV2, BrickV2
+
+
+def all() -> list[BodyV2]:
+    """
+    Get a list of all standard module robots.
+
+    :returns: The list of robots.
+    """
+    return [gecko_v2(), ant_v2(), spider_v2(), snake_v2()]
+
+
+def get(name: str) -> BodyV2:
+    """
+    Get a robot by name.
+
+    :param name: The name of the robot to get.
+    :returns: The robot with that name.
+    :raises ValueError: When a robot with that name does not exist.
+    """
+    match name:
+        case "gecko":
+            return gecko_v2()
+        case "spider":
+            return spider_v2()
+        case "snake":
+            return snake_v2()
+        case "ant":
+            return ant_v2()
+        case _:
+            raise ValueError(f"Robot does not exist: {name}")
+
+
+def gecko_v2() -> BodyV2:
+    """
+    Sample robot with new HW config.
+
+    :returns: the robot
+    """
+    body = BodyV2()
+
+    body.core_v2.right_face.bottom = ActiveHingeV2(0.0)
+    body.core_v2.right_face.bottom.attachment = BrickV2(0.0)
+
+    body.core_v2.left_face.bottom = ActiveHingeV2(0.0)
+    body.core_v2.left_face.bottom.attachment = BrickV2(0.0)
+
+    body.core_v2.back_face.bottom = ActiveHingeV2(np.pi / 2.0)
+    body.core_v2.back_face.bottom.attachment = BrickV2(-np.pi / 2.0)
+    body.core_v2.back_face.bottom.attachment.front = ActiveHingeV2(np.pi / 2.0)
+    body.core_v2.back_face.bottom.attachment.front.attachment = BrickV2(-np.pi / 2.0)
+    body.core_v2.back_face.bottom.attachment.front.attachment.left = ActiveHingeV2(0.0)
+    body.core_v2.back_face.bottom.attachment.front.attachment.right = ActiveHingeV2(0.0)
+    body.core_v2.back_face.bottom.attachment.front.attachment.left.attachment = BrickV2(
+        0.0
+    )
+    body.core_v2.back_face.bottom.attachment.front.attachment.right.attachment = (
+        BrickV2(0.0)
+    )
+
+    return body
+
+
+def spider_v2() -> BodyV2:
+    """
+    Get the spider modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV2()
+
+    body.core_v2.left_face.bottom = ActiveHingeV2(np.pi / 2.0)
+    body.core_v2.left_face.bottom.attachment = BrickV2(-np.pi / 2.0)
+    body.core_v2.left_face.bottom.attachment.front = ActiveHingeV2(0.0)
+    body.core_v2.left_face.bottom.attachment.front.attachment = BrickV2(0.0)
+
+    body.core_v2.right_face.bottom = ActiveHingeV2(np.pi / 2.0)
+    body.core_v2.right_face.bottom.attachment = BrickV2(-np.pi / 2.0)
+    body.core_v2.right_face.bottom.attachment.front = ActiveHingeV2(0.0)
+    body.core_v2.right_face.bottom.attachment.front.attachment = BrickV2(0.0)
+
+    body.core_v2.front_face.bottom = ActiveHingeV2(np.pi / 2.0)
+    body.core_v2.front_face.bottom.attachment = BrickV2(-np.pi / 2.0)
+    body.core_v2.front_face.bottom.attachment.front = ActiveHingeV2(0.0)
+    body.core_v2.front_face.bottom.attachment.front.attachment = BrickV2(0.0)
+
+    body.core_v2.back_face.bottom = ActiveHingeV2(np.pi / 2.0)
+    body.core_v2.back_face.bottom.attachment = BrickV2(-np.pi / 2.0)
+    body.core_v2.back_face.bottom.attachment.front = ActiveHingeV2(0.0)
+    body.core_v2.back_face.bottom.attachment.front.attachment = BrickV2(0.0)
+
+    return body
+
+
+def ant_v2() -> BodyV2:
+    """
+    Get the ant modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV2()
+
+    body.core_v2.left_face.bottom = ActiveHingeV2(0.0)
+    body.core_v2.left_face.bottom.attachment = BrickV2(0.0)
+
+    body.core_v2.right_face.bottom = ActiveHingeV2(0.0)
+    body.core_v2.right_face.bottom.attachment = BrickV2(0.0)
+
+    body.core_v2.back_face.bottom = ActiveHingeV2(np.pi / 2.0)
+    body.core_v2.back_face.bottom.attachment = BrickV2(-np.pi / 2.0)
+    body.core_v2.back_face.bottom.attachment.left = ActiveHingeV2(0.0)
+    body.core_v2.back_face.bottom.attachment.left.attachment = BrickV2(0.0)
+    body.core_v2.back_face.bottom.attachment.right = ActiveHingeV2(0.0)
+    body.core_v2.back_face.bottom.attachment.right.attachment = BrickV2(0.0)
+
+    body.core_v2.back_face.bottom.attachment.front = ActiveHingeV2(np.pi / 2.0)
+    body.core_v2.back_face.bottom.attachment.front.attachment = BrickV2(-np.pi / 2.0)
+    body.core_v2.back_face.bottom.attachment.front.attachment.left = ActiveHingeV2(0.0)
+    body.core_v2.back_face.bottom.attachment.front.attachment.left.attachment = BrickV2(
+        0.0
+    )
+    body.core_v2.back_face.bottom.attachment.front.attachment.right = ActiveHingeV2(0.0)
+    body.core_v2.back_face.bottom.attachment.front.attachment.right.attachment = (
+        BrickV2(0.0)
+    )
+
+    return body
+
+
+def snake_v2() -> BodyV2:
+    """
+    Get the snake modular robot.
+
+    :returns: the robot.
+    """
+    body = BodyV2()
+
+    body.core_v2.left_face.bottom = ActiveHingeV2(0.0)
+    body.core_v2.left_face.bottom.attachment = BrickV2(0.0)
+    body.core_v2.left_face.bottom.attachment.front = ActiveHingeV2(np.pi / 2.0)
+    body.core_v2.left_face.bottom.attachment.front.attachment = BrickV2(-np.pi / 2.0)
+    body.core_v2.left_face.bottom.attachment.front.attachment.front = ActiveHingeV2(0.0)
+    body.core_v2.left_face.bottom.attachment.front.attachment.front.attachment = (
+        BrickV2(0.0)
+    )
+    body.core_v2.left_face.bottom.attachment.front.attachment.front.attachment.front = (
+        ActiveHingeV2(np.pi / 2.0)
+    )
+    body.core_v2.left_face.bottom.attachment.front.attachment.front.attachment.front.attachment = BrickV2(
+        -np.pi / 2.0
+    )
+    body.core_v2.left_face.bottom.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV2(
+        0.0
+    )
+    body.core_v2.left_face.bottom.attachment.front.attachment.front.attachment.front.attachment.front.attachment = BrickV2(
+        0.0
+    )
+    body.core_v2.left_face.bottom.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV2(
+        np.pi / 2.0
+    )
+    body.core_v2.left_face.bottom.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment = BrickV2(
+        -np.pi / 2.0
+    )
+    body.core_v2.left_face.bottom.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV2(
+        0.0
+    )
+    body.core_v2.left_face.bottom.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment = BrickV2(
+        0.0
+    )
+    body.core_v2.left_face.bottom.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front.attachment.front = ActiveHingeV2(
+        np.pi / 2.0
+    )
+
+    return body
```

## revolve2/ci_group/morphological_measures.py

```diff
@@ -1,611 +1,612 @@
-"""MorphologicalMeasures class."""
-from itertools import product
-from typing import Generic, TypeVar
-
-import numpy as np
-from numpy.typing import NDArray
-from pyrr import Vector3
-
-from revolve2.modular_robot.body import Module
-from revolve2.modular_robot.body.base import ActiveHinge, Body, Brick, Core
-
-TModule = TypeVar("TModule", bound=np.generic)
-
-
-class MorphologicalMeasures(Generic[TModule]):
-    """
-    Modular robot morphological measures.
-
-    Only works for robot with only right angle module rotations (90 degrees).
-    Some measures only work for 2d robots, which is noted in their docstring.
-
-    The measures are based on the following paper:
-    Miras, K., Haasdijk, E., Glette, K., Eiben, A.E. (2018).
-    Search Space Analysis of Evolvable Robot Morphologies.
-    In: Sim, K., Kaufmann, P. (eds) Applications of Evolutionary Computation.
-    EvoApplications 2018. Lecture Notes in Computer Science(), vol 10784. Springer, Cham.
-    https://doi.org/10.1007/978-3-319-77538-8_47
-    """
-
-    """Represents the modules of a body in a 3D tensor."""
-    grid: NDArray[TModule]
-    symmetry_grid: NDArray[TModule]
-    """Position of the core in 'body_as_grid'."""
-    core_grid_position: Vector3[np.int_]
-
-    """If the robot is two dimensional, i.e. all module rotations are 0 degrees."""
-    is_2d: bool
-
-    core: Core
-    bricks: list[Brick]
-    active_hinges: list[ActiveHinge]
-
-    """If all slots of the core are filled with other modules."""
-    core_is_filled: bool
-
-    """Bricks which have all slots filled with other modules."""
-    filled_bricks: list[Brick]
-
-    """Active hinges which have all slots filled with other modules."""
-    filled_active_hinges: list[ActiveHinge]
-
-    """
-    Bricks that are only connected to one other module.
-
-    Both children and parent are counted.
-    """
-    single_neighbour_bricks: list[Brick]
-
-    """
-    Bricks that are connected to exactly two other modules.
-
-    Both children and parent are counted.
-    """
-    double_neighbour_bricks: list[Brick]
-
-    """
-    Active hinges that are connected to exactly two other modules.
-
-    Both children and parent are counted.
-    """
-    double_neighbour_active_hinges: list[ActiveHinge]
-
-    """
-    X/Y-plane symmetry according to the paper but in 3D.
-
-    X-axis is defined as forward/backward for the core module
-    Y-axis is defined as left/right for the core module.
-    """
-    xy_symmetry: float
-
-    """
-    X/Z-plane symmetry according to the paper but in 3D.
-
-    X-axis is defined as forward/backward for the core module
-    Z-axis is defined as up/down for the core module.
-    """
-    xz_symmetry: float
-
-    """
-    Y/Z-plane symmetry according to the paper but in 3D.
-
-    Y-axis is defined as left/right for the core module.
-    Z-axis is defined as up/down for the core module.
-    """
-    yz_symmetry: float
-
-    def __init__(self, body: Body) -> None:
-        """
-        Initialize this object.
-
-        :param body: The body to measure.
-        """
-        self.grid, self.core_grid_position = body.to_grid()
-        self.core = body.core
-        self.is_2d = self.__calculate_is_2d_recur(self.core)
-        self.bricks = body.find_modules_of_type(Brick)
-        self.active_hinges = body.find_modules_of_type(ActiveHinge)
-        self.core_is_filled = self.__calculate_core_is_filled()
-        self.filled_bricks = self.__calculate_filled_bricks()
-        self.filled_active_hinges = self.__calculate_filled_active_hinges()
-        self.single_neighbour_bricks = self.__calculate_single_neighbour_bricks()
-        self.double_neighbour_bricks = self.__calculate_double_neighbour_bricks()
-        self.double_neighbour_active_hinges = (
-            self.__calculate_double_neighbour_active_hinges()
-        )
-
-        self.__pad_grid()
-        self.xy_symmetry = self.__calculate_xy_symmetry()
-        self.xz_symmetry = self.__calculate_xz_symmetry()
-        self.yz_symmetry = self.__calculate_yz_symmetry()
-
-    @classmethod
-    def __calculate_is_2d_recur(cls, module: Module) -> bool:
-        return all(
-            [np.isclose(module.rotation, 0.0)]
-            + [cls.__calculate_is_2d_recur(child) for child in module.children.values()]
-        )
-
-    def __calculate_core_is_filled(self) -> bool:
-        return all(
-            [
-                self.core.children.get(child_index) is not None
-                for child_index in self.core.attachment_points.keys()
-            ]
-        )
-
-    def __calculate_filled_bricks(self) -> list[Brick]:
-        return [
-            brick
-            for brick in self.bricks
-            if all(
-                [
-                    brick.children.get(child_index) is not None
-                    for child_index in brick.attachment_points.keys()
-                ]
-            )
-        ]
-
-    def __calculate_filled_active_hinges(self) -> list[ActiveHinge]:
-        return [
-            active_hinge
-            for active_hinge in self.active_hinges
-            if all(
-                [
-                    active_hinge.children.get(child_index) is not None
-                    for child_index in active_hinge.attachment_points.keys()
-                ]
-            )
-        ]
-
-    def __calculate_single_neighbour_bricks(self) -> list[Brick]:
-        return [
-            brick
-            for brick in self.bricks
-            if all(
-                [
-                    brick.children.get(child_index) is None
-                    for child_index in brick.attachment_points.keys()
-                ]
-            )
-        ]
-
-    def __calculate_double_neighbour_bricks(self) -> list[Brick]:
-        return [
-            brick
-            for brick in self.bricks
-            if sum(
-                [
-                    0 if brick.children.get(child_index) is None else 1
-                    for child_index in brick.attachment_points.keys()
-                ]
-            )
-            == 1
-        ]
-
-    def __calculate_double_neighbour_active_hinges(self) -> list[ActiveHinge]:
-        return [
-            active_hinge
-            for active_hinge in self.active_hinges
-            if sum(
-                [
-                    0 if active_hinge.children.get(child_index) is None else 1
-                    for child_index in active_hinge.attachment_points.keys()
-                ]
-            )
-            == 1
-        ]
-
-    def __pad_grid(self) -> None:
-        x, y, z = self.grid.shape
-        xoffs, yoffs, zoffs = self.core_grid_position
-        self.symmetry_grid = np.empty(
-            shape=(x + xoffs, y + yoffs, z + zoffs), dtype=Module
-        )
-        self.symmetry_grid.fill(None)
-        self.symmetry_grid[:x, :y, :z] = self.grid
-
-    def __calculate_xy_symmetry(self) -> float:
-        num_along_plane = 0
-        num_symmetrical = 0
-        for x, y, z in product(
-            range(self.bounding_box_depth),
-            range(self.bounding_box_width),
-            range(1, (self.bounding_box_height - 1) // 2),
-        ):
-            if self.symmetry_grid[x, y, self.core_grid_position[2]] is not None:
-                num_along_plane += 1
-            if self.symmetry_grid[
-                x, y, self.core_grid_position[2] + z
-            ] is not None and type(
-                self.symmetry_grid[x, y, self.core_grid_position[2] + z]
-            ) is type(
-                self.symmetry_grid[x, y, self.core_grid_position[2] - z]
-            ):
-                num_symmetrical += 2
-
-        difference = self.num_modules - num_along_plane
-        return num_symmetrical / difference if difference > 0.0 else difference
-
-    def __calculate_xz_symmetry(self) -> float:
-        num_along_plane = 0
-        num_symmetrical = 0
-        for x, y, z in product(
-            range(self.bounding_box_depth),
-            range(1, (self.bounding_box_width - 1) // 2),
-            range(self.bounding_box_height),
-        ):
-            if self.symmetry_grid[x, self.core_grid_position[1], z] is not None:
-                num_along_plane += 1
-            if self.symmetry_grid[
-                x, self.core_grid_position[1] + y, z
-            ] is not None and type(
-                self.symmetry_grid[x, self.core_grid_position[1] + y, z]
-            ) is type(
-                self.symmetry_grid[x, self.core_grid_position[1] - y, z]
-            ):
-                num_symmetrical += 2
-        difference = self.num_modules - num_along_plane
-        return num_symmetrical / difference if difference > 0.0 else difference
-
-    def __calculate_yz_symmetry(self) -> float:
-        num_along_plane = 0
-        num_symmetrical = 0
-        for x, y, z in product(
-            range(1, (self.bounding_box_depth - 1) // 2),
-            range(self.bounding_box_width),
-            range(self.bounding_box_height),
-        ):
-            if self.symmetry_grid[self.core_grid_position[0], y, z] is not None:
-                num_along_plane += 1
-            if self.symmetry_grid[
-                self.core_grid_position[0] + x, y, z
-            ] is not None and type(
-                self.symmetry_grid[self.core_grid_position[0] + x, y, z]
-            ) is type(
-                self.symmetry_grid[self.core_grid_position[0] - x, y, z]
-            ):
-                num_symmetrical += 2
-        difference = self.num_modules - num_along_plane
-        return num_symmetrical / difference if difference > 0.0 else difference
-
-    @property
-    def bounding_box_depth(self) -> int:
-        """
-        Get the depth of the bounding box around the body.
-
-        Forward/backward axis for the core module.
-
-        :returns: The depth.
-        """
-        return self.grid.shape[0]
-
-    @property
-    def bounding_box_width(self) -> int:
-        """
-        Get the width of the bounding box around the body.
-
-        Right/left axis for the core module.
-
-        :returns: The width.
-        """
-        return self.grid.shape[1]
-
-    @property
-    def bounding_box_height(self) -> int:
-        """
-        Get the height of the bounding box around the body.
-
-        Up/down axis for the core module.
-
-        :returns: The height.
-        """
-        return self.grid.shape[2]
-
-    @property
-    def num_modules(self) -> int:
-        """
-        Get the number of modules.
-
-        :returns: The number of modules.
-        """
-        return 1 + self.num_bricks + self.num_active_hinges
-
-    @property
-    def num_bricks(self) -> int:
-        """
-        Get the number of bricks.
-
-        :returns: The number of bricks.
-        """
-        return len(self.bricks)
-
-    @property
-    def num_active_hinges(self) -> int:
-        """
-        Get the number of active hinges.
-
-        :returns: The number of active hinges.
-        """
-        return len(self.active_hinges)
-
-    @property
-    def num_filled_bricks(self) -> int:
-        """
-        Get the number of bricks which have all slots filled with other modules.
-
-        :returns: The number of bricks.
-        """
-        return len(self.filled_bricks)
-
-    @property
-    def num_filled_active_hinges(self) -> int:
-        """
-        Get the number of bricks which have all slots filled with other modules.
-
-        :returns: The number of bricks.
-        """
-        return len(self.filled_active_hinges)
-
-    @property
-    def num_filled_modules(self) -> int:
-        """
-        Get the number of modules which have all slots filled with other modules, including the core.
-
-        :returns: The number of modules.
-        """
-        return (
-            self.num_filled_bricks
-            + self.num_active_hinges
-            + (1 if self.core_is_filled else 0)
-        )
-
-    @property
-    def max_potentionally_filled_core_and_bricks(self) -> int:
-        """
-        Get the maximum number of core and bricks that could potentially be filled with this set of modules if rearranged in an optimal way.
-
-        This calculates 'b_max' from the paper.
-
-        :returns: The calculated number.
-        """
-        # Snake-like is an optimal arrangement.
-        #
-        #   H H H H
-        #   | | | |
-        # H-C-B-B-B-H
-        #   | | | |
-        #   H H H H
-        #
-        # Every extra brick(B) requires 3 modules:
-        # The bricks itself and two other modules for its sides(here displayed as H).
-        # However, the core and final brick require three each to fill, which is cheaper than another brick.
-        #
-        # Expected sequence:
-        # | num modules | 1 2 3 4 5 6 7 8 9 10 11 12 14
-        # | return val  | 0 0 0 0 1 1 1 2 2 2  3  3  3
-
-        pot_max_filled = max(0, (self.num_modules - 2) // 3)
-
-        # Enough bricks must be available for this strategy.
-        # We can count the core as the first brick.
-        pot_max_filled = min(pot_max_filled, 1 + self.num_bricks)
-
-        return pot_max_filled
-
-    @property
-    def filled_core_and_bricks_proportion(self) -> float:
-        """
-        Get the ratio between filled cores and bricks and how many that potentially could have been if this set of modules was rearranged in an optimal way.
-
-        This calculates 'branching' from the paper.
-
-        :returns: The proportion.
-        """
-        if self.max_potentionally_filled_core_and_bricks == 0:
-            return 0.0
-
-        return (
-            len(self.filled_bricks) + (1 if self.core_is_filled else 0)
-        ) / self.max_potentionally_filled_core_and_bricks
-
-    @property
-    def num_single_neighbour_bricks(self) -> int:
-        """
-        Get the number of bricks that are only connected to one other module.
-
-        Both children and parent are counted.
-
-        :returns: The number of bricks.
-        """
-        return len(self.single_neighbour_bricks)
-
-    @property
-    def max_potential_single_neighbour_bricks(self) -> int:
-        """
-        Get the maximum number of bricks that could potentially have only one neighbour if this set of modules was rearranged in an optimal way.
-
-        This calculates "l_max" from the paper.
-
-        :returns: The calculated number.
-        """
-        # Snake-like is an optimal arrangement.
-        #
-        #   B B B B B
-        #   | | | | |
-        # B-C-B-B-B-B-B
-        #   | | | | |
-        #   B B B B B
-        #
-        # Active hinges are irrelevant because they can always be placed in between two modules without affecting this number.
-        #
-        # Expected sequence:
-        # | num bricks | 0 1 2 3 4 5 6 7 8 9
-        # | return val | 0 1 2 3 4 4 5 6 6 7
-
-        return self.num_bricks - max(0, (self.num_bricks - 2) // 3)
-
-    @property
-    def single_neighbour_brick_proportion(self) -> float:
-        """
-        Get the ratio between bricks with a single neighbour and with how many bricks that potentionally could have been if this set of modules was rearranged in an optimal way.
-
-        This calculates limb proportion(extremities) from the paper.
-
-        :returns: The proportion.
-        """
-        if self.max_potential_single_neighbour_bricks == 0:
-            return 0.0
-
-        return (
-            self.num_single_neighbour_bricks
-            / self.max_potential_single_neighbour_bricks
-        )
-
-    @property
-    def num_double_neighbour_bricks(self) -> int:
-        """
-        Get the number of bricks that are connected to exactly two other modules.
-
-        Both children and parent are counted.
-
-        :returns: The number of bricks.
-        """
-        return len(self.double_neighbour_bricks)
-
-    @property
-    def num_double_neighbour_active_hinges(self) -> int:
-        """
-        Get the number of active hinges that are connected to exactly two other modules.
-
-        Both children and parent are counted.
-
-        :returns: The number of active hinges.
-        """
-        return len(self.double_neighbour_active_hinges)
-
-    @property
-    def potential_double_neighbour_bricks_and_active_hinges(self) -> int:
-        """
-        Get the maximum number of bricks and active hinges that could potentially have exactly two neighbours if this set of modules was rearranged in an optimal way.
-
-        This calculates e_max from the paper.
-
-        :returns: The calculated number.
-        """
-        #
-        # C-M-M-M-M-M
-        #
-        # Snake in direction is optimal, no matter whether modules are bricks or active hinges.
-        #
-        # Simply add up the number of bricks and active hinges and subtract 1 for the final module.
-
-        return max(0, self.num_bricks + self.num_active_hinges - 1)
-
-    @property
-    def double_neighbour_brick_and_active_hinge_proportion(self) -> float:
-        """
-        Get the ratio between the number of bricks and active hinges with exactly two neighbours and how many that could potentially have been if this set of modules was rearranged in an optimal way.
-
-        This calculate length of limbs proportion(extensiveness) from the paper.
-
-        :returns: The proportion.
-        """
-        if self.potential_double_neighbour_bricks_and_active_hinges == 0:
-            return 0.0
-
-        return (
-            self.num_double_neighbour_bricks + self.num_double_neighbour_active_hinges
-        ) / self.potential_double_neighbour_bricks_and_active_hinges
-
-    @property
-    def bounding_box_volume(self) -> int:
-        """
-        Get the volume of the bounding box.
-
-        This calculates m_area from the paper.
-
-        :returns: The volume.
-        """
-        return (
-            self.bounding_box_width * self.bounding_box_height * self.bounding_box_depth
-        )
-
-    @property
-    def bounding_box_volume_coverage(self) -> float:
-        """
-        Get the proportion of the bounding box that is filled with modules.
-
-        This calculates 'coverage' from the paper.
-
-        :returns: The proportion.
-        """
-        return self.num_modules / self.bounding_box_volume
-
-    @property
-    def branching(self) -> float:
-        """
-        Get the 'branching' measurement from the paper.
-
-        Alias for filled_core_and_bricks_proportion.
-
-        :returns: Branching measurement.
-        """
-        return self.filled_core_and_bricks_proportion
-
-    @property
-    def limbs(self) -> float:
-        """
-        Get the 'limbs' measurement from the paper.
-
-        Alias for single_neighbour_brick_proportion.
-
-        :returns: Limbs measurement.
-        """
-        return self.single_neighbour_brick_proportion
-
-    @property
-    def length_of_limbs(self) -> float:
-        """
-        Get the 'length of limbs' measurement from the paper.
-
-        Alias for double_neighbour_brick_and_active_hinge_proportion.
-
-        :returns: Length of limbs measurement.
-        """
-        return self.double_neighbour_brick_and_active_hinge_proportion
-
-    @property
-    def coverage(self) -> float:
-        """
-        Get the 'coverage' measurement from the paper.
-
-        Alias for bounding_box_volume_coverage.
-
-        :returns: Coverage measurement.
-        """
-        return self.bounding_box_volume_coverage
-
-    @property
-    def proportion_2d(self) -> float:
-        """
-        Get the 'proportion' measurement from the paper.
-
-        Only for 2d robots.
-
-        :returns: Proportion measurement.
-        """
-        assert self.is_2d
-
-        return min(self.bounding_box_depth, self.bounding_box_width) / max(
-            self.bounding_box_depth, self.bounding_box_width
-        )
-
-    @property
-    def symmetry(self) -> float:
-        """
-        Get the 'symmetry' measurement from the paper, but extended to 3d.
-
-        :returns: Symmetry measurement.
-        """
-        return max(self.xy_symmetry, self.xz_symmetry, self.yz_symmetry)
+"""MorphologicalMeasures class."""
+
+from itertools import product
+from typing import Generic, TypeVar
+
+import numpy as np
+from numpy.typing import NDArray
+from pyrr import Vector3
+
+from revolve2.modular_robot.body import Module
+from revolve2.modular_robot.body.base import ActiveHinge, Body, Brick, Core
+
+TModule = TypeVar("TModule", bound=np.generic)
+
+
+class MorphologicalMeasures(Generic[TModule]):
+    """
+    Modular robot morphological measures.
+
+    Only works for robot with only right angle module rotations (90 degrees).
+    Some measures only work for 2d robots, which is noted in their docstring.
+
+    The measures are based on the following paper:
+    Miras, K., Haasdijk, E., Glette, K., Eiben, A.E. (2018).
+    Search Space Analysis of Evolvable Robot Morphologies.
+    In: Sim, K., Kaufmann, P. (eds) Applications of Evolutionary Computation.
+    EvoApplications 2018. Lecture Notes in Computer Science(), vol 10784. Springer, Cham.
+    https://doi.org/10.1007/978-3-319-77538-8_47
+    """
+
+    """Represents the modules of a body in a 3D tensor."""
+    grid: NDArray[TModule]
+    symmetry_grid: NDArray[TModule]
+    """Position of the core in 'body_as_grid'."""
+    core_grid_position: Vector3[np.int_]
+
+    """If the robot is two dimensional, i.e. all module rotations are 0 degrees."""
+    is_2d: bool
+
+    core: Core
+    bricks: list[Brick]
+    active_hinges: list[ActiveHinge]
+
+    """If all slots of the core are filled with other modules."""
+    core_is_filled: bool
+
+    """Bricks which have all slots filled with other modules."""
+    filled_bricks: list[Brick]
+
+    """Active hinges which have all slots filled with other modules."""
+    filled_active_hinges: list[ActiveHinge]
+
+    """
+    Bricks that are only connected to one other module.
+
+    Both children and parent are counted.
+    """
+    single_neighbour_bricks: list[Brick]
+
+    """
+    Bricks that are connected to exactly two other modules.
+
+    Both children and parent are counted.
+    """
+    double_neighbour_bricks: list[Brick]
+
+    """
+    Active hinges that are connected to exactly two other modules.
+
+    Both children and parent are counted.
+    """
+    double_neighbour_active_hinges: list[ActiveHinge]
+
+    """
+    X/Y-plane symmetry according to the paper but in 3D.
+
+    X-axis is defined as forward/backward for the core module
+    Y-axis is defined as left/right for the core module.
+    """
+    xy_symmetry: float
+
+    """
+    X/Z-plane symmetry according to the paper but in 3D.
+
+    X-axis is defined as forward/backward for the core module
+    Z-axis is defined as up/down for the core module.
+    """
+    xz_symmetry: float
+
+    """
+    Y/Z-plane symmetry according to the paper but in 3D.
+
+    Y-axis is defined as left/right for the core module.
+    Z-axis is defined as up/down for the core module.
+    """
+    yz_symmetry: float
+
+    def __init__(self, body: Body) -> None:
+        """
+        Initialize this object.
+
+        :param body: The body to measure.
+        """
+        self.grid, self.core_grid_position = body.to_grid()
+        self.core = body.core
+        self.is_2d = self.__calculate_is_2d_recur(self.core)
+        self.bricks = body.find_modules_of_type(Brick)
+        self.active_hinges = body.find_modules_of_type(ActiveHinge)
+        self.core_is_filled = self.__calculate_core_is_filled()
+        self.filled_bricks = self.__calculate_filled_bricks()
+        self.filled_active_hinges = self.__calculate_filled_active_hinges()
+        self.single_neighbour_bricks = self.__calculate_single_neighbour_bricks()
+        self.double_neighbour_bricks = self.__calculate_double_neighbour_bricks()
+        self.double_neighbour_active_hinges = (
+            self.__calculate_double_neighbour_active_hinges()
+        )
+
+        self.__pad_grid()
+        self.xy_symmetry = self.__calculate_xy_symmetry()
+        self.xz_symmetry = self.__calculate_xz_symmetry()
+        self.yz_symmetry = self.__calculate_yz_symmetry()
+
+    @classmethod
+    def __calculate_is_2d_recur(cls, module: Module) -> bool:
+        return all(
+            [np.isclose(module.rotation, 0.0)]
+            + [cls.__calculate_is_2d_recur(child) for child in module.children.values()]
+        )
+
+    def __calculate_core_is_filled(self) -> bool:
+        return all(
+            [
+                self.core.children.get(child_index) is not None
+                for child_index in self.core.attachment_points.keys()
+            ]
+        )
+
+    def __calculate_filled_bricks(self) -> list[Brick]:
+        return [
+            brick
+            for brick in self.bricks
+            if all(
+                [
+                    brick.children.get(child_index) is not None
+                    for child_index in brick.attachment_points.keys()
+                ]
+            )
+        ]
+
+    def __calculate_filled_active_hinges(self) -> list[ActiveHinge]:
+        return [
+            active_hinge
+            for active_hinge in self.active_hinges
+            if all(
+                [
+                    active_hinge.children.get(child_index) is not None
+                    for child_index in active_hinge.attachment_points.keys()
+                ]
+            )
+        ]
+
+    def __calculate_single_neighbour_bricks(self) -> list[Brick]:
+        return [
+            brick
+            for brick in self.bricks
+            if all(
+                [
+                    brick.children.get(child_index) is None
+                    for child_index in brick.attachment_points.keys()
+                ]
+            )
+        ]
+
+    def __calculate_double_neighbour_bricks(self) -> list[Brick]:
+        return [
+            brick
+            for brick in self.bricks
+            if sum(
+                [
+                    0 if brick.children.get(child_index) is None else 1
+                    for child_index in brick.attachment_points.keys()
+                ]
+            )
+            == 1
+        ]
+
+    def __calculate_double_neighbour_active_hinges(self) -> list[ActiveHinge]:
+        return [
+            active_hinge
+            for active_hinge in self.active_hinges
+            if sum(
+                [
+                    0 if active_hinge.children.get(child_index) is None else 1
+                    for child_index in active_hinge.attachment_points.keys()
+                ]
+            )
+            == 1
+        ]
+
+    def __pad_grid(self) -> None:
+        x, y, z = self.grid.shape
+        xoffs, yoffs, zoffs = self.core_grid_position
+        self.symmetry_grid = np.empty(
+            shape=(x + xoffs, y + yoffs, z + zoffs), dtype=Module
+        )
+        self.symmetry_grid.fill(None)
+        self.symmetry_grid[:x, :y, :z] = self.grid
+
+    def __calculate_xy_symmetry(self) -> float:
+        num_along_plane = 0
+        num_symmetrical = 0
+        for x, y, z in product(
+            range(self.bounding_box_depth),
+            range(self.bounding_box_width),
+            range(1, (self.bounding_box_height - 1) // 2),
+        ):
+            if self.symmetry_grid[x, y, self.core_grid_position[2]] is not None:
+                num_along_plane += 1
+            if self.symmetry_grid[
+                x, y, self.core_grid_position[2] + z
+            ] is not None and type(
+                self.symmetry_grid[x, y, self.core_grid_position[2] + z]
+            ) is type(
+                self.symmetry_grid[x, y, self.core_grid_position[2] - z]
+            ):
+                num_symmetrical += 2
+
+        difference = self.num_modules - num_along_plane
+        return num_symmetrical / difference if difference > 0.0 else difference
+
+    def __calculate_xz_symmetry(self) -> float:
+        num_along_plane = 0
+        num_symmetrical = 0
+        for x, y, z in product(
+            range(self.bounding_box_depth),
+            range(1, (self.bounding_box_width - 1) // 2),
+            range(self.bounding_box_height),
+        ):
+            if self.symmetry_grid[x, self.core_grid_position[1], z] is not None:
+                num_along_plane += 1
+            if self.symmetry_grid[
+                x, self.core_grid_position[1] + y, z
+            ] is not None and type(
+                self.symmetry_grid[x, self.core_grid_position[1] + y, z]
+            ) is type(
+                self.symmetry_grid[x, self.core_grid_position[1] - y, z]
+            ):
+                num_symmetrical += 2
+        difference = self.num_modules - num_along_plane
+        return num_symmetrical / difference if difference > 0.0 else difference
+
+    def __calculate_yz_symmetry(self) -> float:
+        num_along_plane = 0
+        num_symmetrical = 0
+        for x, y, z in product(
+            range(1, (self.bounding_box_depth - 1) // 2),
+            range(self.bounding_box_width),
+            range(self.bounding_box_height),
+        ):
+            if self.symmetry_grid[self.core_grid_position[0], y, z] is not None:
+                num_along_plane += 1
+            if self.symmetry_grid[
+                self.core_grid_position[0] + x, y, z
+            ] is not None and type(
+                self.symmetry_grid[self.core_grid_position[0] + x, y, z]
+            ) is type(
+                self.symmetry_grid[self.core_grid_position[0] - x, y, z]
+            ):
+                num_symmetrical += 2
+        difference = self.num_modules - num_along_plane
+        return num_symmetrical / difference if difference > 0.0 else difference
+
+    @property
+    def bounding_box_depth(self) -> int:
+        """
+        Get the depth of the bounding box around the body.
+
+        Forward/backward axis for the core module.
+
+        :returns: The depth.
+        """
+        return self.grid.shape[0]
+
+    @property
+    def bounding_box_width(self) -> int:
+        """
+        Get the width of the bounding box around the body.
+
+        Right/left axis for the core module.
+
+        :returns: The width.
+        """
+        return self.grid.shape[1]
+
+    @property
+    def bounding_box_height(self) -> int:
+        """
+        Get the height of the bounding box around the body.
+
+        Up/down axis for the core module.
+
+        :returns: The height.
+        """
+        return self.grid.shape[2]
+
+    @property
+    def num_modules(self) -> int:
+        """
+        Get the number of modules.
+
+        :returns: The number of modules.
+        """
+        return 1 + self.num_bricks + self.num_active_hinges
+
+    @property
+    def num_bricks(self) -> int:
+        """
+        Get the number of bricks.
+
+        :returns: The number of bricks.
+        """
+        return len(self.bricks)
+
+    @property
+    def num_active_hinges(self) -> int:
+        """
+        Get the number of active hinges.
+
+        :returns: The number of active hinges.
+        """
+        return len(self.active_hinges)
+
+    @property
+    def num_filled_bricks(self) -> int:
+        """
+        Get the number of bricks which have all slots filled with other modules.
+
+        :returns: The number of bricks.
+        """
+        return len(self.filled_bricks)
+
+    @property
+    def num_filled_active_hinges(self) -> int:
+        """
+        Get the number of bricks which have all slots filled with other modules.
+
+        :returns: The number of bricks.
+        """
+        return len(self.filled_active_hinges)
+
+    @property
+    def num_filled_modules(self) -> int:
+        """
+        Get the number of modules which have all slots filled with other modules, including the core.
+
+        :returns: The number of modules.
+        """
+        return (
+            self.num_filled_bricks
+            + self.num_active_hinges
+            + (1 if self.core_is_filled else 0)
+        )
+
+    @property
+    def max_potentionally_filled_core_and_bricks(self) -> int:
+        """
+        Get the maximum number of core and bricks that could potentially be filled with this set of modules if rearranged in an optimal way.
+
+        This calculates 'b_max' from the paper.
+
+        :returns: The calculated number.
+        """
+        # Snake-like is an optimal arrangement.
+        #
+        #   H H H H
+        #   | | | |
+        # H-C-B-B-B-H
+        #   | | | |
+        #   H H H H
+        #
+        # Every extra brick(B) requires 3 modules:
+        # The bricks itself and two other modules for its sides(here displayed as H).
+        # However, the core and final brick require three each to fill, which is cheaper than another brick.
+        #
+        # Expected sequence:
+        # | num modules | 1 2 3 4 5 6 7 8 9 10 11 12 14
+        # | return val  | 0 0 0 0 1 1 1 2 2 2  3  3  3
+
+        pot_max_filled = max(0, (self.num_modules - 2) // 3)
+
+        # Enough bricks must be available for this strategy.
+        # We can count the core as the first brick.
+        pot_max_filled = min(pot_max_filled, 1 + self.num_bricks)
+
+        return pot_max_filled
+
+    @property
+    def filled_core_and_bricks_proportion(self) -> float:
+        """
+        Get the ratio between filled cores and bricks and how many that potentially could have been if this set of modules was rearranged in an optimal way.
+
+        This calculates 'branching' from the paper.
+
+        :returns: The proportion.
+        """
+        if self.max_potentionally_filled_core_and_bricks == 0:
+            return 0.0
+
+        return (
+            len(self.filled_bricks) + (1 if self.core_is_filled else 0)
+        ) / self.max_potentionally_filled_core_and_bricks
+
+    @property
+    def num_single_neighbour_bricks(self) -> int:
+        """
+        Get the number of bricks that are only connected to one other module.
+
+        Both children and parent are counted.
+
+        :returns: The number of bricks.
+        """
+        return len(self.single_neighbour_bricks)
+
+    @property
+    def max_potential_single_neighbour_bricks(self) -> int:
+        """
+        Get the maximum number of bricks that could potentially have only one neighbour if this set of modules was rearranged in an optimal way.
+
+        This calculates "l_max" from the paper.
+
+        :returns: The calculated number.
+        """
+        # Snake-like is an optimal arrangement.
+        #
+        #   B B B B B
+        #   | | | | |
+        # B-C-B-B-B-B-B
+        #   | | | | |
+        #   B B B B B
+        #
+        # Active hinges are irrelevant because they can always be placed in between two modules without affecting this number.
+        #
+        # Expected sequence:
+        # | num bricks | 0 1 2 3 4 5 6 7 8 9
+        # | return val | 0 1 2 3 4 4 5 6 6 7
+
+        return self.num_bricks - max(0, (self.num_bricks - 2) // 3)
+
+    @property
+    def single_neighbour_brick_proportion(self) -> float:
+        """
+        Get the ratio between bricks with a single neighbour and with how many bricks that potentionally could have been if this set of modules was rearranged in an optimal way.
+
+        This calculates limb proportion(extremities) from the paper.
+
+        :returns: The proportion.
+        """
+        if self.max_potential_single_neighbour_bricks == 0:
+            return 0.0
+
+        return (
+            self.num_single_neighbour_bricks
+            / self.max_potential_single_neighbour_bricks
+        )
+
+    @property
+    def num_double_neighbour_bricks(self) -> int:
+        """
+        Get the number of bricks that are connected to exactly two other modules.
+
+        Both children and parent are counted.
+
+        :returns: The number of bricks.
+        """
+        return len(self.double_neighbour_bricks)
+
+    @property
+    def num_double_neighbour_active_hinges(self) -> int:
+        """
+        Get the number of active hinges that are connected to exactly two other modules.
+
+        Both children and parent are counted.
+
+        :returns: The number of active hinges.
+        """
+        return len(self.double_neighbour_active_hinges)
+
+    @property
+    def potential_double_neighbour_bricks_and_active_hinges(self) -> int:
+        """
+        Get the maximum number of bricks and active hinges that could potentially have exactly two neighbours if this set of modules was rearranged in an optimal way.
+
+        This calculates e_max from the paper.
+
+        :returns: The calculated number.
+        """
+        #
+        # C-M-M-M-M-M
+        #
+        # Snake in direction is optimal, no matter whether modules are bricks or active hinges.
+        #
+        # Simply add up the number of bricks and active hinges and subtract 1 for the final module.
+
+        return max(0, self.num_bricks + self.num_active_hinges - 1)
+
+    @property
+    def double_neighbour_brick_and_active_hinge_proportion(self) -> float:
+        """
+        Get the ratio between the number of bricks and active hinges with exactly two neighbours and how many that could potentially have been if this set of modules was rearranged in an optimal way.
+
+        This calculate length of limbs proportion(extensiveness) from the paper.
+
+        :returns: The proportion.
+        """
+        if self.potential_double_neighbour_bricks_and_active_hinges == 0:
+            return 0.0
+
+        return (
+            self.num_double_neighbour_bricks + self.num_double_neighbour_active_hinges
+        ) / self.potential_double_neighbour_bricks_and_active_hinges
+
+    @property
+    def bounding_box_volume(self) -> int:
+        """
+        Get the volume of the bounding box.
+
+        This calculates m_area from the paper.
+
+        :returns: The volume.
+        """
+        return (
+            self.bounding_box_width * self.bounding_box_height * self.bounding_box_depth
+        )
+
+    @property
+    def bounding_box_volume_coverage(self) -> float:
+        """
+        Get the proportion of the bounding box that is filled with modules.
+
+        This calculates 'coverage' from the paper.
+
+        :returns: The proportion.
+        """
+        return self.num_modules / self.bounding_box_volume
+
+    @property
+    def branching(self) -> float:
+        """
+        Get the 'branching' measurement from the paper.
+
+        Alias for filled_core_and_bricks_proportion.
+
+        :returns: Branching measurement.
+        """
+        return self.filled_core_and_bricks_proportion
+
+    @property
+    def limbs(self) -> float:
+        """
+        Get the 'limbs' measurement from the paper.
+
+        Alias for single_neighbour_brick_proportion.
+
+        :returns: Limbs measurement.
+        """
+        return self.single_neighbour_brick_proportion
+
+    @property
+    def length_of_limbs(self) -> float:
+        """
+        Get the 'length of limbs' measurement from the paper.
+
+        Alias for double_neighbour_brick_and_active_hinge_proportion.
+
+        :returns: Length of limbs measurement.
+        """
+        return self.double_neighbour_brick_and_active_hinge_proportion
+
+    @property
+    def coverage(self) -> float:
+        """
+        Get the 'coverage' measurement from the paper.
+
+        Alias for bounding_box_volume_coverage.
+
+        :returns: Coverage measurement.
+        """
+        return self.bounding_box_volume_coverage
+
+    @property
+    def proportion_2d(self) -> float:
+        """
+        Get the 'proportion' measurement from the paper.
+
+        Only for 2d robots.
+
+        :returns: Proportion measurement.
+        """
+        assert self.is_2d
+
+        return min(self.bounding_box_depth, self.bounding_box_width) / max(
+            self.bounding_box_depth, self.bounding_box_width
+        )
+
+    @property
+    def symmetry(self) -> float:
+        """
+        Get the 'symmetry' measurement from the paper, but extended to 3d.
+
+        :returns: Symmetry measurement.
+        """
+        return max(self.xy_symmetry, self.xz_symmetry, self.yz_symmetry)
```

## revolve2/ci_group/morphological_novelty_metric/__init__.py

 * *Ordering differences only*

```diff
@@ -1,12 +1,12 @@
-"""
-Calculate Morphological Novelty across a Population.
-
-Using the MorphologicalNoveltyMetric for evaluating a population of robots can be done as shown in the code below.
-
- >>> robots: list[revolve2.modular_robot.ModularRobot]
- >>> novelties = get_novelty_from_population(robots)
-"""
-
-from ._morphological_novelty_metric import get_novelty_from_population
-
-__all__ = ["get_novelty_from_population"]
+"""
+Calculate Morphological Novelty across a Population.
+
+Using the MorphologicalNoveltyMetric for evaluating a population of robots can be done as shown in the code below.
+
+ >>> robots: list[revolve2.modular_robot.ModularRobot]
+ >>> novelties = get_novelty_from_population(robots)
+"""
+
+from ._morphological_novelty_metric import get_novelty_from_population
+
+__all__ = ["get_novelty_from_population"]
```

## revolve2/ci_group/morphological_novelty_metric/_build_cmodule.py

 * *Ordering differences only*

```diff
@@ -1,59 +1,59 @@
-import os
-from os.path import join
-
-import numpy
-from Cython.Build import cythonize
-from setuptools import Extension, setup
-
-
-def build() -> None:
-    """
-    Build the morphological novelty shared object.
-
-    :raises OSError: If the users OS is not Windows or UNIX-based.
-    """
-    directory_path = os.path.dirname(os.path.abspath(__file__))
-
-    source = join(directory_path, "_calculate_novelty.pyx")
-
-    include = numpy.get_include()
-
-    match os.name:
-        case "nt":  # Windows
-            extra_compile_args = [
-                "/O2",
-                "-UNDEBUG",
-            ]
-        case "posix":  # UNIX-based systems
-            extra_compile_args = [
-                "-O3",
-                "-ffast-math",
-                "-UNDEBUG",
-            ]
-        case _:
-            raise OSError(
-                f"No build parameter set for operating systems of type {os.name}"
-            )
-
-    ext = Extension(
-        name="calculate_novelty",
-        sources=[source],
-        include_dirs=[include],
-        define_macros=[("NPY_NO_DEPRECATED_API", "NPY_1_7_API_VERSION")],
-        extra_compile_args=extra_compile_args,
-    )
-
-    ext_modules = cythonize(
-        ext,
-        include_path=[include],
-        compiler_directives={"binding": True, "language_level": 3},
-    )
-
-    setup(
-        ext_modules=ext_modules,
-        script_args=["build_ext", f"--build-lib={directory_path}"],
-    )
-
-
-if __name__ == "__main__":
-    build()
+import os
+from os.path import join
+
+import numpy
+from Cython.Build import cythonize
+from setuptools import Extension, setup
+
+
+def build() -> None:
+    """
+    Build the morphological novelty shared object.
+
+    :raises OSError: If the users OS is not Windows or UNIX-based.
+    """
+    directory_path = os.path.dirname(os.path.abspath(__file__))
+
+    source = join(directory_path, "_calculate_novelty.pyx")
+
+    include = numpy.get_include()
+
+    match os.name:
+        case "nt":  # Windows
+            extra_compile_args = [
+                "/O2",
+                "-UNDEBUG",
+            ]
+        case "posix":  # UNIX-based systems
+            extra_compile_args = [
+                "-O3",
+                "-ffast-math",
+                "-UNDEBUG",
+            ]
+        case _:
+            raise OSError(
+                f"No build parameter set for operating systems of type {os.name}"
+            )
+
+    ext = Extension(
+        name="calculate_novelty",
+        sources=[source],
+        include_dirs=[include],
+        define_macros=[("NPY_NO_DEPRECATED_API", "NPY_1_7_API_VERSION")],
+        extra_compile_args=extra_compile_args,
+    )
+
+    ext_modules = cythonize(
+        ext,
+        include_path=[include],
+        compiler_directives={"binding": True, "language_level": 3},
+    )
+
+    setup(
+        ext_modules=ext_modules,
+        script_args=["build_ext", f"--build-lib={directory_path}"],
+    )
+
+
+if __name__ == "__main__":
+    build()
```

## revolve2/ci_group/morphological_novelty_metric/_calculate_novelty.pyx

 * *Ordering differences only*

```diff
@@ -1,81 +1,81 @@
-#cython: language_level=3
-cimport cython
-import numpy as np
-from libc.math cimport sqrt
-from numpy cimport ndarray
-
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-@cython.nonecheck(False)
-cdef double move_supply(
-        long[:,:] supply,
-        long[:,:] capacity,
-        (int, int) from_index,
-        (int, int) to_index,
-):
-    cdef double distance
-    cdef long flow
-    cdef int zero_state = 0
-    if supply[from_index[0], from_index[1]] <= capacity[to_index[0], to_index[1]]:
-        flow = supply[from_index[0], from_index[1]]
-        capacity[to_index[0], to_index[1]] = capacity[to_index[0], to_index[1]]-flow
-        supply[from_index[0], from_index[1]] = zero_state
-    else:
-        flow = capacity[to_index[0], to_index[1]]
-        supply[from_index[0], from_index[1]] = supply[from_index[0], from_index[1]]-flow
-        capacity[to_index[0], to_index[1]] = zero_state
-    distance = sqrt((from_index[0]-to_index[0])**2 + (from_index[1]-to_index[1])**2)
-    return flow*distance
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-cdef (int, int) find_first_candidate(long[:,:] array, int hist_shape, (int, int) prev):
-    cdef int ie, je
-    cdef (int, int) neg_return = (-1, -1)
-    cdef int zero_state = 0
-    for ie in range(prev[0], hist_shape):
-        for je in range(prev[1], hist_shape):
-            if array[ie, je] > zero_state:
-                return ie, je
-    return neg_return
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-cdef double wasserstein_distance(
-        long[:,:] supply,
-        long[:,:] capacity,
-        int hist_shape,
-):
-    cdef double score = 0.0
-    cdef int i, j
-    cdef (int, int) from_index = (0, 0), to_index = (0, 0)
-    cdef int zero_state = 0
-
-    for i in range(hist_shape):
-        from_index = find_first_candidate(supply, hist_shape, from_index)
-        for j in range(hist_shape):
-            to_index = find_first_candidate(capacity, hist_shape, to_index)
-            if from_index[0] < zero_state or to_index[0] < zero_state:
-                return score
-            work = move_supply(supply, capacity, from_index, to_index)
-            score += work
-    return score
-
-@cython.boundscheck(False)
-@cython.wraparound(False)
-cpdef ndarray[double, ndim=1] calculate_novelty(ndarray[long, ndim=3, mode="c"] histograms, int amount_instances, int histogram_size):
-    cdef ndarray[double, ndim=1, mode="c"] novelty_scores = np.zeros(shape=amount_instances)
-    cdef int i, j
-    cdef long[:,:] supply, capacity
-    cdef ndarray[long, ndim=3, mode="c"] tmp_hist
-
-    for i in range(amount_instances-1):
-        for j in range(i+1, amount_instances):
-            tmp_hist = histograms.copy()
-            supply = tmp_hist[i]
-            capacity = tmp_hist[j]
-            score = wasserstein_distance(supply, capacity , histogram_size)
-            novelty_scores[i] += score
-            novelty_scores[j] += score
-    return novelty_scores
+#cython: language_level=3
+cimport cython
+import numpy as np
+from libc.math cimport sqrt
+from numpy cimport ndarray
+
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+@cython.nonecheck(False)
+cdef double move_supply(
+        long[:,:] supply,
+        long[:,:] capacity,
+        (int, int) from_index,
+        (int, int) to_index,
+):
+    cdef double distance
+    cdef long flow
+    cdef int zero_state = 0
+    if supply[from_index[0], from_index[1]] <= capacity[to_index[0], to_index[1]]:
+        flow = supply[from_index[0], from_index[1]]
+        capacity[to_index[0], to_index[1]] = capacity[to_index[0], to_index[1]]-flow
+        supply[from_index[0], from_index[1]] = zero_state
+    else:
+        flow = capacity[to_index[0], to_index[1]]
+        supply[from_index[0], from_index[1]] = supply[from_index[0], from_index[1]]-flow
+        capacity[to_index[0], to_index[1]] = zero_state
+    distance = sqrt((from_index[0]-to_index[0])**2 + (from_index[1]-to_index[1])**2)
+    return flow*distance
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+cdef (int, int) find_first_candidate(long[:,:] array, int hist_shape, (int, int) prev):
+    cdef int ie, je
+    cdef (int, int) neg_return = (-1, -1)
+    cdef int zero_state = 0
+    for ie in range(prev[0], hist_shape):
+        for je in range(prev[1], hist_shape):
+            if array[ie, je] > zero_state:
+                return ie, je
+    return neg_return
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+cdef double wasserstein_distance(
+        long[:,:] supply,
+        long[:,:] capacity,
+        int hist_shape,
+):
+    cdef double score = 0.0
+    cdef int i, j
+    cdef (int, int) from_index = (0, 0), to_index = (0, 0)
+    cdef int zero_state = 0
+
+    for i in range(hist_shape):
+        from_index = find_first_candidate(supply, hist_shape, from_index)
+        for j in range(hist_shape):
+            to_index = find_first_candidate(capacity, hist_shape, to_index)
+            if from_index[0] < zero_state or to_index[0] < zero_state:
+                return score
+            work = move_supply(supply, capacity, from_index, to_index)
+            score += work
+    return score
+
+@cython.boundscheck(False)
+@cython.wraparound(False)
+cpdef ndarray[double, ndim=1] calculate_novelty(ndarray[long, ndim=3, mode="c"] histograms, int amount_instances, int histogram_size):
+    cdef ndarray[double, ndim=1, mode="c"] novelty_scores = np.zeros(shape=amount_instances)
+    cdef int i, j
+    cdef long[:,:] supply, capacity
+    cdef ndarray[long, ndim=3, mode="c"] tmp_hist
+
+    for i in range(amount_instances-1):
+        for j in range(i+1, amount_instances):
+            tmp_hist = histograms.copy()
+            supply = tmp_hist[i]
+            capacity = tmp_hist[j]
+            score = wasserstein_distance(supply, capacity , histogram_size)
+            novelty_scores[i] += score
+            novelty_scores[j] += score
+    return novelty_scores
```

## revolve2/ci_group/morphological_novelty_metric/_coordinate_operations.py

 * *Ordering differences only*

```diff
@@ -1,113 +1,113 @@
-from itertools import product
-from typing import Any
-
-import numpy as np
-from numpy.typing import NDArray
-from pyrr import Vector3
-
-from revolve2.modular_robot.body import Module
-from revolve2.modular_robot.body.base import Body
-
-
-def coords_from_bodies(
-    bodies: list[Body], cob_heuristics: bool
-) -> list[NDArray[np.float64]]:
-    """
-    Extract coordinates of modules from a body.
-
-    :param bodies: The bodies.
-    :param cob_heuristics: If change of basis heuristic approximation is used.
-    :return: The array of coordinates.
-    """
-    crds = _body_to_adjusted_coordinates(bodies)
-    if cob_heuristics:
-        _coordinates_pca_heuristic(crds)
-    else:
-        _coordinates_pca_change_basis(crds)
-    return crds
-
-
-def _body_to_adjusted_coordinates(bodies: list[Body]) -> list[NDArray[np.float64]]:
-    """
-    Extract coordinates of modules in a body and adjusts them with the core position.
-
-    :param bodies: The body.
-    :return: The coordinates for each body.
-    """
-    crds = [np.empty(shape=0, dtype=np.float64)] * len(bodies)
-    i = 0
-    for body in bodies:
-        tpl: tuple[NDArray[Any], Vector3] = body.to_grid()
-        body_array, core_position = tpl
-        x, y, z = body_array.shape
-
-        elements = []
-        for xe, ye, ze in product(range(x), range(y), range(z)):
-            target = body_array[xe, ye, ze]
-            if isinstance(target, Module):
-                elements.append(np.subtract((xe, ye, ze), core_position))
-        crds[i] = np.asarray(elements)
-        i += 1
-    return crds
-
-
-def _coordinates_pca_change_basis(coordinates: list[NDArray[np.float64]]) -> None:
-    """
-    Transform the coordinate distribution by the magnitude of variance of the respective basis.
-
-    The detailed steps of the transformation are discussed in the paper.
-
-    :param coordinates: The coordinates.
-    """
-    i = 0
-    for target_coordinates in coordinates:
-        if len(target_coordinates) > 1:
-            covariance_matrix = np.cov(target_coordinates.T)
-            eigen_values, eigen_vectors = np.linalg.eig(covariance_matrix)
-
-            # sorting axis by amplitude of variance
-            srt = np.argsort(eigen_values)[::-1]
-            for j in range(len(srt)):
-                if srt[j] == j:
-                    continue
-                candidate = srt[j]
-
-                # here we start rotating using Rodrigues` rotation formula.
-                rx, ry, rz = eigen_vectors[candidate] / np.linalg.norm(
-                    eigen_vectors[candidate]
-                )
-                k = np.array([[0, -rz, ry], [rz, 0, -rx], [-ry, rx, 0]])
-                rotation_matrix = np.identity(3) + 2 * np.dot(k, k)
-
-                target_coordinates = np.dot(target_coordinates, rotation_matrix.T)
-
-                eigen_vectors[[j, candidate]] = eigen_vectors[[candidate, j]]
-                srt[[j, candidate]] = srt[[candidate, j]]
-
-            final_coordinates = np.linalg.inv(eigen_vectors).dot(target_coordinates.T)
-            coordinates[i] = final_coordinates.T
-        i += 1
-
-
-def _coordinates_pca_heuristic(crds: list[NDArray[np.float64]]) -> None:
-    """
-    Transform the coordinate distribution by the magnitude of variance of the respective basis.
-
-    The heuristic approximation of the transformation by simply switching axes.
-
-    :param crds: The coordinates.
-    """
-    i = 0
-    for target_coords in crds:
-        if len(target_coords) > 1:
-            covariance_matrix = np.cov(target_coords.T)
-            eigen_values, _ = np.linalg.eig(covariance_matrix)
-            srt = np.argsort(eigen_values)[::-1]
-            for j in range(len(srt)):
-                if srt[j] == j:
-                    continue
-                candidate = srt[j]
-                target_coords[:, [j, candidate]] = target_coords[:, [candidate, j]]
-                srt[[j, candidate]] = srt[[candidate, j]]
-            crds[i] = target_coords
-        i += 1
+from itertools import product
+from typing import Any
+
+import numpy as np
+from numpy.typing import NDArray
+from pyrr import Vector3
+
+from revolve2.modular_robot.body import Module
+from revolve2.modular_robot.body.base import Body
+
+
+def coords_from_bodies(
+    bodies: list[Body], cob_heuristics: bool
+) -> list[NDArray[np.float64]]:
+    """
+    Extract coordinates of modules from a body.
+
+    :param bodies: The bodies.
+    :param cob_heuristics: If change of basis heuristic approximation is used.
+    :return: The array of coordinates.
+    """
+    crds = _body_to_adjusted_coordinates(bodies)
+    if cob_heuristics:
+        _coordinates_pca_heuristic(crds)
+    else:
+        _coordinates_pca_change_basis(crds)
+    return crds
+
+
+def _body_to_adjusted_coordinates(bodies: list[Body]) -> list[NDArray[np.float64]]:
+    """
+    Extract coordinates of modules in a body and adjusts them with the core position.
+
+    :param bodies: The body.
+    :return: The coordinates for each body.
+    """
+    crds = [np.empty(shape=0, dtype=np.float64)] * len(bodies)
+    i = 0
+    for body in bodies:
+        tpl: tuple[NDArray[Any], Vector3] = body.to_grid()
+        body_array, core_position = tpl
+        x, y, z = body_array.shape
+
+        elements = []
+        for xe, ye, ze in product(range(x), range(y), range(z)):
+            target = body_array[xe, ye, ze]
+            if isinstance(target, Module):
+                elements.append(np.subtract((xe, ye, ze), core_position))
+        crds[i] = np.asarray(elements)
+        i += 1
+    return crds
+
+
+def _coordinates_pca_change_basis(coordinates: list[NDArray[np.float64]]) -> None:
+    """
+    Transform the coordinate distribution by the magnitude of variance of the respective basis.
+
+    The detailed steps of the transformation are discussed in the paper.
+
+    :param coordinates: The coordinates.
+    """
+    i = 0
+    for target_coordinates in coordinates:
+        if len(target_coordinates) > 1:
+            covariance_matrix = np.cov(target_coordinates.T)
+            eigen_values, eigen_vectors = np.linalg.eig(covariance_matrix)
+
+            # sorting axis by amplitude of variance
+            srt = np.argsort(eigen_values)[::-1]
+            for j in range(len(srt)):
+                if srt[j] == j:
+                    continue
+                candidate = srt[j]
+
+                # here we start rotating using Rodrigues` rotation formula.
+                rx, ry, rz = eigen_vectors[candidate] / np.linalg.norm(
+                    eigen_vectors[candidate]
+                )
+                k = np.array([[0, -rz, ry], [rz, 0, -rx], [-ry, rx, 0]])
+                rotation_matrix = np.identity(3) + 2 * np.dot(k, k)
+
+                target_coordinates = np.dot(target_coordinates, rotation_matrix.T)
+
+                eigen_vectors[[j, candidate]] = eigen_vectors[[candidate, j]]
+                srt[[j, candidate]] = srt[[candidate, j]]
+
+            final_coordinates = np.linalg.inv(eigen_vectors).dot(target_coordinates.T)
+            coordinates[i] = final_coordinates.T
+        i += 1
+
+
+def _coordinates_pca_heuristic(crds: list[NDArray[np.float64]]) -> None:
+    """
+    Transform the coordinate distribution by the magnitude of variance of the respective basis.
+
+    The heuristic approximation of the transformation by simply switching axes.
+
+    :param crds: The coordinates.
+    """
+    i = 0
+    for target_coords in crds:
+        if len(target_coords) > 1:
+            covariance_matrix = np.cov(target_coords.T)
+            eigen_values, _ = np.linalg.eig(covariance_matrix)
+            srt = np.argsort(eigen_values)[::-1]
+            for j in range(len(srt)):
+                if srt[j] == j:
+                    continue
+                candidate = srt[j]
+                target_coords[:, [j, candidate]] = target_coords[:, [candidate, j]]
+                srt[[j, candidate]] = srt[[candidate, j]]
+            crds[i] = target_coords
+        i += 1
```

## revolve2/ci_group/morphological_novelty_metric/_morphological_novelty_metric.py

 * *Ordering differences only*

```diff
@@ -1,133 +1,133 @@
-from math import atan2, pi, sqrt
-
-import numpy as np
-from numpy.typing import NDArray
-
-from revolve2.modular_robot import ModularRobot
-
-from ._coordinate_operations import coords_from_bodies
-from .calculate_novelty import calculate_novelty
-
-_INT_CASTER: int = 10_000
-"""Casting floats to INT allows to mitigate floating-point issues in the distribution reshaping. The higher the number, the more presicion you get."""
-
-Orientations = list[list[tuple[float, float]]]
-Magnitudes = list[list[float]]
-
-
-def get_novelty_from_population(
-    population: list[ModularRobot], cob_heuristic: bool = False, num_bins: int = 20
-) -> NDArray[np.float64]:
-    """
-    Get the morphological novelty score for individuals in a population.
-
-    This metric for Morphological Novelty considers robots a distribution in space, which can be reshaped into any other distribution.
-    The work that has to be done to reshape distribution 1 to distribution 2 is used for the final novelty calculation.
-    A detailed description of the Algorithm can be found in:
-    Oliver Weissl, and A.E. Eiben. "Morphological-Novelty in Modular Robot Evolution". 2023 IEEE Symposium Series on Computational Intelligence (SSCI)(pp. 1066-1071). IEEE, 2023.
-
-    :param population: The population of robots.
-    :param cob_heuristic: Whether the heuristic approximation for change of basis is used.
-    :param num_bins: The amount of bins in the histogram. Increasing this allows for more detail, but risks sparseness, while lower values generalize more.
-    :return: The novelty scores.
-    """
-    bodies = [robot.body for robot in population]
-
-    coordinates = coords_from_bodies(bodies, cob_heuristics=cob_heuristic)
-
-    magn, orient = _coordinates_to_magnitudes_orientation(coordinates)
-    histograms = _gen_gradient_histogram(
-        orientations=orient, magnitudes=magn, num_bins=num_bins
-    )
-    int_histograms = _normalize_cast_int(histograms)
-
-    novelty_scores: NDArray[np.float64] = calculate_novelty(
-        int_histograms, int_histograms.shape[0], num_bins
-    )
-    return novelty_scores
-
-
-def _coordinates_to_magnitudes_orientation(
-    coordinates: list[NDArray[np.float64]],
-) -> tuple[Magnitudes, Orientations]:
-    """
-    Calculate the magnitude and orientation for the coordinates supplied.
-
-    :param coordinates: The coordinates for calculating the magnitudes and orientations.
-    :return: The magnitudes and orientations.
-    """
-    instances = len(coordinates)
-    magnitudes = [[0.0]] * instances
-    orientations = [[(0.0, 0.0)]] * instances
-    for i in range(instances):
-        coordinates_amount = coordinates[i].shape[0]
-        mags = [0.0] * coordinates_amount
-        orts = [(0.0, 0.0)] * coordinates_amount
-        for j in range(coordinates_amount):
-            coord = coordinates[i][j]
-            ax = atan2(sqrt(coord[1] ** 2 + coord[2] ** 2), coord[0]) * 180 / pi
-            az = atan2(coord[2], sqrt(coord[1] ** 2 + coord[0] ** 2)) * 180 / pi
-            orts[j] = (ax, az)
-            mags[j] = sqrt(coord.dot(coord))
-        orientations[i] = orts
-        magnitudes[i] = mags
-    return magnitudes, orientations
-
-
-def _gen_gradient_histogram(
-    orientations: Orientations,
-    magnitudes: Magnitudes,
-    num_bins: int,
-) -> NDArray[np.float64]:
-    """
-    Generate the gradient histograms for the respective histogram index.
-
-    :param orientations: The orientations of points in the bodies.
-    :param magnitudes: The magnitudes of points in the bodies.
-    :param num_bins: The number of bins in the histogram.
-    :return: The gradient histograms. Shape = (instances x num_bins x num_bins).
-    """
-    bin_size = 360 / num_bins
-    instances = len(orientations)
-    histograms = np.zeros(shape=(instances, num_bins, num_bins), dtype=np.float64)
-    for i in range(instances):
-        for orientation, magnitude in zip(orientations[i], magnitudes[i]):
-            x, z = int(orientation[0] / bin_size), int(orientation[1] / bin_size)
-            histograms[i, x, z] += magnitude
-    return histograms
-
-
-def _normalize_cast_int(histograms: NDArray[np.float64]) -> NDArray[np.int64]:
-    """
-    Normalize a matrix (array), making its sum  = _INT_CASTER.
-
-    :param histograms: The histograms to cast and normalize.
-    :return: The normalized and cast histograms.
-    """
-    int_histograms = np.zeros(histograms.shape, dtype=np.int64)
-
-    instances = histograms.shape[0]
-    for i in range(instances):
-        histogram = histograms[i].copy()
-
-        if histogram.sum() > 0.0:
-            histogram /= histogram.sum()
-        else:
-            # If a body only has a core, but no other modules the histogram will be empty.
-            histogram += 1 / histogram.size
-
-        histogram *= _INT_CASTER
-        # Casting the float histograms to int, in order to avoid floating point errors in the reshaping.
-        histogram = histogram.astype(np.int64)
-
-        # Due to the int-casting the histogram sums are marginally smaller than _INT_CASTER.
-        error = _INT_CASTER - histogram.sum()
-        mask = np.zeros(shape=histogram.size, dtype=np.int64)
-
-        # each histogram must sum up to _INT_CASTER. Therefore, a mask is applied.
-        mask[:error] += 1
-        np.random.seed(42)  # forces shuffles into reproducible patterns
-        np.random.shuffle(mask)  # shuffling the mask to minimize bias in the histogram
-        int_histograms[i] = histogram + np.reshape(mask, (-1, histogram.shape[0]))
-
-    return int_histograms
+from math import atan2, pi, sqrt
+
+import numpy as np
+from numpy.typing import NDArray
+
+from revolve2.modular_robot import ModularRobot
+
+from ._coordinate_operations import coords_from_bodies
+from .calculate_novelty import calculate_novelty
+
+_INT_CASTER: int = 10_000
+"""Casting floats to INT allows to mitigate floating-point issues in the distribution reshaping. The higher the number, the more presicion you get."""
+
+Orientations = list[list[tuple[float, float]]]
+Magnitudes = list[list[float]]
+
+
+def get_novelty_from_population(
+    population: list[ModularRobot], cob_heuristic: bool = False, num_bins: int = 20
+) -> NDArray[np.float64]:
+    """
+    Get the morphological novelty score for individuals in a population.
+
+    This metric for Morphological Novelty considers robots a distribution in space, which can be reshaped into any other distribution.
+    The work that has to be done to reshape distribution 1 to distribution 2 is used for the final novelty calculation.
+    A detailed description of the Algorithm can be found in:
+    Oliver Weissl, and A.E. Eiben. "Morphological-Novelty in Modular Robot Evolution". 2023 IEEE Symposium Series on Computational Intelligence (SSCI)(pp. 1066-1071). IEEE, 2023.
+
+    :param population: The population of robots.
+    :param cob_heuristic: Whether the heuristic approximation for change of basis is used.
+    :param num_bins: The amount of bins in the histogram. Increasing this allows for more detail, but risks sparseness, while lower values generalize more.
+    :return: The novelty scores.
+    """
+    bodies = [robot.body for robot in population]
+
+    coordinates = coords_from_bodies(bodies, cob_heuristics=cob_heuristic)
+
+    magn, orient = _coordinates_to_magnitudes_orientation(coordinates)
+    histograms = _gen_gradient_histogram(
+        orientations=orient, magnitudes=magn, num_bins=num_bins
+    )
+    int_histograms = _normalize_cast_int(histograms)
+
+    novelty_scores: NDArray[np.float64] = calculate_novelty(
+        int_histograms, int_histograms.shape[0], num_bins
+    )
+    return novelty_scores
+
+
+def _coordinates_to_magnitudes_orientation(
+    coordinates: list[NDArray[np.float64]],
+) -> tuple[Magnitudes, Orientations]:
+    """
+    Calculate the magnitude and orientation for the coordinates supplied.
+
+    :param coordinates: The coordinates for calculating the magnitudes and orientations.
+    :return: The magnitudes and orientations.
+    """
+    instances = len(coordinates)
+    magnitudes = [[0.0]] * instances
+    orientations = [[(0.0, 0.0)]] * instances
+    for i in range(instances):
+        coordinates_amount = coordinates[i].shape[0]
+        mags = [0.0] * coordinates_amount
+        orts = [(0.0, 0.0)] * coordinates_amount
+        for j in range(coordinates_amount):
+            coord = coordinates[i][j]
+            ax = atan2(sqrt(coord[1] ** 2 + coord[2] ** 2), coord[0]) * 180 / pi
+            az = atan2(coord[2], sqrt(coord[1] ** 2 + coord[0] ** 2)) * 180 / pi
+            orts[j] = (ax, az)
+            mags[j] = sqrt(coord.dot(coord))
+        orientations[i] = orts
+        magnitudes[i] = mags
+    return magnitudes, orientations
+
+
+def _gen_gradient_histogram(
+    orientations: Orientations,
+    magnitudes: Magnitudes,
+    num_bins: int,
+) -> NDArray[np.float64]:
+    """
+    Generate the gradient histograms for the respective histogram index.
+
+    :param orientations: The orientations of points in the bodies.
+    :param magnitudes: The magnitudes of points in the bodies.
+    :param num_bins: The number of bins in the histogram.
+    :return: The gradient histograms. Shape = (instances x num_bins x num_bins).
+    """
+    bin_size = 360 / num_bins
+    instances = len(orientations)
+    histograms = np.zeros(shape=(instances, num_bins, num_bins), dtype=np.float64)
+    for i in range(instances):
+        for orientation, magnitude in zip(orientations[i], magnitudes[i]):
+            x, z = int(orientation[0] / bin_size), int(orientation[1] / bin_size)
+            histograms[i, x, z] += magnitude
+    return histograms
+
+
+def _normalize_cast_int(histograms: NDArray[np.float64]) -> NDArray[np.int64]:
+    """
+    Normalize a matrix (array), making its sum  = _INT_CASTER.
+
+    :param histograms: The histograms to cast and normalize.
+    :return: The normalized and cast histograms.
+    """
+    int_histograms = np.zeros(histograms.shape, dtype=np.int64)
+
+    instances = histograms.shape[0]
+    for i in range(instances):
+        histogram = histograms[i].copy()
+
+        if histogram.sum() > 0.0:
+            histogram /= histogram.sum()
+        else:
+            # If a body only has a core, but no other modules the histogram will be empty.
+            histogram += 1 / histogram.size
+
+        histogram *= _INT_CASTER
+        # Casting the float histograms to int, in order to avoid floating point errors in the reshaping.
+        histogram = histogram.astype(np.int64)
+
+        # Due to the int-casting the histogram sums are marginally smaller than _INT_CASTER.
+        error = _INT_CASTER - histogram.sum()
+        mask = np.zeros(shape=histogram.size, dtype=np.int64)
+
+        # each histogram must sum up to _INT_CASTER. Therefore, a mask is applied.
+        mask[:error] += 1
+        np.random.seed(42)  # forces shuffles into reproducible patterns
+        np.random.shuffle(mask)  # shuffling the mask to minimize bias in the histogram
+        int_histograms[i] = histogram + np.reshape(mask, (-1, histogram.shape[0]))
+
+    return int_histograms
```

## revolve2/ci_group/morphological_novelty_metric/calculate_novelty.pyi

 * *Ordering differences only*

```diff
@@ -1,8 +1,8 @@
-import numpy as np
-from numpy.typing import NDArray
-
-"""Allow mypy and sphinx to resolve the compiled cython module."""
-
-def calculate_novelty(
-    histograms: NDArray[np.int64], amount_instances: int, histogram_size: int
-) -> NDArray[np.float64]: ...
+import numpy as np
+from numpy.typing import NDArray
+
+"""Allow mypy and sphinx to resolve the compiled cython module."""
+
+def calculate_novelty(
+    histograms: NDArray[np.int64], amount_instances: int, histogram_size: int
+) -> NDArray[np.float64]: ...
```

## revolve2/ci_group/planar_robot_representation.py

```diff
@@ -1,191 +1,192 @@
-"""Draw 2D representations of Modular Robots. Based on Karine Miras` Method."""
-import os
-import time
-from typing import Any
-
-import cairo
-import numpy as np
-from numpy.typing import NDArray
-from pyrr import Vector3
-
-from revolve2.modular_robot import ModularRobot
-from revolve2.modular_robot.body import Module
-from revolve2.modular_robot.body.base import ActiveHinge, Body, Brick, Core
-
-
-def __mk_path() -> str:
-    path = f"planar_robot_representations_{time.time()}"
-    print(f"Saving images to: {path}")
-    if not os.path.exists(path):
-        os.mkdir(path)
-    return path
-
-
-def draw_robots(
-    robots: list[ModularRobot] | list[Body], scale: int = 100, path: str | None = None
-) -> None:
-    """
-    Draw multiple robots at once.
-
-    How to use:
-     >>> robots: list[revolve2.modular_robot.ModularRobot] | list[revolve2.modular_robot.body.base.Body]
-     >>> draw_robots(robots, path="<your desired path to save the image to>")
-
-    :param robots: The robots.
-    :param scale: The scale for the robots to be drawn.
-    :param path: The path for the output files.
-    """
-    if not path:
-        path = __mk_path()
-
-    for robot in robots:
-        draw_robot(robot, scale, path)
-
-
-def draw_robot(
-    robot: ModularRobot | Body, scale: int = 100, path: str | None = None
-) -> None:
-    """
-    Draw a 2D representation for a modular robots body.
-
-    How to use:
-     >>> robot: revolve2.modular_robot.ModularRobot | revolve2.modular_robot.body.base.Body
-     >>> draw_robot(robot, path="<your desired path to save the image to>")
-
-    :param robot: Supply the robot as a ModularRobot object, or the body directly as a Body object.
-    :param scale: Allows to set the size of the drawing.
-    :param path: The path to save images to.
-    """
-    if not path:
-        path = __mk_path()
-
-    body = robot if isinstance(robot, Body) else robot.body
-    tpl: tuple[NDArray[Any], Vector3[np.int_]] = body.to_grid()
-    body_grid, core_position = tpl
-    x, y, _ = body_grid.shape
-
-    image = cairo.ImageSurface(cairo.FORMAT_ARGB32, x * scale, y * scale)
-    context = cairo.Context(image)
-    context.scale(scale, scale)
-
-    cx, cy, _ = tuple(core_position)
-    _draw_module(
-        module=body.core,
-        position=(cx, cy),
-        previous_position=(cx, cy),
-        orientation=_make_rot_mat(0),
-        context=context,
-    )
-    _save_png(image, path)
-
-
-def _draw_module(
-    module: Module,
-    position: tuple[int, int],
-    previous_position: tuple[int, int],
-    orientation: NDArray[np.int_],
-    context: "cairo.Context[cairo.ImageSurface]",
-    print_id: bool = False,
-) -> None:
-    """
-    Draw a module onto the canvas.
-
-    :param module: The module.
-    :param position: The position on the canvas.
-    :param previous_position: The position of the previous module.
-    :param orientation: The orientation to draw in.
-    :param context: The context to draw it on.
-    :param print_id: If the modules id should be drawn as well.
-    :raises Exception: If the module cant be drawn.
-    """
-    x, y = position
-    context.rectangle(x, y, 1, 1)  # draw module object
-
-    match module:
-        case Core():
-            context.set_source_rgb(255, 255, 0)  # Yellow
-        case ActiveHinge():
-            context.set_source_rgb(1, 0, 0)  # Red
-            if module.rotation == 0:
-                context.set_source_rgb(1.0, 0.4, 0.4)  # Flesh Color
-        case Brick():
-            context.set_source_rgb(0, 0, 1)  # Blue
-        case _:
-            raise Exception(
-                f"Module of type {type(module)} has no defined structure for drawing."
-            )
-
-    # default operation for every module
-    context.fill_preserve()
-    context.set_line_width(0.01)
-    context.stroke()
-    context.set_source_rgb(0, 0, 0)
-
-    if module.parent is not None:
-        # draw the connection to the parent module
-        x_offset, y_offset = (
-            previous_position[0] - position[0],
-            previous_position[1] - position[1],
-        )
-
-        circ_x = (
-            x + 0.5
-            if x_offset == 0
-            else x + (x_offset if x_offset > 0 else abs(x_offset) - 1)
-        )
-        circ_y = (
-            y + 0.5
-            if y_offset == 0
-            else y + (y_offset if y_offset > 0 else abs(y_offset) - 1)
-        )
-
-        context.arc(circ_x, circ_y, 0.1, 0, np.pi * 2)
-        context.fill_preserve()
-        context.stroke()
-
-    if print_id:
-        # print module id onto canvas
-        context.set_font_size(0.3)
-        context.move_to(x, y + 0.4)
-        context.show_text(str(module.uuid))
-        context.stroke()
-
-    for key, child in module.children.items():
-        angle = module.attachment_points[key].orientation.angle
-        mapo = _make_rot_mat(angle)
-        target_orientation = orientation @ mapo
-
-        x, y = target_orientation.dot(np.array([1, 0]))
-
-        new_pos = position[0] + x, position[1] + y
-        _draw_module(
-            module=child,
-            position=new_pos,
-            previous_position=position,
-            context=context,
-            orientation=target_orientation,
-        )
-
-
-def _make_rot_mat(theta: float) -> NDArray[np.int_]:
-    """
-    Make a rotation matrix from angle in 2D.
-
-    This function casts angles to iterations of 90, since we plot on a grid.
-
-    :param theta: The angle.
-    :return: The matrix.
-    """
-    c, s = int(round(np.cos(theta))), int(round(np.sin(theta)))
-    rotation = np.array(((c, -s), (s, c)))
-    return rotation
-
-
-def _save_png(image: cairo.ImageSurface, path: str) -> None:
-    """
-    Save the image representation of a robot as png.
-
-    :param image: The image.
-    :param path: The path to save the image to.
-    """
-    image.write_to_png(f"{path}/robot_2d_{str(hash(image))}.png")
+"""Draw 2D representations of Modular Robots. Based on Karine Miras` Method."""
+
+import os
+import time
+from typing import Any
+
+import cairo
+import numpy as np
+from numpy.typing import NDArray
+from pyrr import Vector3
+
+from revolve2.modular_robot import ModularRobot
+from revolve2.modular_robot.body import Module
+from revolve2.modular_robot.body.base import ActiveHinge, Body, Brick, Core
+
+
+def __mk_path() -> str:
+    path = f"planar_robot_representations_{time.time()}"
+    print(f"Saving images to: {path}")
+    if not os.path.exists(path):
+        os.mkdir(path)
+    return path
+
+
+def draw_robots(
+    robots: list[ModularRobot] | list[Body], scale: int = 100, path: str | None = None
+) -> None:
+    """
+    Draw multiple robots at once.
+
+    How to use:
+     >>> robots: list[revolve2.modular_robot.ModularRobot] | list[revolve2.modular_robot.body.base.Body]
+     >>> draw_robots(robots, path="<your desired path to save the image to>")
+
+    :param robots: The robots.
+    :param scale: The scale for the robots to be drawn.
+    :param path: The path for the output files.
+    """
+    if not path:
+        path = __mk_path()
+
+    for robot in robots:
+        draw_robot(robot, scale, path)
+
+
+def draw_robot(
+    robot: ModularRobot | Body, scale: int = 100, path: str | None = None
+) -> None:
+    """
+    Draw a 2D representation for a modular robots body.
+
+    How to use:
+     >>> robot: revolve2.modular_robot.ModularRobot | revolve2.modular_robot.body.base.Body
+     >>> draw_robot(robot, path="<your desired path to save the image to>")
+
+    :param robot: Supply the robot as a ModularRobot object, or the body directly as a Body object.
+    :param scale: Allows to set the size of the drawing.
+    :param path: The path to save images to.
+    """
+    if not path:
+        path = __mk_path()
+
+    body = robot if isinstance(robot, Body) else robot.body
+    tpl: tuple[NDArray[Any], Vector3[np.int_]] = body.to_grid()
+    body_grid, core_position = tpl
+    x, y, _ = body_grid.shape
+
+    image = cairo.ImageSurface(cairo.FORMAT_ARGB32, x * scale, y * scale)
+    context = cairo.Context(image)
+    context.scale(scale, scale)
+
+    cx, cy, _ = tuple(core_position)
+    _draw_module(
+        module=body.core,
+        position=(cx, cy),
+        previous_position=(cx, cy),
+        orientation=_make_rot_mat(0),
+        context=context,
+    )
+    _save_png(image, path)
+
+
+def _draw_module(
+    module: Module,
+    position: tuple[int, int],
+    previous_position: tuple[int, int],
+    orientation: NDArray[np.int_],
+    context: "cairo.Context[cairo.ImageSurface]",
+    print_id: bool = False,
+) -> None:
+    """
+    Draw a module onto the canvas.
+
+    :param module: The module.
+    :param position: The position on the canvas.
+    :param previous_position: The position of the previous module.
+    :param orientation: The orientation to draw in.
+    :param context: The context to draw it on.
+    :param print_id: If the modules id should be drawn as well.
+    :raises Exception: If the module cant be drawn.
+    """
+    x, y = position
+    context.rectangle(x, y, 1, 1)  # draw module object
+
+    match module:
+        case Core():
+            context.set_source_rgb(255, 255, 0)  # Yellow
+        case ActiveHinge():
+            context.set_source_rgb(1, 0, 0)  # Red
+            if module.rotation == 0:
+                context.set_source_rgb(1.0, 0.4, 0.4)  # Flesh Color
+        case Brick():
+            context.set_source_rgb(0, 0, 1)  # Blue
+        case _:
+            raise Exception(
+                f"Module of type {type(module)} has no defined structure for drawing."
+            )
+
+    # default operation for every module
+    context.fill_preserve()
+    context.set_line_width(0.01)
+    context.stroke()
+    context.set_source_rgb(0, 0, 0)
+
+    if module.parent is not None:
+        # draw the connection to the parent module
+        x_offset, y_offset = (
+            previous_position[0] - position[0],
+            previous_position[1] - position[1],
+        )
+
+        circ_x = (
+            x + 0.5
+            if x_offset == 0
+            else x + (x_offset if x_offset > 0 else abs(x_offset) - 1)
+        )
+        circ_y = (
+            y + 0.5
+            if y_offset == 0
+            else y + (y_offset if y_offset > 0 else abs(y_offset) - 1)
+        )
+
+        context.arc(circ_x, circ_y, 0.1, 0, np.pi * 2)
+        context.fill_preserve()
+        context.stroke()
+
+    if print_id:
+        # print module id onto canvas
+        context.set_font_size(0.3)
+        context.move_to(x, y + 0.4)
+        context.show_text(str(module.uuid))
+        context.stroke()
+
+    for key, child in module.children.items():
+        angle = module.attachment_points[key].orientation.angle
+        mapo = _make_rot_mat(angle)
+        target_orientation = orientation @ mapo
+
+        x, y = target_orientation.dot(np.array([1, 0]))
+
+        new_pos = position[0] + x, position[1] + y
+        _draw_module(
+            module=child,
+            position=new_pos,
+            previous_position=position,
+            context=context,
+            orientation=target_orientation,
+        )
+
+
+def _make_rot_mat(theta: float) -> NDArray[np.int_]:
+    """
+    Make a rotation matrix from angle in 2D.
+
+    This function casts angles to iterations of 90, since we plot on a grid.
+
+    :param theta: The angle.
+    :return: The matrix.
+    """
+    c, s = int(round(np.cos(theta))), int(round(np.sin(theta)))
+    rotation = np.array(((c, -s), (s, c)))
+    return rotation
+
+
+def _save_png(image: cairo.ImageSurface, path: str) -> None:
+    """
+    Save the image representation of a robot as png.
+
+    :param image: The image.
+    :param path: The path to save the image to.
+    """
+    image.write_to_png(f"{path}/robot_2d_{str(hash(image))}.png")
```

## revolve2/ci_group/simulation_parameters.py

```diff
@@ -1,30 +1,31 @@
-"""Standard simulation functions and parameters."""
-from revolve2.simulation.simulator import BatchParameters
-
-STANDARD_SIMULATION_TIME = 30
-STANDARD_SAMPLING_FREQUENCY = 5
-STANDARD_SIMULATION_TIMESTEP = 0.001
-STANDARD_CONTROL_FREQUENCY = 20
-
-
-def make_standard_batch_parameters(
-    simulation_time: int = STANDARD_SIMULATION_TIME,
-    sampling_frequency: float | None = STANDARD_SAMPLING_FREQUENCY,
-    simulation_timestep: float = STANDARD_SIMULATION_TIMESTEP,
-    control_frequency: float = STANDARD_CONTROL_FREQUENCY,
-) -> BatchParameters:
-    """
-    Create batch parameters as standardized within the CI Group.
-
-    :param simulation_time: As defined in the `BatchParameters` class.
-    :param sampling_frequency: As defined in the `BatchParameters` class.
-    :param simulation_timestep: As defined in the `BatchParameters` class.
-    :param control_frequency: As defined in the `BatchParameters` class.
-    :returns: The create batch parameters.
-    """
-    return BatchParameters(
-        simulation_time=simulation_time,
-        sampling_frequency=sampling_frequency,
-        simulation_timestep=simulation_timestep,
-        control_frequency=control_frequency,
-    )
+"""Standard simulation functions and parameters."""
+
+from revolve2.simulation.simulator import BatchParameters
+
+STANDARD_SIMULATION_TIME = 30
+STANDARD_SAMPLING_FREQUENCY = 5
+STANDARD_SIMULATION_TIMESTEP = 0.001
+STANDARD_CONTROL_FREQUENCY = 20
+
+
+def make_standard_batch_parameters(
+    simulation_time: int = STANDARD_SIMULATION_TIME,
+    sampling_frequency: float | None = STANDARD_SAMPLING_FREQUENCY,
+    simulation_timestep: float = STANDARD_SIMULATION_TIMESTEP,
+    control_frequency: float = STANDARD_CONTROL_FREQUENCY,
+) -> BatchParameters:
+    """
+    Create batch parameters as standardized within the CI Group.
+
+    :param simulation_time: As defined in the `BatchParameters` class.
+    :param sampling_frequency: As defined in the `BatchParameters` class.
+    :param simulation_timestep: As defined in the `BatchParameters` class.
+    :param control_frequency: As defined in the `BatchParameters` class.
+    :returns: The create batch parameters.
+    """
+    return BatchParameters(
+        simulation_time=simulation_time,
+        sampling_frequency=sampling_frequency,
+        simulation_timestep=simulation_timestep,
+        control_frequency=control_frequency,
+    )
```

## revolve2/ci_group/terrains.py

```diff
@@ -1,159 +1,161 @@
-"""Standard terrains."""
-
-import math
-
-import numpy as np
-import numpy.typing as npt
-from noise import pnoise2
-from pyrr import Vector3
-
-from revolve2.modular_robot_simulation import Terrain
-from revolve2.simulation.scene import Pose
-from revolve2.simulation.scene.geometry import GeometryHeightmap, GeometryPlane
-from revolve2.simulation.scene.vector2 import Vector2
-
-
-def flat(size: Vector2 = Vector2([20.0, 20.0])) -> Terrain:
-    """
-    Create a flat plane terrain.
-
-    :param size: Size of the plane.
-    :returns: The created terrain.
-    """
-    return Terrain(
-        static_geometry=[
-            GeometryPlane(
-                pose=Pose(),
-                mass=0.0,
-                size=size,
-            )
-        ]
-    )
-
-
-def crater(
-    size: tuple[float, float],
-    ruggedness: float,
-    curviness: float,
-    granularity_multiplier: float = 1.0,
-) -> Terrain:
-    r"""
-    Create a crater-like terrain with rugged floor using a heightmap.
-
-    It will look like::
-
-        |            |
-         \_        .'
-           '.,^_..'
-
-    A combination of the rugged and bowl heightmaps.
-
-    :param size: Size of the crater.
-    :param ruggedness: How coarse the ground is.
-    :param curviness: Height of the edges of the crater.
-    :param granularity_multiplier: Multiplier for how many edges are used in the heightmap.
-    :returns: The created terrain.
-    """
-    NUM_EDGES = 100  # arbitrary constant to get a nice number of edges
-
-    num_edges = (
-        int(NUM_EDGES * size[0] * granularity_multiplier),
-        int(NUM_EDGES * size[1] * granularity_multiplier),
-    )
-
-    rugged = rugged_heightmap(
-        size=size,
-        num_edges=num_edges,
-        density=1.5,
-    )
-    bowl = bowl_heightmap(num_edges=num_edges)
-
-    max_height = ruggedness + curviness
-    if max_height == 0.0:
-        heightmap = np.zeros(num_edges)
-        max_height = 1.0
-    else:
-        heightmap = (ruggedness * rugged + curviness * bowl) / (ruggedness + curviness)
-
-    return Terrain(
-        static_geometry=[
-            GeometryHeightmap(
-                pose=Pose(),
-                mass=0.0,
-                size=Vector3([size[0], size[1], max_height]),
-                base_thickness=0.1 + ruggedness,
-                heights=heightmap,
-            )
-        ]
-    )
-
-
-def rugged_heightmap(
-    size: tuple[float, float],
-    num_edges: tuple[int, int],
-    density: float = 1.0,
-) -> npt.NDArray[np.float_]:
-    """
-    Create a rugged terrain heightmap.
-
-    It will look like::
-
-        ..^.__,^._.-.
-
-    Be aware: the maximum height of the heightmap is not actually 1.
-    It is around [-1,1] but not exactly.
-
-    :param size: Size of the heightmap.
-    :param num_edges: How many edges to use for the heightmap.
-    :param density: How coarse the ruggedness is.
-    :returns: The created heightmap as a 2 dimensional array.
-    """
-    OCTAVE = 10
-    C1 = 4.0  # arbitrary constant to get nice noise
-
-    return np.fromfunction(
-        np.vectorize(
-            lambda y, x: pnoise2(
-                x / num_edges[0] * C1 * size[0] * density,
-                y / num_edges[1] * C1 * size[1] * density,
-                OCTAVE,
-            ),
-            otypes=[float],
-        ),
-        num_edges,
-        dtype=float,
-    )
-
-
-def bowl_heightmap(
-    num_edges: tuple[int, int],
-) -> npt.NDArray[np.float_]:
-    r"""
-    Create a terrain heightmap in the shape of a bowl.
-
-    It will look like::
-
-        |         |
-         \       /
-          '.___.'
-
-    The height of the edges of the bowl is 1.0 and the center is 0.0.
-
-    :param num_edges: How many edges to use for the heightmap.
-    :returns: The created heightmap as a 2 dimensional array.
-    """
-    return np.fromfunction(
-        np.vectorize(
-            lambda y, x: (x / num_edges[0] * 2.0 - 1.0) ** 2
-            + (y / num_edges[1] * 2.0 - 1.0) ** 2
-            if math.sqrt(
-                (x / num_edges[0] * 2.0 - 1.0) ** 2
-                + (y / num_edges[1] * 2.0 - 1.0) ** 2
-            )
-            <= 1.0
-            else 0.0,
-            otypes=[float],
-        ),
-        num_edges,
-        dtype=float,
-    )
+"""Standard terrains."""
+
+import math
+
+import numpy as np
+import numpy.typing as npt
+from noise import pnoise2
+from pyrr import Vector3
+
+from revolve2.modular_robot_simulation import Terrain
+from revolve2.simulation.scene import Pose
+from revolve2.simulation.scene.geometry import GeometryHeightmap, GeometryPlane
+from revolve2.simulation.scene.vector2 import Vector2
+
+
+def flat(size: Vector2 = Vector2([20.0, 20.0])) -> Terrain:
+    """
+    Create a flat plane terrain.
+
+    :param size: Size of the plane.
+    :returns: The created terrain.
+    """
+    return Terrain(
+        static_geometry=[
+            GeometryPlane(
+                pose=Pose(),
+                mass=0.0,
+                size=size,
+            )
+        ]
+    )
+
+
+def crater(
+    size: tuple[float, float],
+    ruggedness: float,
+    curviness: float,
+    granularity_multiplier: float = 1.0,
+) -> Terrain:
+    r"""
+    Create a crater-like terrain with rugged floor using a heightmap.
+
+    It will look like::
+
+        |            |
+         \_        .'
+           '.,^_..'
+
+    A combination of the rugged and bowl heightmaps.
+
+    :param size: Size of the crater.
+    :param ruggedness: How coarse the ground is.
+    :param curviness: Height of the edges of the crater.
+    :param granularity_multiplier: Multiplier for how many edges are used in the heightmap.
+    :returns: The created terrain.
+    """
+    NUM_EDGES = 100  # arbitrary constant to get a nice number of edges
+
+    num_edges = (
+        int(NUM_EDGES * size[0] * granularity_multiplier),
+        int(NUM_EDGES * size[1] * granularity_multiplier),
+    )
+
+    rugged = rugged_heightmap(
+        size=size,
+        num_edges=num_edges,
+        density=1.5,
+    )
+    bowl = bowl_heightmap(num_edges=num_edges)
+
+    max_height = ruggedness + curviness
+    if max_height == 0.0:
+        heightmap = np.zeros(num_edges)
+        max_height = 1.0
+    else:
+        heightmap = (ruggedness * rugged + curviness * bowl) / (ruggedness + curviness)
+
+    return Terrain(
+        static_geometry=[
+            GeometryHeightmap(
+                pose=Pose(),
+                mass=0.0,
+                size=Vector3([size[0], size[1], max_height]),
+                base_thickness=0.1 + ruggedness,
+                heights=heightmap,
+            )
+        ]
+    )
+
+
+def rugged_heightmap(
+    size: tuple[float, float],
+    num_edges: tuple[int, int],
+    density: float = 1.0,
+) -> npt.NDArray[np.float_]:
+    """
+    Create a rugged terrain heightmap.
+
+    It will look like::
+
+        ..^.__,^._.-.
+
+    Be aware: the maximum height of the heightmap is not actually 1.
+    It is around [-1,1] but not exactly.
+
+    :param size: Size of the heightmap.
+    :param num_edges: How many edges to use for the heightmap.
+    :param density: How coarse the ruggedness is.
+    :returns: The created heightmap as a 2 dimensional array.
+    """
+    OCTAVE = 10
+    C1 = 4.0  # arbitrary constant to get nice noise
+
+    return np.fromfunction(
+        np.vectorize(
+            lambda y, x: pnoise2(
+                x / num_edges[0] * C1 * size[0] * density,
+                y / num_edges[1] * C1 * size[1] * density,
+                OCTAVE,
+            ),
+            otypes=[float],
+        ),
+        num_edges,
+        dtype=float,
+    )
+
+
+def bowl_heightmap(
+    num_edges: tuple[int, int],
+) -> npt.NDArray[np.float_]:
+    r"""
+    Create a terrain heightmap in the shape of a bowl.
+
+    It will look like::
+
+        |         |
+         \       /
+          '.___.'
+
+    The height of the edges of the bowl is 1.0 and the center is 0.0.
+
+    :param num_edges: How many edges to use for the heightmap.
+    :returns: The created heightmap as a 2 dimensional array.
+    """
+    return np.fromfunction(
+        np.vectorize(
+            lambda y, x: (
+                (x / num_edges[0] * 2.0 - 1.0) ** 2
+                + (y / num_edges[1] * 2.0 - 1.0) ** 2
+                if math.sqrt(
+                    (x / num_edges[0] * 2.0 - 1.0) ** 2
+                    + (y / num_edges[1] * 2.0 - 1.0) ** 2
+                )
+                <= 1.0
+                else 0.0
+            ),
+            otypes=[float],
+        ),
+        num_edges,
+        dtype=float,
+    )
```

## Comparing `revolve2_ci_group-1.0.2.dist-info/METADATA` & `revolve2_ci_group-1.1.1.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,16 +1,16 @@
 Metadata-Version: 2.1
 Name: revolve2-ci-group
-Version: 1.0.2
+Version: 1.1.1
 Summary: Revolve2: Computational Intelligence Group experimentation tools and standards.
 Home-page: https://github.com/ci-group/revolve2
 Author: Aart Stuurman
 Author-email: aartstuurman@hotmail.com
 Requires-Python: >=3.10,<3.12
-Classifier: Development Status :: 4 - Beta
+Classifier: Development Status :: 5 - Production/Stable
 Classifier: Intended Audience :: Science/Research
 Classifier: License :: OSI Approved :: GNU Lesser General Public License v3 (LGPLv3)
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Topic :: Scientific/Engineering
@@ -18,21 +18,21 @@
 Provides-Extra: dev
 Requires-Dist: Cython (>=3.0.4,<4.0.0)
 Requires-Dist: multineat (>=0.12,<0.13)
 Requires-Dist: noise (>=1.2.2,<2.0.0)
 Requires-Dist: numpy (>=1.21.2,<2.0.0)
 Requires-Dist: opencv-contrib-python (>=4.9.0.80,<5.0.0.0)
 Requires-Dist: opencv-python (>=4.9.0.80,<5.0.0.0)
-Requires-Dist: revolve2-modular-robot-simulation (==1.0.2)
+Requires-Dist: revolve2-modular-robot-simulation (==1.1.1)
 Requires-Dist: setuptools (>=68.2.2,<69.0.0)
 Requires-Dist: sqlalchemy (>=2.0.0,<3.0.0)
 Project-URL: Repository, https://github.com/ci-group/revolve2
 Description-Content-Type: text/markdown
 
-<img  align="right" width="150" height="150"  src="./docs/source/logo.png">
+<img align="right" width="150" height="150"  src="./docs/source/logo_light.png">
 
 # Revolve2
 
 Revolve2 is a collection of Python packages used for researching evolutionary algorithms and modular robotics.
 Its primary features are a modular robot framework, an abstraction layer around physics simulators, and evolutionary algorithms.
 
 **Documentation: [ci-group.github.io/revolve2](https://ci-group.github.io/revolve2)**
```

## Comparing `revolve2_ci_group-1.0.2.dist-info/RECORD` & `revolve2_ci_group-1.1.1.dist-info/RECORD`

 * *Files 14% similar despite different names*

```diff
@@ -1,41 +1,42 @@
-revolve2/ci_group/__init__.py,sha256=30qlB3Tjiaf3MYpgTpqi1p0HykRYG5taWb2175_ZDEs,97
-revolve2/ci_group/ci_lab_utilities/__init__.py,sha256=tBWgYwiWvb5Gui8FZTSxPKVONB_8jgltT7-W0bF6mUE,176
-revolve2/ci_group/ci_lab_utilities/_calibrate_camera.py,sha256=i4csRBvSyRCdM-r2WQldBvZ5du8dW_w-t3dvlwECIJw,3237
-revolve2/ci_group/ci_lab_utilities/_ip_camera.py,sha256=2JEEH8zd0ZXw0IRWK9VO9rCOutiDYXEkdhdL2amzdVY,6393
-revolve2/ci_group/fitness_functions.py,sha256=wBgWAl6QlF9RBDZlR6GgguFA8xLEdYoZIAwtf4s2c28,744
-revolve2/ci_group/genotypes/__init__.py,sha256=aVcIFE8sZbTwfRvgQCSRCtpRkpJfJt_wmyXhQOZvXSo,46
-revolve2/ci_group/genotypes/cppnwin/__init__.py,sha256=0yvxhw0PRWkjjgJFzsdfvuWiFeO4Az7f9efZ4mo0B2U,106
-revolve2/ci_group/genotypes/cppnwin/_multineat_genotype_pickle_wrapper.py,sha256=EGvlvEGQCNQGpwE7GVCO4X2oQoKhdM-p4pT0TFlbTJQ,838
-revolve2/ci_group/genotypes/cppnwin/_multineat_rng_from_random.py,sha256=A12Luqgz_eVlNwHV28baiS3bC9vy1V-D351622-brZk,373
-revolve2/ci_group/genotypes/cppnwin/_random_multineat_genotype.py,sha256=De75aTKWH3XBIXESX7wB-lREuD_rYI0U4z96tRVXk8Y,1687
-revolve2/ci_group/genotypes/cppnwin/modular_robot/__init__.py,sha256=smpt7yuq9-4xoS2YxA-lv5sgoGkf1xDKXu2th8O5JGI,332
-revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_cpg_network_neighbor_v1.py,sha256=gjDZVt1lpjGOTfYIaiP7Xrl43Skc8u6RnwALgyrksRU,2755
-revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg.py,sha256=COO437hQbEXKZrvwnnt5oITABU-w-31N2EDyfdKhxmI,3865
-revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg_orm.py,sha256=vSY0InkRsbMi6wb3cPiKQrV-yjmUS0ETihToAVRajbA,4343
-revolve2/ci_group/genotypes/cppnwin/modular_robot/_multineat_params.py,sha256=zDhLAmth7WR3R5bOJOm7Gdl4-6vfjLE3uasd-9yjK5o,1878
-revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/__init__.py,sha256=e_P8tN05rbeHAfO5TvE07nheifmoh_eYqNTpygJaf84,197
-revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_develop.py,sha256=xOW4evPU8EwIjC52sfY0Zz96WRRrhnjXjrfM_-5o58Q,4885
-revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_orm_v1.py,sha256=BsofHRRV7uIe_9jdlJA7e58Wk1WLhRFmOmekpxqbfeY,4185
-revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_v1.py,sha256=-RU37M7AoibufYFUdMAYEx0gJvmB6vyZp3wk7TO_xA8,3701
-revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/__init__.py,sha256=Qrpxrl-gG8vFej3s_K1g_Pdfnipl-IG84YZdL_hrMtA,197
-revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_develop.py,sha256=q6a9Uapghpo8JwY4HGqv95nG0GMnYceTanxoFVUvzsw,5209
-revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_orm_v2.py,sha256=cLM19D9Qc8GBzo-vNWXypHE70TJS7yXMfoU7OdxvLq0,4185
-revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_v2.py,sha256=8JOzcJTQe1EBwCovcT2FMy86ZIQE1NCzA_P4qEVhCyA,3701
-revolve2/ci_group/modular_robots_v1.py,sha256=rSir9PwRJiFYmmp3iHLy5CwXC466H-gkereksqI4cdY,29664
-revolve2/ci_group/modular_robots_v2.py,sha256=iIqtsAPt3WJOTpKnbm9k6x7kkrOAG2OI2IMj3srNwzY,1795
-revolve2/ci_group/morphological_measures.py,sha256=OKX8637co-Spjyyx8CT-0SDsksVOgyGUpx6MyvhHH7k,20093
-revolve2/ci_group/morphological_novelty_metric/__init__.py,sha256=wH9xNuhJRffKHxNOZ2mb98pCs9Bf35idMR44RvtYlXk,413
-revolve2/ci_group/morphological_novelty_metric/_build_cmodule.py,sha256=So3KS57M7rp13YoelmwAk_k3Imw7ZoXEY_jvt4ey54U,1515
-revolve2/ci_group/morphological_novelty_metric/_calculate_novelty.pyx,sha256=MDYAOiJtLQufJAdsFTq4mm7I13DtcZT-zv5z-8RTJnw,2996
-revolve2/ci_group/morphological_novelty_metric/_coordinate_operations.py,sha256=LSBvjzhMV5L32TaEAv71uWdN7nKxNj9v7CQMRy2_xVQ,4032
-revolve2/ci_group/morphological_novelty_metric/_morphological_novelty_metric.py,sha256=f1gY5fRt22z4wySXqZCDsq4MBfcIWC5LLDLVcE_U_q4,5601
-revolve2/ci_group/morphological_novelty_metric/calculate_novelty.cp310-win_amd64.pyd,sha256=Qzs8-d0aNpgh4K1xFTFx7vd28j50Avip1FePlwn0ACs,167424
-revolve2/ci_group/morphological_novelty_metric/calculate_novelty.cp311-win_amd64.pyd,sha256=ktnv7-FSL0sp6-iZSAhZXojOLL8hz9_IGbycDkFnZwM,163840
-revolve2/ci_group/morphological_novelty_metric/calculate_novelty.pyi,sha256=-2jzOzOhfoP_IgFhQ59_xWN6wIzT2H8nWA0AxY5YQoY,260
-revolve2/ci_group/planar_robot_representation.py,sha256=ltkYiXUW5Xks45GAQdxpU3cVDtRT_kBKJqk9jpxXnHw,5944
-revolve2/ci_group/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-revolve2/ci_group/simulation_parameters.py,sha256=pXI512mWjRc5VRLBodVCzXLfoah1rxQlkEpZCjLWML8,1209
-revolve2/ci_group/terrains.py,sha256=juiZWLnWKDxgL8e5VzB0OHw3vQ5uGTLoZlhwjuBWzOU,4287
-revolve2_ci_group-1.0.2.dist-info/METADATA,sha256=TdK7BkuAycTzxcUNBNCDFH965NbjWdcjHNX1hIBymUM,3486
-revolve2_ci_group-1.0.2.dist-info/WHEEL,sha256=-FZBVKyKauScY3vLa8vJR6hBCpAJfFykw2MOwlNKr1g,98
-revolve2_ci_group-1.0.2.dist-info/RECORD,,
+revolve2_ci_group-1.1.1.dist-info/METADATA,sha256=D2aItVpjq-l1tPj9gv0ILjCu64TXUxjPZs_LVQ1loQ0,3504
+revolve2_ci_group-1.1.1.dist-info/WHEEL,sha256=Cm_iXQVvG9gZu9yBSXSme-F8PbsPx--sQzakwRLuE1o,149
+revolve2_ci_group-1.1.1.dist-info/RECORD,,
+revolve2/ci_group/modular_robots_v1.py,sha256=bgnhLYJ_kjPkiQBiaCy9NebEjLDfULAIUT0VfxW5csk,28859
+revolve2/ci_group/morphological_measures.py,sha256=TI0jlIGBXOUD6wqZ2urOKO3uBF7gCIWmg6LAnDqoPoM,19483
+revolve2/ci_group/fitness_functions.py,sha256=ADAmjeyaNN0cQHeh3Ijll8p94uy4Wlg01sYF8YY11CE,721
+revolve2/ci_group/__init__.py,sha256=CAjxUe86OxtqLidhzA43t8wCpZuo_ly6trEK-xHB7zo,96
+revolve2/ci_group/planar_robot_representation.py,sha256=nEUZqPal4QueCBuaKl6Hvbd1PDQXqvQdLI2TB1JBiKQ,5754
+revolve2/ci_group/modular_robots_v2.py,sha256=A40Nw_x936vJiOJ8RBUAbcIu34fpx-q-og1W3Y6NTt0,6585
+revolve2/ci_group/py.typed,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+revolve2/ci_group/terrains.py,sha256=gDwWO1ex7Q8qhxUIoEPbpLO0rQlcCSfky32C1TGn1dQ,4188
+revolve2/ci_group/simulation_parameters.py,sha256=RIMpWf6L_Un4hhVwRa9gk3DQFp5RiSvPy98LYTCkiKo,1180
+revolve2/ci_group/morphological_novelty_metric/_morphological_novelty_metric.py,sha256=62_pe2fzyHGzgIv9C-7_uE-u-B9pYujoDBzgLx2Q7Mw,5468
+revolve2/ci_group/morphological_novelty_metric/calculate_novelty.pyi,sha256=GxpO-9j0E6d4vCnFud8CsZ9lp47oFw9NCWjtpOHqhVY,252
+revolve2/ci_group/morphological_novelty_metric/__init__.py,sha256=FVbQgADSjZv9mzoVGq528c8B7DU9yoco1UL7D-NIwis,401
+revolve2/ci_group/morphological_novelty_metric/_calculate_novelty.pyx,sha256=9Eq5jQ--DSGpo-bL0MCGxeT2xJ1X9OA_pi_PPkvGyj0,2915
+revolve2/ci_group/morphological_novelty_metric/_build_cmodule.py,sha256=qnpZNZvf8yIms4Oz8ovKaapjEPUyhmj1BLyro51cT5U,1456
+revolve2/ci_group/morphological_novelty_metric/_coordinate_operations.py,sha256=_to2o5yqLSDsqGd0qzzIzkhFcYJFngkXZaaAgZbWf7k,3919
+revolve2/ci_group/morphological_novelty_metric/calculate_novelty.cpython-310-x86_64-linux-gnu.so,sha256=Nsvtp_GMChD5CjC3XwA-0azQyF-M0rJh0fevipgy7_0,1517536
+revolve2/ci_group/ci_lab_utilities/_ip_camera.py,sha256=JMptV42BK0wZ5_aWgZwCxu-Smruw4gsaEkFK9CAY5do,6204
+revolve2/ci_group/ci_lab_utilities/_calibrate_camera.py,sha256=WvMCXXxaiDQ6qTTJABb-9yMhFdYlCaIigY8Sh3tldpM,3154
+revolve2/ci_group/ci_lab_utilities/__init__.py,sha256=rmIIr8zZGKGjNWUAznxsxV0-aV9vnxOIELsyiSSpNoE,172
+revolve2/ci_group/genotypes/__init__.py,sha256=O1kH8-2IZGuvj7KsWGSZS6hHusFBfJpb6g7DkU2g1wU,45
+revolve2/ci_group/genotypes/cppnwin/_random_multineat_genotype.py,sha256=4_2Ual0XzhMWnbFixpWQsSUmE09FRYbP-ZdYcwECA68,1728
+revolve2/ci_group/genotypes/cppnwin/_multineat_genotype_pickle_wrapper.py,sha256=76w7sWoypN5ZkWuxUGsOvKnd9FCYWx0UZwW2bGcrfsE,809
+revolve2/ci_group/genotypes/cppnwin/__init__.py,sha256=4zkXp-Ke4cNLi3i_GpTgAXI9MDj59VVLRQNKzDc88Pw,101
+revolve2/ci_group/genotypes/cppnwin/_multineat_rng_from_random.py,sha256=JUdbv83v7pHaLZL5Fz6VS4eBt7Ogxp6ZnTZCGEZlRZU,359
+revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_cpg_network_neighbor_v1.py,sha256=9x-4M04m7Q3RmLcNAJ7w0GIT6AUgd-RSjM3eii2Elic,2669
+revolve2/ci_group/genotypes/cppnwin/modular_robot/_multineat_params.py,sha256=_aKeeg7hPUW-WIYxzduleBoE_HNeyLAnq4toJ4jwInI,1831
+revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg.py,sha256=oVZNM7BKmD153AeK03KGkZW_0-3T597oM8xIe-ByroE,3744
+revolve2/ci_group/genotypes/cppnwin/modular_robot/__init__.py,sha256=XvsxpiLIUIqtZd1gIqOqoURyiXNFhccLLd5qEAJWu4s,321
+revolve2/ci_group/genotypes/cppnwin/modular_robot/_brain_genotype_cpg_orm.py,sha256=3BWy4vmQERFuz3sgoGni8Rl0hEnvTm5AEgwyDqwXniQ,4208
+revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/__init__.py,sha256=AIatphTZhbHMfla-iY4gUbKGUpH3ekeRedb_eyEGmtg,193
+revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_orm_v1.py,sha256=9g-g7UCGt7TznG5O44w1KJFGrVUT7-P9LgrYvs0JYlw,4052
+revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_develop.py,sha256=EY_op3ZmqKdeI5rGuwJClD2xOPUcsCE1Vj-3xoOZ7bo,4721
+revolve2/ci_group/genotypes/cppnwin/modular_robot/v1/_body_genotype_v1.py,sha256=yL7qSRufQHfPJ_YDw7FHEX8pKou5ByztOAIryp5Mz6U,3583
+revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_orm_v2.py,sha256=PEs66IXE9XQCXX1IlsS7JTiIDOoRi4m9rPzLJNG1W84,4048
+revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_genotype_v2.py,sha256=5CqC617PFY9TdOL8Lv1Vt1oBvigzYN6stwDsiFslQgI,3579
+revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/__init__.py,sha256=qYwaOH-piPcOTvvfkIMYqmrJ3X7IsWDydrkTQSMT16s,193
+revolve2/ci_group/genotypes/cppnwin/modular_robot/v2/_body_develop.py,sha256=NRGHL7bqdZBWv9FAMD4VciyEHeeNau_1u9Go5bO_pzM,5919
+revolve2/ci_group/interactive_objects/__init__.py,sha256=YVflGhr8RfYN_G_koGZ2P5bofHBjlI8MXY4EpXAzqLI,108
+revolve2/ci_group/interactive_objects/_ball.py,sha256=jsgncCP3SN5gtjJqw0GW4fVK4lLnx5QcB4divbeLDj4,1235
```

